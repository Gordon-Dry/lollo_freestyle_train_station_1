local transf = require 'transf'
local vec3 = require 'vec3'


function data()
	-- print('old con, params are set =')
	-- debugPrint(moduleHelpers.getParams())
	return {
		type = 'STREET_STATION_CARGO',
		description = {
			name = _("Roadside lorry bay"),
			description = _("Roadside lorry loading / unloading bay."),
		},
		availability = {
			yearFrom = 1925, -- -1,
			yearTo = 0, -- -1, -- 0
		},
		order = 5005,
		-- soundConfig = {
		-- 	soundSet = { name = "lollo_lorry_bay" }
		-- },
		autoRemovable = false,
		skipCollision = true, -- we need this to change the street type when reconfiguring
		params = {
            {
                key = 'fileName',
                name = 'File Name',
                values = {
                    'dummy',
                },
                defaultIndex = 0
            }
        },
		updateFn = function(params)
			print('updateFn starting, params =')
			debugPrint(params)
			-- LOLLO NOTE I cannot call the api from here, sigh.
			local result = {
				colliders = {},
				-- coord2terminalInfo = {},
				cost = 1000,
				edgeLists = {},
				groundFaces = {},
				models = {
					{
						id = 'lollo_freestyle_train_station/icon/blue.mdl',
                        transf = {1, 0, 0, 0,
                            0, 1, 0, 0,
                            0, 0, 1, 0,
                            0, 0, 0, 1},
					},
				},
				stations = {},
				terminalGroups = {},
				terrainAlignmentLists = {},
			}
--[[
			result.terminateConstructionHookBAK = function()
				-- this fires after the user has added a module
				-- print('LOLLO starting terminateConstructionHook')
				-- print('LOLLO result.models =')
				-- debugPrint(result.models)
				-- local cargoAreaModelIndexesBase0 = slotUtils.getCargoAreaModelIndexesBase0(result.models)
				local allCargoAreaModelIndexesBase0 = slotUtils.getCargoAreaModelIndexesBase0Simple(result.models)
				local allCargoLinkIndexesBase0 = slotUtils.getCargoLinksModelIndexesBase0Simple(result.models)
				-- print('LOLLO cargoAreaModelIndexesBase0 =')
				-- debugPrint(cargoAreaModelIndexesBase0)
				-- print('LOLLO allCargoAreaModelIndexesBase0 =')
				-- debugPrint(allCargoAreaModelIndexesBase0)
				-- LOLLO TODO in future, if you add more lorry bays, only take the non-adjacent ones
				local lorryBayModelIndexesBase0 = slotUtils.getLorryBayModelIndexesBase0(result.models)
				local vehicleEdgeModelIndexesBase0 = slotUtils.getVehicleEdgeModelIndexesBase0(result.models)
				-- print('LOLLO lorryBayModelIndexesBase0 =')
				-- debugPrint(lorryBayModelIndexesBase0)
				-- print('LOLLO vehicleEdgeModelIndexesBase0 =')
				-- debugPrint(vehicleEdgeModelIndexesBase0)

				result.stations = {
					{
						tag = 0, -- in the stock station, this is 0 for cargo and 1 for passengers
						terminals = { } -- 0 is the position of the linked terminal group, in base 0
					}
				}
				result.terminalGroups = {}
				local vehicleEdgeModelIndexBase0_Counter = 0
				-- for _, vehicleEdge in pairs(lorryBayModelIndexesBase0) do
				for _, vehicleEdgeModelIndex in pairs(vehicleEdgeModelIndexesBase0) do
					table.insert(
						result.terminalGroups,
						{
							tag = vehicleEdgeModelIndexBase0_Counter,
							terminals = {
								{ vehicleEdgeModelIndex, 0 }
							}
						}
					)

					-- local adjacentCargoAreas = slotUtils.getAdjacentValues(cargoAreaModelIndexesBase0, vehicleEdge.x, vehicleEdge.y)
					-- print('LOLLO adjacentCargoAreas = ')
					-- debugPrint(adjacentCargoAreas)
					-- for _, v in pairs(adjacentCargoAreas) do
					-- 	table.insert(result.terminalGroups[#result.terminalGroups].terminals, {v, 0})
					-- end

					for _, modelIndex in pairs(lorryBayModelIndexesBase0) do
						table.insert(result.terminalGroups[#result.terminalGroups].terminals, {modelIndex, 0})
					end

					for _, modelIndex in pairs(allCargoAreaModelIndexesBase0) do
						table.insert(result.terminalGroups[#result.terminalGroups].terminals, {modelIndex, 0})
					end

					-- LOLLO NOTE the following is required to make the links visible.
					-- Missing this, their lanes will work but their models won't be displayed.
					for _, modelIndex in pairs(allCargoLinkIndexesBase0) do
						table.insert(result.terminalGroups[#result.terminalGroups].terminals, {modelIndex, 0})
					end

					table.insert(result.stations[1].terminals, vehicleEdgeModelIndexBase0_Counter)
					vehicleEdgeModelIndexBase0_Counter = vehicleEdgeModelIndexBase0_Counter + 1
				end

				-- for lorryBayCounter = 1, tagCounterBase0 do
				-- 	table.insert(result.stations[1].terminals, lorryBayCounter - 1)
				-- end
				-- avoid dump when configuring
				if #(result.stations[1].terminals) == 0 then
					table.insert(result.stations[1].terminals, 0)
				end

				-- it should output something like (this example has one terminal made of two adjacent bits)
				-- stock result.stations =
				-- 	{
				-- 		{
				-- 			tag = 0, -- in the stock station, this is 0 for cargo and 1 for passengers
				-- 			terminals = { 0 } -- 0 is the position of the linked terminal group, in base 0
				-- 		}
				-- 	}
				-- stock result.terminalGroups =
				-- {
				-- 	{
				-- 		tag = -1, -- possibly useless, try to keep the m all different tho
				-- 		terminals = {
				-- 			{ 22, 0 }, -- 22 is the position of a model with a terminal, in base 0
				-- 			{ 25, 0 }, -- 0 is always 0 in the stock station, it is something like a terminal number
				-- 		}
				-- 	}
				-- }

				-- print('LOLLO lollo_freestyle_train_station leaving terminateConstructionHook')
				-- print('LOLLO result.models = ')
				-- debugPrint(result.models)
				-- print('LOLLO result.stations = ')
				-- debugPrint(result.stations)
				-- print('LOLLO result.terminalGroups = ')
				-- debugPrint(result.terminalGroups)
			end
]]
			return result
		end,
--[[ 		preProcessFn = function(modules, change, three)
			-- this fires when the user adds or removes a module
			-- print('LOLLO preProcessFn')
			-- print('modules =')
			-- debugPrint(modules)
			-- print('change =')
			-- debugPrint(change)
			-- default behaviour
			if change.added then
				modules[change.slotId] = change.module
			else
				modules[change.slotId] = nil
			end
			-- airport behaviour
			-- if change.added then
			-- 	if change.slotId == landingSlotId + 1 then
			-- 		modules[landingSlotId + 0] = nil
			-- 	elseif change.slotId == landingSlotId + 0 then
			-- 		modules[landingSlotId + 1] = nil
			-- 	elseif change.slotId == landingSlotId + 2 then
			-- 		modules[landingSlotId + 3] = nil
			-- 	elseif change.slotId == landingSlotId + 3 then
			-- 		modules[landingSlotId + 2] = nil
			-- 	end
			-- 	modules[change.slotId] = change.module
			-- else
			-- 	modules[change.slotId] = nil
			-- end
			return modules
        end, ]]
		upgradeFn = function(_)
            print('LOLLO upgradeFn') -- never fires
            -- LOLLO NOTE the game wants this function to be defined, even if it returns an empty table.
            -- If you leave it out, adding and removing tram tracks won't work.
            -- (Bus lanes don't work anyway.)
            return {}
        end,
	}
end