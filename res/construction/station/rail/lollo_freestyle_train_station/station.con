local _constants = require('lollo_freestyle_train_station.constants')
local arrayUtils = require('lollo_freestyle_train_station.arrayUtils')
local logger = require('lollo_freestyle_train_station.logger')
local moduleHelpers = require('lollo_freestyle_train_station.moduleHelpers')
local slotHelpers = require('lollo_freestyle_train_station.slotHelpers')
local transfUtilsUG = require 'transf'
local transfUtils = require('lollo_freestyle_train_station.transfUtils')

-- LOLLO NOTE
-- Instead of different cargo platforms with different widths, we could only use 5m areas for all,
-- and add new modules for extra space, parallel to the platform-tracks.
-- However, it is easier to place more platform-tracks upfront than add modules later,
-- so we go this way.

-- LOLLO NOTE we need skipCollision = false in the construction
-- coz we don't want to check for crazy stuff on a non-grid pattern.
-- However, it can be trouble.
-- Perhaps you bury the modules into the ground, like with the lorry station?
-- If I crop the platform tracks outside the station, there are no more collisions!
-- If I replace the track definition of my platform-track with the stock track,
-- the problem still occurs.
-- If I add the edgeLists in terminateConstructionHook, it does not help.
-- The trick was to carefully avoid anything even grazing on the neighbour edge:
-- even a collision-free model with a path can make trouble.
-- It's also important to assign void bounding boxes and colliders to certain models,
-- as opposed to not assigning any, which fails to turn off collisions.
-- When configuring a modular construction, the spacing is vital coz it covers the area that the game checks for collisions,
-- with own or third objects. The height assigns a height to this area, turning it into a collidable parallelepiped.

-- LOLLO NOTE we add a "subways" indexed table with the same indexes as params.modules, to hold extra information
-- that is, the transf. If a module is deleted in the game, its matching subways[] entry may be still around.
-- As soon as a new subway is built, its subways[] will be updated.
-- So, when querying params.subways[slotId], make sure that params.modules[slotId] also exists.

-- LOLLO NOTE try building a station next to a platform and onto a track
-- belonging to another terminal: you can. You shouldn't tho. Adding colliders into the modules does not help.
-- The proper way would be to check the neighbours before assigning a slot,
-- but this can be expensive and complicated in a free layout such as this.

function data()
	return {
		type = 'RAIL_STATION',
		description = {
			name = _("LolloFreestyleTrainStationName"),
			description = _("LolloFreestyleTrainStationDesc"),
		},
		availability = {
			yearFrom = -1, -- 1925, -- -1,
			yearTo = -1, -- -1, -- 0
		},
		order = 5005,
		soundConfig = {
			soundSet = { name = "station_cargo_old" }
		},
		autoRemovable = false,
		skipCollision = false, -- see the notes
		params = { -- keep it empty or it will crash coz it won't find the params, which I pass when building the construction
            -- {
            --     key = 'fileName',
            --     name = 'File Name',
            --     values = {
            --         'dummy',
            --     },
            --     defaultIndex = 0
            -- }
        },
		updateFn = function(params)
			logger.print('station.con updateFn starting')
			-- logger.print('updateFn starting, params =') logger.debugPrint(params)
			-- logger.print('station.con updateFn starting, params.modules =') logger.debugPrint(params.modules)
			-- LOLLO TODO sometimes, there are too many modules of type trackSpeed or trackElectrification
			-- It seems fixed, but keep checking it.
			if not params.modules then params.modules = {} end

			-- LOLLO NOTE I cannot call the api from here, sigh. api is there, but api.res is NIL. Also game is there, but game.interface is NIL
			local result = {
				colliders = {},
				-- coord2terminalInfo = {},
                cost = 1000,
                demangleId = slotHelpers.demangleId,
                edgeLists = {},
				groundFaces = {},
				labelText = {},
                mangleId = slotHelpers.mangleId,
				models = {
					-- {
					-- 	id = 'lollo_freestyle_train_station/icon/blue.mdl',
					-- 	tag = 'stationTag',
                    --     transf = {1, 0, 0, 0,
                    --         0, 1, 0, 0,
                    --         0, 0, 1, 0,
                    --         0, 0, 0, 1},
					-- },
                },
                slotConfig = {
					-- LOLLO NOTE these guys skip the collision check between the spacing rectangle
					-- of the module being placed and the spacing rectangles of the already built modules.
					-- they also skip the collision check between the spacing rectangle
					-- of the module being placed and the objects outside the construction (the slot does not turn red while proposing a placement).
					-- If I skip the sloped area collisions there will be trouble tho!
					-- [_constants.slopedCargoArea1x5ModuleType] = {
					-- 	maxModules = -1,
					-- 	message = nil, --'LOLLO slotConfig message',
					-- 	skipCollisionCheck = true,
					-- },
					-- [_constants.slopedPassengerArea1x5ModuleType] = {
					-- 	maxModules = -1,
					-- 	message = nil, --'LOLLO slotConfig message',
					-- 	skipCollisionCheck = true,
					-- },
					-- [_constants.slopedCargoArea1x10ModuleType] = {
					-- 	maxModules = -1,
					-- 	message = nil, --'LOLLO slotConfig message',
					-- 	skipCollisionCheck = true,
					-- },
					-- [_constants.slopedPassengerArea1x10ModuleType] = {
					-- 	maxModules = -1,
					-- 	message = nil, --'LOLLO slotConfig message',
					-- 	skipCollisionCheck = true,
					-- },
					-- [_constants.slopedCargoArea1x20ModuleType] = {
					-- 	maxModules = -1,
					-- 	message = nil, --'LOLLO slotConfig message',
					-- 	skipCollisionCheck = true,
					-- },
					-- [_constants.slopedPassengerArea1x20ModuleType] = {
					-- 	maxModules = -1,
					-- 	message = nil, --'LOLLO slotConfig message',
					-- 	skipCollisionCheck = true,
					-- },
					[_constants.trackElectrificationModuleType] = {
						maxModules = -1,
						message = nil, --'LOLLO slotConfig message',
						skipCollisionCheck = true,
					},
					[_constants.trackSpeedModuleType] = {
						maxModules = -1,
						message = nil, --'LOLLO slotConfig message',
						skipCollisionCheck = true,
					},
					-- [_constants.cargoTerminalModuleType] = {
					-- 	maxModules = -1,
					-- 	message = nil, --'LOLLO slotConfig message',
					-- 	skipCollisionCheck = true,
					-- },
					-- [_constants.passengerTerminalModuleType] = {
					-- 	maxModules = -1,
					-- 	message = nil, --'LOLLO slotConfig message',
					-- 	skipCollisionCheck = true,
					-- },
				},
                slots = {},
				stations = {},
				terminalGroups = {},
				terrainAlignmentLists = { { -- LOLLO NOTE this thing with the empty faces is required , otherwise the game will make its own alignments, with spikes and all on bridges or tunnels.
					type = "EQUAL",
					optional = true,
					faces =  { }
				} },
			}

			local occupiedInfo = {
				crossConnectorsWithFlatAreas = { },
				crossConnectorsWithSlopedAreas = { },
			}
			local _getOccupiedInfo4FlatAreas = function(t, i)
				if occupiedInfo.crossConnectorsWithFlatAreas[t] == nil or occupiedInfo.crossConnectorsWithFlatAreas[t][i] == nil then
					return nil
				else
					return occupiedInfo.crossConnectorsWithFlatAreas[t][i]
				end
			end
			local _setOccupiedInfo4FlatAreas = function(t, i, newId)
				if occupiedInfo.crossConnectorsWithFlatAreas[t] == nil then
					occupiedInfo.crossConnectorsWithFlatAreas[t] = {}
				end
				occupiedInfo.crossConnectorsWithFlatAreas[t][i] = newId
			end
			local _getOccupiedInfo4SlopedAreas = function(t, i)
				if occupiedInfo.crossConnectorsWithSlopedAreas[t] == nil or occupiedInfo.crossConnectorsWithSlopedAreas[t][i] == nil then
					return { id = nil, yShift = 0 }
				else
					-- logger.print('get occupiedInfo.crossConnectorsWithSlopedAreas[t][i] =') logger.debugPrint(occupiedInfo.crossConnectorsWithSlopedAreas[t][i])
					return occupiedInfo.crossConnectorsWithSlopedAreas[t][i]
				end
			end
			local _setOccupiedInfo4SlopedAreas = function(t, i, newId, yShift)
				if occupiedInfo.crossConnectorsWithSlopedAreas[t] == nil then
					occupiedInfo.crossConnectorsWithSlopedAreas[t] = {}
				end
				-- logger.print('set occupiedInfo.crossConnectorsWithSlopedAreas[t][i] =') logger.debugPrint(occupiedInfo.crossConnectorsWithSlopedAreas[t][i])
				occupiedInfo.crossConnectorsWithSlopedAreas[t][i] = { id = newId, yShift = yShift or 0 }
			end
			local _occupySlopedAreas = function(t, i, slotId, slotTypeId, yShift)
				if params.modules[slotId] ~= nil then
					if i > 1 then _setOccupiedInfo4SlopedAreas(t, i-1, slotTypeId, yShift) end
					_setOccupiedInfo4SlopedAreas(t, i, slotTypeId, yShift)
					if i+1 <= #params.terminals[t].centrePlatformsRelative then _setOccupiedInfo4SlopedAreas(t, i+1, slotTypeId, yShift) end
					if i+2 <= #params.terminals[t].centrePlatformsRelative then _setOccupiedInfo4SlopedAreas(t, i+2, slotTypeId, yShift) end
				end
			end

			result.terminateConstructionHookInfo = {
				crossConnectorPositions = {},
				isAnyCargoTerminal = false,
				isAnyPassengerTerminal = false,
				liftBottomPositions = {},
				openStairsOrLiftsPositions = {},
				trackCrossingPositions = {},
				tunnelStairsTopPositions = {},
				tunnelStairsBottomPositions = {},
				underpassPositionsOnGround = {},
				underpassPositionsOnBridge = {},
				vehicleNodes = {}
			}

			result.laneZs = {}

			for t = 1, #params.terminals do
				-- this is only a test to see if the transformation was ok. They match beautifully! Use this when talking to UG.
				-- if #result.edgeLists > 0 then
				-- 	local firstPosTanX2 = result.edgeLists[1].edges
				-- 	logger.print('firstPosTanX2 =') logger.debugPrint(firstPosTanX2)
				-- 	local retransformedFirstEdge = transfUtils.getPosTanX2Transformed(firstPosTanX2, params.myTransf)
				-- 	logger.print('retransformed first edge =') logger.debugPrint(retransformedFirstEdge)
				-- end
				local _laneZ = _constants.platformHeight -- we could also make it vary for each terminal:
				-- everything except the platforms and the terminal deco will vary along with it.
				result.laneZs[t] = _laneZ

				local isCargoTerminal = params.terminals[t].isCargo
				if isCargoTerminal then result.terminateConstructionHookInfo.isAnyCargoTerminal = true else result.terminateConstructionHookInfo.isAnyPassengerTerminal = true end

				local isTrackOnPlatformLeft = params.terminals[t].isTrackOnPlatformLeft

				local function _addPlatformRoofs()
					if isCargoTerminal then return end
					local iMax = #params.terminals[t].centrePlatformsRelative
					local iss = {}
					for i = 2, iMax, 3 do iss[#iss+1] = i end
					-- fill the last if any
					if math.fmod(iMax, 3) == 1 then iss[#iss+1] = iMax end

					for _, i in pairs(iss) do
						local cpl = params.terminals[t].centrePlatformsRelative[i]
						-- if cpl.type ~= 2 then -- no platform roofs in tunnels
							local myId = result.mangleId(t, i, _constants.idBases.platformRoofSlotId)
							table.insert(result.slots, {
								-- height = 0,
								id = myId,
								spacing = {-0.1, 2, 1, 1},
								transf = moduleHelpers.getPlatformObjectTransf_WithYRotation(cpl.posTanX2),
								type = _constants.platformRoofModuleType,
							})
						-- end
					end
				end
				_addPlatformRoofs()

				local function _addOutsideExtensions()
					local iMax = #params.terminals[t].centrePlatformsRelative
					local iss = {}
					for i = 2, iMax, 3 do iss[#iss+1] = i end
					-- fill the last if any
					if math.fmod(iMax, 3) == 1 then iss[#iss+1] = iMax end

					for _, i in pairs(iss) do
						local cpl = params.terminals[t].centrePlatformsRelative[i]
						if (cpl.type == 0 or cpl.type == 1) -- only on ground and on bridges
						and not(isCargoTerminal)
						-- and params.terminals[t].slopedAreasFineRelative[2.5] -- thin sloped areas were added later and they are burnt into the initial data
						then
							-- so they cannot be added willy nilly
							if not(_getOccupiedInfo4SlopedAreas(t, i).id) or _getOccupiedInfo4SlopedAreas(t, i).id == _constants.idBases.slopedArea1x2_5SlotId then
								local yShiftOutside, yShiftOutside4StreetAccess = moduleHelpers.slopedAreas.getYShift(params, t, i, 2.5)
								local myId = result.mangleId(t, i, _constants.idBases.slopedArea1x2_5SlotId)
								table.insert(result.slots, {
									-- height = 0,
									id = myId,
									-- 0, 3} and 3, 0} shift this along the track so it avoids flat areas,
									-- which have the same thing reversed.
									-- This way, sloped areas and flat areas can be easily combined.
									spacing = isTrackOnPlatformLeft and {2, 0, 0, 3} or {0, 2, 3, 0},
									transf = transfUtilsUG.mul(
										moduleHelpers.getPlatformObjectTransf_WithYRotation(cpl.posTanX2),
										{ 0, 1, 0, 0,  -1, 0, 0, 0,  0, 0, 1, 0,  0, yShiftOutside, _constants.platformSideBitsZ, 1 }
									),
									type = _constants.slopedPassengerArea1x2_5ModuleType,
								})
								_occupySlopedAreas(t, i, myId, _constants.idBases.slopedArea1x2_5SlotId, yShiftOutside4StreetAccess)
							end
						end
						if cpl.type == 0 then -- only on ground
							if not(_getOccupiedInfo4SlopedAreas(t, i).id) or _getOccupiedInfo4SlopedAreas(t, i).id == _constants.idBases.slopedArea1x5SlotId then
								local yShiftOutside, yShiftOutside4StreetAccess = moduleHelpers.slopedAreas.getYShift(params, t, i, 5)
								local myId = result.mangleId(t, i, _constants.idBases.slopedArea1x5SlotId)
								table.insert(result.slots, {
									-- height = 0,
									id = myId,
									-- 0, 3} and 3, 0} shift this along the track so it avoids flat areas,
									-- which have the same thing reversed.
									-- This way, sloped areas and flat areas can be easily combined.
									spacing = isTrackOnPlatformLeft and {2, 0, 0, 3} or {0, 2, 3, 0},
									transf = transfUtilsUG.mul(
										moduleHelpers.getPlatformObjectTransf_WithYRotation(cpl.posTanX2),
										{ 0, 1, 0, 0,  -1, 0, 0, 0,  0, 0, 1, 0,  0, yShiftOutside, _constants.platformSideBitsZ, 1 }
									),
									type = isCargoTerminal and _constants.slopedCargoArea1x5ModuleType or _constants.slopedPassengerArea1x5ModuleType,
								})
								_occupySlopedAreas(t, i, myId, _constants.idBases.slopedArea1x5SlotId, yShiftOutside4StreetAccess)
							end
							if not(_getOccupiedInfo4SlopedAreas(t, i).id) or _getOccupiedInfo4SlopedAreas(t, i).id == _constants.idBases.slopedArea1x10SlotId then
								local yShiftOutside, yShiftOutside4StreetAccess = moduleHelpers.slopedAreas.getYShift(params, t, i, 10)
								local myId = result.mangleId(t, i, _constants.idBases.slopedArea1x10SlotId)
								table.insert(result.slots, {
									-- height = 0,
									id = myId,
									spacing = isTrackOnPlatformLeft and {3, 2, 0, 3} or {2, 3, 3, 0},
									transf = transfUtilsUG.mul(
										moduleHelpers.getPlatformObjectTransf_WithYRotation(cpl.posTanX2),
										{ 0, 1, 0, 0,  -1, 0, 0, 0,  0, 0, 1, 0,  0, yShiftOutside, _constants.platformSideBitsZ, 1 }
									),
									type = isCargoTerminal and _constants.slopedCargoArea1x10ModuleType or _constants.slopedPassengerArea1x10ModuleType,
								})
								_occupySlopedAreas(t, i, myId, _constants.idBases.slopedArea1x10SlotId, yShiftOutside4StreetAccess)
							end

							if not(_getOccupiedInfo4SlopedAreas(t, i).id) or _getOccupiedInfo4SlopedAreas(t, i).id == _constants.idBases.slopedArea1x20SlotId then
								local yShiftOutside, yShiftOutside4StreetAccess = moduleHelpers.slopedAreas.getYShift(params, t, i, 20)
								local myId = result.mangleId(t, i, _constants.idBases.slopedArea1x20SlotId)
								table.insert(result.slots, {
									-- height = 0,
									id = myId,
									spacing = isTrackOnPlatformLeft and {8, 4, 0, 3} or {4, 8, 3, 0},
									transf = transfUtilsUG.mul(
										moduleHelpers.getPlatformObjectTransf_WithYRotation(cpl.posTanX2),
										{ 0, 1, 0, 0,  -1, 0, 0, 0,  0, 0, 1, 0,  0, yShiftOutside, _constants.platformSideBitsZ, 1 }
									),
									type = isCargoTerminal and _constants.slopedCargoArea1x20ModuleType or _constants.slopedPassengerArea1x20ModuleType,
								})
								_occupySlopedAreas(t, i, myId, _constants.idBases.slopedArea1x20SlotId, yShiftOutside4StreetAccess)
							end
						end
					end
				end
				_addOutsideExtensions()

				local function _addStreetAccess()
					for i = 2, #params.terminals[t].centrePlatformsRelative do -- cross connectors, which are nodes, are 1 more then centre platforms, which are edges, so I go on until the end
						local cpl = params.terminals[t].centrePlatformsRelative[i]
						local cplPrevious = params.terminals[t].centrePlatformsRelative[i-1]
						if cpl.type ~= 2 and cplPrevious.type ~= 2 then -- no tunnels
							local isUnderpass = params.modules[result.mangleId(t, i, _constants.idBases.underpassSlotId)] ~= nil
							local isNextUnderpass = i < #params.terminals[t].centrePlatformsRelative
								and params.modules[result.mangleId(t, i+1, _constants.idBases.underpassSlotId)] ~= nil
								or false
							local isPreviousUnderpass = i > 1
								and params.modules[result.mangleId(t, i-1, _constants.idBases.underpassSlotId)] ~= nil
								or false
							local crossConnectorPosTanX2 = params.terminals[t].crossConnectorsRelative[i].posTanX2
							if not(isUnderpass) and not(isPreviousUnderpass) then
								if cpl.type == 0 then -- ground
									if not(_getOccupiedInfo4FlatAreas(t, i))
									or _getOccupiedInfo4FlatAreas(t, i) == _constants.idBases.flatStairsOrRampSlotId then
										local yShift = cpl.width + _getOccupiedInfo4SlopedAreas(t, i).yShift
										local myPosTanX2 = transfUtils.getExtrapolatedPosTanX2Continuation(crossConnectorPosTanX2, yShift)
										local myTransf = transfUtilsUG.mul(
											moduleHelpers.getPlatformObjectTransf_AlwaysVertical(myPosTanX2),
											{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1 }
										)
										local myId = result.mangleId(t, i, _constants.idBases.flatStairsOrRampSlotId)
										table.insert(result.slots, {
											-- height = 0,
											id = myId,
											-- spacing = {-0.1, 1.5, -0.1, 0.9},
											spacing = {0.5, 1.5, -0.1, 1},
											transf = myTransf,
											type = isCargoTerminal and _constants.flatCargoRampModuleType or _constants.flatPassengerStairsModuleType,
										})
										if params.modules[myId] ~= nil then
											_setOccupiedInfo4FlatAreas(t, i, _constants.idBases.flatStairsOrRampSlotId)
										end
									end
									if not(_getOccupiedInfo4FlatAreas(t, i))
									or _getOccupiedInfo4FlatAreas(t, i) == _constants.idBases.flatArea5x5SlotId then
										local yShift = cpl.width + 5 + _getOccupiedInfo4SlopedAreas(t, i).yShift
										local myPosTanX2 = transfUtils.getExtrapolatedPosTanX2Continuation(crossConnectorPosTanX2, yShift)
										local myTransf = transfUtilsUG.mul(
											moduleHelpers.getPlatformObjectTransf_AlwaysVertical(myPosTanX2),
											{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1 }
										)
										local myId = result.mangleId(t, i, _constants.idBases.flatArea5x5SlotId)
										table.insert(result.slots, {
											-- height = 0,
											id = myId,
											-- spacing = {-0.1, 3, -0.1, 2},
											spacing = {0.5, 3, -0.1, 2},
											transf = myTransf,
											type = isCargoTerminal and _constants.flatCargoArea5x5ModuleType or _constants.flatPassengerArea5x5ModuleType,
										})
										if params.modules[myId] ~= nil then
											_setOccupiedInfo4FlatAreas(t, i, _constants.idBases.flatArea5x5SlotId)
										end
									end
									if not(_getOccupiedInfo4FlatAreas(t, i))
									or _getOccupiedInfo4FlatAreas(t, i) == _constants.idBases.flatArea8x5SlotId then
										local yShift = cpl.width + 5 + _getOccupiedInfo4SlopedAreas(t, i).yShift
										local myPosTanX2 = transfUtils.getExtrapolatedPosTanX2Continuation(crossConnectorPosTanX2, yShift)
										local myTransf = transfUtilsUG.mul(
											moduleHelpers.getPlatformObjectTransf_AlwaysVertical(myPosTanX2),
											{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1 }
										)
										local myId = result.mangleId(t, i, _constants.idBases.flatArea8x5SlotId)
										table.insert(result.slots, {
											-- height = 0,
											id = myId,
											-- spacing = {-0.1, 3, -0.1, 3},
											spacing = {0.5, 3, -0.1, 3},
											transf = myTransf,
											type = isCargoTerminal and _constants.flatCargoArea8x5ModuleType or _constants.flatPassengerArea8x5ModuleType,
										})
										if not(isUnderpass) and not(isPreviousUnderpass) and params.modules[myId] ~= nil then
											_setOccupiedInfo4FlatAreas(t, i, _constants.idBases.flatArea8x5SlotId)
										end
									end
									if not(_getOccupiedInfo4FlatAreas(t, i))
									or _getOccupiedInfo4FlatAreas(t, i) == _constants.idBases.flatArea8x10SlotId then
										local yShift = cpl.width + 10 + _getOccupiedInfo4SlopedAreas(t, i).yShift
										local myPosTanX2 = transfUtils.getExtrapolatedPosTanX2Continuation(crossConnectorPosTanX2, yShift)
										local myTransf = transfUtilsUG.mul(
											moduleHelpers.getPlatformObjectTransf_AlwaysVertical(myPosTanX2),
											{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1 }
										)
										local myId = result.mangleId(t, i, _constants.idBases.flatArea8x10SlotId)
										table.insert(result.slots, {
											-- height = 0,
											id = myId,
											-- spacing = {-0.1, 3, -0.1, 3},
											spacing = {0.5, 3, -0.1, 3},
											transf = myTransf,
											type = isCargoTerminal and _constants.flatCargoArea8x10ModuleType or _constants.flatPassengerArea8x10ModuleType,
										})
										if not(isUnderpass) and not(isPreviousUnderpass) and params.modules[myId] ~= nil then
											_setOccupiedInfo4FlatAreas(t, i, _constants.idBases.flatArea8x10SlotId)
										end
									end
									if not(isCargoTerminal) then
										if not(_getOccupiedInfo4FlatAreas(t, i))
										or _getOccupiedInfo4FlatAreas(t, i) == _constants.idBases.flatStation0MSlotId then
											local yShift = cpl.width + _getOccupiedInfo4SlopedAreas(t, i).yShift
											local myPosTanX2 = transfUtils.getExtrapolatedPosTanX2Continuation(crossConnectorPosTanX2, yShift)
											local myTransf = transfUtilsUG.mul(
												moduleHelpers.getPlatformObjectTransf_AlwaysVertical(myPosTanX2),
												{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ + _constants.platformSideBitsZ, 1 }
											)
											local myId = result.mangleId(t, i, _constants.idBases.flatStation0MSlotId)
											table.insert(result.slots, {
												-- height = 0,
												id = myId,
												spacing = isTrackOnPlatformLeft and {1, 1, 3, -0.1} or {1, 1, -0.1, 3},
												transf = myTransf,
												type = _constants.flatPassengerStation0MModuleType,
											})
											if params.modules[myId] ~= nil then
												local lane2AreaTransf = transfUtils.get1MLaneTransf(
													{
														myPosTanX2[1][1][1],
														myPosTanX2[1][1][2],
														myPosTanX2[1][1][3] + _laneZ,
													},
													transfUtils.transf2Position(myTransf)
												)
												result.models[#result.models+1] = {
													id = _constants.passengerLaneModelId,
													transf = lane2AreaTransf
												}
												_setOccupiedInfo4FlatAreas(t, i, _constants.idBases.flatStation0MSlotId)
											end
										end
										if not(_getOccupiedInfo4FlatAreas(t, i))
										or _getOccupiedInfo4FlatAreas(t, i) == _constants.idBases.flatStation5MSlotId then
											local yShift = cpl.width + _getOccupiedInfo4SlopedAreas(t, i).yShift
											local myPosTanX2 = transfUtils.getExtrapolatedPosTanX2Continuation(crossConnectorPosTanX2, yShift)
											local myTransf = transfUtilsUG.mul(
												moduleHelpers.getPlatformObjectTransf_AlwaysVertical(myPosTanX2),
												{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1 }
											)
											local myId = result.mangleId(t, i, _constants.idBases.flatStation5MSlotId)
											table.insert(result.slots, {
												-- height = 0,
												id = myId,
												spacing = isTrackOnPlatformLeft and {1, 1, 3, -0.1} or {1, 1, -0.1, 3},
												transf = myTransf,
												type = _constants.flatPassengerStation5MModuleType,
											})
											if params.modules[myId] ~= nil then
												local lane2AreaTransf = transfUtils.get1MLaneTransf(
													{
														myPosTanX2[1][1][1],
														myPosTanX2[1][1][2],
														myPosTanX2[1][1][3] + _laneZ,
													},
													transfUtils.transf2Position(myTransf)
												)
												result.models[#result.models+1] = {
													id = _constants.passengerLaneModelId,
													transf = lane2AreaTransf
												}
												_setOccupiedInfo4FlatAreas(t, i, _constants.idBases.flatStation5MSlotId)
											end
										end
									end
								elseif cpl.type == 1 then -- bridge
									if not(isCargoTerminal) then
										if not(_getOccupiedInfo4FlatAreas(t, i))
										or _getOccupiedInfo4FlatAreas(t, i) == _constants.idBases.sideLiftSlotId then
											local yShift = cpl.width + _getOccupiedInfo4SlopedAreas(t, i).yShift
											local myPosTanX2 = transfUtils.getExtrapolatedPosTanX2Continuation(crossConnectorPosTanX2, yShift)
											local myTransf = transfUtilsUG.mul(
												moduleHelpers.getPlatformObjectTransf_AlwaysVertical(myPosTanX2),
												{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1 }
											)
											local myId = result.mangleId(t, i, _constants.idBases.sideLiftSlotId)
											table.insert(result.slots, {
												-- height = 0,
												id = myId,
												spacing = isTrackOnPlatformLeft and {1, 1, 3, -0.1} or {1, 1, -0.1, 3},
												transf = myTransf,
												type = _constants.passengerSideLiftModuleType,
											})
											if params.modules[myId] ~= nil then
												local underpassBottomTransf = transfUtilsUG.mul(
													myTransf,
													{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _constants.underpassZ, 1 }
												)
												if result.terminateConstructionHookInfo.underpassPositionsOnBridge[t] == nil then
													result.terminateConstructionHookInfo.underpassPositionsOnBridge[t] = {}
												end
												table.insert(
													result.terminateConstructionHookInfo.underpassPositionsOnBridge[t],
													{
														t = t,
														lanePosTanX2 = cpl.posTanX2,
														pos2Link = transfUtils.transf2Position(underpassBottomTransf)
													}
												)

												result.models[#result.models+1] = {
													id = _constants.passengerLaneModelId,
													transf = transfUtils.get1MLaneTransf(
														transfUtils.getPositionRaisedBy(myPosTanX2[1][1], _laneZ),
														transfUtils.transf2Position(myTransf)
													)
												}
												_setOccupiedInfo4FlatAreas(t, i, _constants.idBases.sideLiftSlotId)
											end
										end
										if i < #params.terminals[t].centrePlatformsRelative
										and not(isNextUnderpass)
										and (not(_getOccupiedInfo4FlatAreas(t, i))
										or _getOccupiedInfo4FlatAreas(t, i) == _constants.idBases.platformLiftSlotId) then
											local xyZoomFactor = isTrackOnPlatformLeft and 1 or -1
											local myTransf = transfUtilsUG.mul(
												moduleHelpers.getPlatformObjectTransf_AlwaysVertical(cpl.posTanX2),
												{ xyZoomFactor, 0, 0, 0,  0, xyZoomFactor, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1 }
											)
											local myId = result.mangleId(t, i, _constants.idBases.platformLiftSlotId)
											table.insert(result.slots, {
												-- height = 0,
												id = myId,
												spacing = isTrackOnPlatformLeft and {3, -0.1, 1, 1} or {-0.1, 3, 1, 1},
												transf = myTransf,
												type = _constants.passengerPlatformLiftModuleType,
											})
										end
									end
								end
							end
						end
					end
				end
				_addStreetAccess()

				local function _addTrackCrossings()
					-- if isCargoTerminal then return end
					-- cross connectors, which are nodes, are 1 more then centre platforms, which are edges, so I go on until the end
					-- I work with centrePlatformsFineRelative instead of centrePlatformsRelative so I get more accurate angles
					for ii = 2, #params.terminals[t].centrePlatformsFineRelative do
						local cpf = params.terminals[t].centrePlatformsFineRelative[ii]
						local cpfPrevious = params.terminals[t].centrePlatformsFineRelative[ii-1]
						if cpf.leadingIndex ~= cpfPrevious.leadingIndex then
							local i = cpf.leadingIndex
							local isUnderpass = params.modules[result.mangleId(t, i, _constants.idBases.underpassSlotId)] ~= nil
							local isPreviousUnderpass = i > 1
								and params.modules[result.mangleId(t, i-1, _constants.idBases.underpassSlotId)] ~= nil
								or false

							if not(isUnderpass) and not(isPreviousUnderpass) then
								local crossConnectorPosTanX2 = params.terminals[t].crossConnectorsRelative[i].posTanX2
								-- a bit of a bodge: I take the position from the connector,
								-- which has no knowledge of the slope,
								-- and the slope from the centre platform fine,
								-- which is very slightly shifted from the connector. Not too bad.
								local trackCrossingPosTanX2 = transfUtils.getPosTanX2Normalised(
									transfUtils.getPosTanX2Reversed(crossConnectorPosTanX2), -- cross connectors go from the platform border to its centre, here we go toward the edge
									cpf.width * 0.5 + 2.5 -- half platform width plus half track width is the centre of the track
								)
								local trackCrossingTransf = moduleHelpers.getPlatformObjectTransf_WithYRotation(cpf.posTanX2)
								trackCrossingTransf[13] = trackCrossingPosTanX2[2][1][1]
								trackCrossingTransf[14] = trackCrossingPosTanX2[2][1][2]
								trackCrossingTransf[15] = trackCrossingPosTanX2[2][1][3]

								local trackCrossingId = result.mangleId(t, i, _constants.idBases.trackCrossingSlotId)
								table.insert(result.slots, {
									-- height = 0,
									id = trackCrossingId,
									spacing = {1.5, -0.5, 1, 1}, -- avoid module collisions with terminal slots
									transf = trackCrossingTransf,
									type = _constants.trackCrossingModuleType,
								})

								-- add connecting lanes to existing modules
								-- they connect to passenger lanes and can be connected to roads nearby.
								-- they do not connect to cargo lanes, but the catchment area extends
								-- when nearby roads are connected, so it's good enough.
								if params.modules[trackCrossingId] ~= nil then
									local trackCrossingPos = transfUtils.getPositionRaisedBy(
										transfUtils.transf2Position(trackCrossingTransf),
										_constants.trackCrossingZ
									)
									result.models[#result.models+1] = {
										id = _constants.passengerLaneLinkableRaisedModelId,
										transf = transfUtils.get1MLaneTransf(
											trackCrossingPos,
											transfUtils.getPositionRaisedBy(crossConnectorPosTanX2[1][1], _laneZ)
										)
									}

									if result.terminateConstructionHookInfo.trackCrossingPositions[t] == nil then result.terminateConstructionHookInfo.trackCrossingPositions[t] = {} end
									local cpl = params.terminals[t].centrePlatformsRelative[cpf.leadingIndex]
									table.insert(
										result.terminateConstructionHookInfo.trackCrossingPositions[t],
										{
											t = t,
											lanePosTanX2 = cpl.posTanX2,
											pos = trackCrossingPos
										}
									)
								end
							end
						end
					end
				end
				_addTrackCrossings()

				local function _addLanesAcross()
					if isCargoTerminal then return end

					for i = 2, #params.terminals[t].centrePlatformsRelative do -- cross connectors, which are nodes, are 1 more then centre platforms, which are edges, so I go on until the end
						local isUnderpass = params.modules[result.mangleId(t, i, _constants.idBases.underpassSlotId)] ~= nil
						local isPreviousUnderpass = i > 1
							and params.modules[result.mangleId(t, i-1, _constants.idBases.underpassSlotId)] ~= nil
							or false
						-- local isPlatformLift = params.modules[result.mangleId(t, i, _constants.idBases.platformLiftSlotId)] ~= nil
						-- local isPreviousPlatformLift = i > 1
						-- 	and params.modules[result.mangleId(t, i-1, _constants.idBases.platformLiftSlotId)] ~= nil
						-- 	or false

						-- if not(isUnderpass) and not(isPreviousUnderpass) and not(isPlatformLift) and not(isPreviousPlatformLift) then
						if not(isUnderpass) and not(isPreviousUnderpass) then
							local crossConnectorPosTanX2 = params.terminals[t].crossConnectorsRelative[i].posTanX2
							local crossConnectorTransf = transfUtilsUG.mul(
								transfUtils.get1MLaneTransf(crossConnectorPosTanX2[1][1], crossConnectorPosTanX2[2][1]),
								{1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1}
							)
							result.models[#result.models+1] = {
								id = _constants.passengerLaneModelId,
								transf = crossConnectorTransf
							}
							if result.terminateConstructionHookInfo.crossConnectorPositions[t] == nil then result.terminateConstructionHookInfo.crossConnectorPositions[t] = {} end
							local cpl = params.terminals[t].centrePlatformsRelative[i]
							table.insert(
								result.terminateConstructionHookInfo.crossConnectorPositions[t],
								{
									t = t,
									lanePosTanX2 = cpl.posTanX2,
									pos = transfUtils.getPositionRaisedBy(crossConnectorPosTanX2[2][1], _laneZ)
								}
							)
						end
					end
				end
				_addLanesAcross()

				local function _addLanesAlong()
					if isCargoTerminal then return end

					local maxI = #params.terminals[t].centrePlatformsRelative - 1
					for i = 2, maxI do -- skip the outermost edges to avoid collisions, the game is very picky here.
						local cpl = params.terminals[t].centrePlatformsRelative[i]
						local isInTunnel = cpl.type == 2
						local isOnBridge = cpl.type == 1
						local isPlatformLift = params.modules[result.mangleId(t, i, _constants.idBases.platformLiftSlotId)] ~= nil
						local isStairsUp = params.modules[result.mangleId(t, i, _constants.idBases.tunnelStairsUpSlotId)] ~= nil
						local isStairsUpDown = params.modules[result.mangleId(t, i, _constants.idBases.tunnelStairsUpDownSlotId)] ~= nil
						local isOpenLift = params.modules[result.mangleId(t, i, _constants.idBases.openLiftSlotId)] ~= nil
                        local isOpenStairsUpLeft = params.modules[result.mangleId(t, i, _constants.idBases.openStairsUpLeftSlotId)] ~= nil
						local isNextOpenStairsUpLeft = i < maxI
							and params.modules[result.mangleId(t, i+1, _constants.idBases.openStairsUpLeftSlotId)] ~= nil
							or false
						local isOpenStairsUpRight = params.modules[result.mangleId(t, i, _constants.idBases.openStairsUpRightSlotId)] ~= nil
						local isNextOpenStairsUpRight = i > 2
							and params.modules[result.mangleId(t, i-1, _constants.idBases.openStairsUpRightSlotId)] ~= nil
							or false
						local isUnderpass = params.modules[result.mangleId(t, i, _constants.idBases.underpassSlotId)] ~= nil

						local myModelId = _constants.passengerLaneLinkableModelId -- _constants.passengerLaneModelId
						if isPlatformLift then myModelId = _constants.passengerLaneLiftModelId
						elseif isUnderpass then myModelId = _constants.passengerLaneUnderpassModelId
                        elseif isOpenLift then myModelId = _constants.passengerLaneOpenLiftModelId
						elseif isStairsUp then myModelId = _constants.passengerLaneTunnelStairsUpModelId
						elseif isStairsUpDown then myModelId = _constants.passengerLaneTunnelStairsUpDownModelId
						-- elseif isOpenStairsUpLeft then myModelId = _constants.passengerLaneOpenStairsUpTopModelId
						-- elseif isOpenStairsUpRight then myModelId = _constants.passengerLaneOpenStairsUpTopModelId
						elseif isNextOpenStairsUpLeft then myModelId = _constants.passengerLaneOpenStairsUpBottomNextModelId
						elseif isNextOpenStairsUpRight then myModelId = _constants.passengerLaneOpenStairsUpBottomPrevModelId
						end
						local centreLaneTransf = (isOpenStairsUpLeft or isOpenStairsUpRight)
							and transfUtils.get1MModelTransf(cpl.posTanX2[1][1], cpl.posTanX2[2][1])
							or transfUtils.get1MLaneTransf(cpl.posTanX2[1][1], cpl.posTanX2[2][1])
                        if (isOpenStairsUpLeft or isOpenStairsUpRight) then
                            if isOpenStairsUpLeft then
                                result.models[#result.models+1] = {
                                    id = _constants.passengerLaneOpenStairsUpTopNextModelId,
                                    transf = transfUtilsUG.mul(centreLaneTransf, {1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1})
                                }
                            end
                            if isOpenStairsUpRight then
                                result.models[#result.models+1] = {
                                    id = _constants.passengerLaneOpenStairsUpTopPrevModelId,
                                    transf = transfUtilsUG.mul(centreLaneTransf, {1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1})
                                }
                            end
                        else
                            result.models[#result.models+1] = {
                                id = myModelId,
                                transf = transfUtilsUG.mul(centreLaneTransf, {1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1})
                            }
                        end
						if isStairsUp then
							if result.terminateConstructionHookInfo.tunnelStairsTopPositions[t] == nil then
								result.terminateConstructionHookInfo.tunnelStairsTopPositions[t] = {}
							end
							table.insert(
								result.terminateConstructionHookInfo.tunnelStairsTopPositions[t],
								{
									t = t,
									lanePosTanX2 = cpl.posTanX2,
									pos2Link = transfUtils.transf2Position(
										transfUtilsUG.mul(
											centreLaneTransf,
											{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  _constants.underpassLengthM * 0.5, 0, _laneZ + _constants.tunnelStairsUpZ, 1 }
										)
									)
								}
							)
						elseif isStairsUpDown then
							if result.terminateConstructionHookInfo.tunnelStairsBottomPositions[t] == nil then
								result.terminateConstructionHookInfo.tunnelStairsBottomPositions[t] = {}
							end
							table.insert(
								result.terminateConstructionHookInfo.tunnelStairsBottomPositions[t],
								{
									t = t,
									lanePosTanX2 = cpl.posTanX2,
									pos2Link = transfUtils.transf2Position(
										transfUtilsUG.mul(
											centreLaneTransf,
											{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  _constants.underpassLengthM * 0.5, 0, _laneZ + _constants.underpassZ, 1 }
										)
									)
								}
							)
							if result.terminateConstructionHookInfo.tunnelStairsTopPositions[t] == nil then
								result.terminateConstructionHookInfo.tunnelStairsTopPositions[t] = {}
							end
							table.insert(
								result.terminateConstructionHookInfo.tunnelStairsTopPositions[t],
								{
									t = t,
									lanePosTanX2 = cpl.posTanX2,
									pos2Link = transfUtils.transf2Position(
										transfUtilsUG.mul(
											centreLaneTransf,
											{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  _constants.underpassLengthM * 0.5, 0, _laneZ + _constants.tunnelStairsUpZ, 1 }
										)
									)
								}
							)
						elseif (isUnderpass and isOnBridge) or isPlatformLift then
							if result.terminateConstructionHookInfo.underpassPositionsOnBridge[t] == nil then
								result.terminateConstructionHookInfo.underpassPositionsOnBridge[t] = {}
							end
							table.insert(
								result.terminateConstructionHookInfo.underpassPositionsOnBridge[t],
								{
									t = t,
									lanePosTanX2 = cpl.posTanX2,
									pos2Link = transfUtils.transf2Position(
										transfUtilsUG.mul(
											centreLaneTransf,
											{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  _constants.underpassLengthM * 0.5, 0, _laneZ + _constants.underpassZ, 1 }
										)
									)
								}
							)
						elseif isUnderpass then
							if result.terminateConstructionHookInfo.underpassPositionsOnGround[t] == nil then
								result.terminateConstructionHookInfo.underpassPositionsOnGround[t] = {}
							end
							table.insert(
								result.terminateConstructionHookInfo.underpassPositionsOnGround[t],
								{
									t = t,
									lanePosTanX2 = cpl.posTanX2,
									pos2Link = transfUtils.transf2Position(
										transfUtilsUG.mul(
											centreLaneTransf,
											{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  _constants.underpassLengthM * 0.5, 0, _laneZ + _constants.underpassZ, 1 }
										)
									)
								}
							)
						elseif (isOpenStairsUpLeft or isOpenStairsUpRight or isOpenLift) then
							if result.terminateConstructionHookInfo.openStairsOrLiftsPositions[t] == nil then
								result.terminateConstructionHookInfo.openStairsOrLiftsPositions[t] = {}
							end
							table.insert(
								result.terminateConstructionHookInfo.openStairsOrLiftsPositions[t],
								{
									t = t,
									era = moduleHelpers.getEraPrefix(params, t, i),
									lanePosTanX2 = cpl.posTanX2,
									pos2Link = transfUtils.transf2Position(
										transfUtilsUG.mul(
											centreLaneTransf,
											{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0.5, 0, _laneZ + _constants.openStairsUpZ, 1 }
										)
									)
								}
							)
						end
					end
				end
				_addLanesAlong()

				local function _addWaitingAreas()
					if isCargoTerminal then
						for _, cwas in pairs(params.terminals[t].cargoWaitingAreasRelative) do
							for i = 1, #cwas do
								local posTanX2 = cwas[i].posTanX2
								local centreLaneTransf = transfUtils.get1MLaneTransf(posTanX2[1][1], posTanX2[2][1])
								result.models[#result.models+1] = {
									id = _constants.cargoWaitingAreaModelId,
									tag = slotHelpers.mangleModelTag(t, true),
									transf = transfUtilsUG.mul(centreLaneTransf, {1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1})
								}
							end
						end
					else
						if isTrackOnPlatformLeft then
							for i = 1, #params.terminals[t].leftPlatformsRelative do
								local posTanX2 = params.terminals[t].leftPlatformsRelative[i].posTanX2
								local leftLaneTransf = transfUtils.get1MLaneTransf(posTanX2[1][1], posTanX2[2][1])

								result.models[#result.models+1] = {
									id = _constants.passengerWaitingAreaModelId,
									tag = slotHelpers.mangleModelTag(t, false),
									transf = transfUtilsUG.mul(leftLaneTransf, {1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1})
								}
							end
						else
							for i = 1, #params.terminals[t].rightPlatformsRelative do
								local posTanX2 = params.terminals[t].rightPlatformsRelative[i].posTanX2
								-- invert the lanes or the passengers will face away from the track when waiting
								-- local rightLaneTransf = transfUtils.get1MLaneTransf(posTanX2[1][1], posTanX2[2][1])
								local rightLaneTransf = transfUtils.get1MLaneTransf(posTanX2[2][1], posTanX2[1][1])

								result.models[#result.models+1] = {
									id = _constants.passengerWaitingAreaModelId,
									tag = slotHelpers.mangleModelTag(t, false),
									-- if you touch this, you screw things
									-- transf = transfUtilsUG.mul(rightLaneTransf, {-1, 0, 0, 0,  0, -1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1})
									transf = transfUtilsUG.mul(rightLaneTransf, {1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1})
								}
							end
						end
					end
				end
				_addWaitingAreas()

				local _addUpDownSlots = function()
					if isCargoTerminal then return end

					for i = 2, #params.terminals[t].centrePlatformsRelative - 1, 2 do
						local cpl = params.terminals[t].centrePlatformsRelative[i]
						local era = moduleHelpers.getEraPrefix(params, t, i)
						local mySpacing = {3, -0.1, 1, 1}
						local myTransf = transfUtilsUG.mul(
								moduleHelpers.getPlatformObjectTransf_AlwaysVertical(cpl.posTanX2),
								{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1 }
							)
						if cpl.type == 2 then -- tunnels
							-- LOLLO TODO MAYBE place one automatically when... When? When adding a subway?
							table.insert(result.slots, {
								-- height = 0,
								id = result.mangleId(t, i, _constants.idBases.tunnelStairsUpSlotId),
								spacing = mySpacing,
								transf = myTransf,
								type = _constants.tunnelStairsUpModuleType,
							})
							table.insert(result.slots, {
								-- height = 0,
								id = result.mangleId(t, i, _constants.idBases.tunnelStairsUpDownSlotId),
								spacing = mySpacing,
								transf = myTransf,
								type = _constants.tunnelStairsUpDownModuleType,
							})
						else -- ground and bridges
							table.insert(result.slots, {
								-- height = 0,
								id = result.mangleId(t, i, _constants.idBases.underpassSlotId),
								-- shape 0 1 2 3, only graphical
								spacing = mySpacing,
								transf = myTransf,
								type = _constants.underpassModuleType,
							})
							if cpl.type == 0 then -- ground
                                table.insert(result.slots, {
                                    -- height = 0,
                                    id = result.mangleId(t, i, _constants.idBases.openLiftSlotId),
                                    -- shape 0 1 2 3, only graphical
                                    spacing = mySpacing,
                                    transf = myTransf,
                                    type = _constants.openLiftModuleType,
                                })
								local idM2 = result.mangleId(t, i-2, _constants.idBases.openStairsUpLeftSlotId)
								local idP2 = result.mangleId(t, i+2, _constants.idBases.openStairsUpLeftSlotId)
								if not(params.modules[idM2]) and not(params.modules[idP2]) then
									table.insert(result.slots, {
										-- height = 0,
										id = result.mangleId(t, i, _constants.idBases.openStairsUpLeftSlotId),
										spacing = mySpacing,
										transf = myTransf,
										type = _constants.openStairsUpLeftModuleType,
									})
								end
								idM2 = result.mangleId(t, i-2, _constants.idBases.openStairsUpRightSlotId)
								idP2 = result.mangleId(t, i+2, _constants.idBases.openStairsUpRightSlotId)
								if not(params.modules[idM2]) and not(params.modules[idP2]) then
									table.insert(result.slots, {
										-- height = 0,
										id = result.mangleId(t, i, _constants.idBases.openStairsUpRightSlotId),
										spacing = mySpacing,
										transf = transfUtilsUG.mul(
											myTransf,
											{ -1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, 0, 1 }
										),
										type = _constants.openStairsUpRightModuleType,
									})
								end
							end
						end
					end
				end
				_addUpDownSlots()

				local _addTerminalSlot = function()
					local i = params.terminals[t].trackEdgeListMidIndex
					local tel = params.terminals[t].trackEdgeLists[i]
					local posTanX2 = transfUtils.getPosTanX2Transformed(tel.posTanX2, params.inverseMainTransf)
					-- local nearlyCentredPosTanX2 = transfUtils.getPosTanX2Normalised(posTanX2, 2)
					local nearlyCentredPosTanX2 = transfUtils.getPosTanX2Normalised(posTanX2, 0.1) -- does not need to be perfectly centred
					local myTransf = transfUtilsUG.mul(
						moduleHelpers.getPlatformObjectTransf_WithYRotation(nearlyCentredPosTanX2),
						{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1 }
					)
					table.insert(result.slots, {
						-- height = 0,
						id = result.mangleId(t, 0, _constants.idBases.terminalSlotId),
						spacing = {0, 0, 0, 0}, -- this can collide so we keep it zero
						transf = myTransf,
						type = isCargoTerminal and _constants.cargoTerminalModuleType or _constants.passengerTerminalModuleType,
                    })
                    -- insert two undeletable dummy slots for upgrading tracks
					table.insert(result.slots, {
						-- height = 0,
						id = result.mangleId(t, 0, _constants.idBases.trackElectrificationSlotId),
						spacing = {0, 0, 0, 0}, -- this does not prevent deletion, it just makes it harder
						transf = myTransf,
						type = _constants.trackElectrificationModuleType
					})
					table.insert(result.slots, {
						-- height = 0,
						id = result.mangleId(t, 0, _constants.idBases.trackSpeedSlotId),
						spacing = {0, 0, 0, 0},
						transf = myTransf,
						type = _constants.trackSpeedModuleType
					})
					table.insert(result.slots, {
						-- height = 0,
						id = result.mangleId(t, 0, _constants.idBases.platformEraASlotId),
						spacing = {0, 0, 0, 0},
						transf = myTransf,
						type = _constants.era_a_platformModuleType
					})
					table.insert(result.slots, {
						-- height = 0,
						id = result.mangleId(t, 0, _constants.idBases.platformEraBSlotId),
						spacing = {0, 0, 0, 0},
						transf = myTransf,
						type = _constants.era_b_platformModuleType
					})
					table.insert(result.slots, {
						-- height = 0,
						id = result.mangleId(t, 0, _constants.idBases.platformEraCSlotId),
						spacing = {0, 0, 0, 0},
						transf = myTransf,
						type = _constants.era_c_platformModuleType
					})
				end
				_addTerminalSlot()
			end -- loop over terminals

			local _addSubwaySlots = function()
				-- logger.print('_addSubwaySlots starting, params.subways =') logger.debugPrint(params.subways)
				if not(params.subways) then return end

				for slotId, subway in pairs(params.subways) do
					if params.modules[slotId] ~= nil then
						local extraData = params.subways[slotId]
						if extraData == nil then
							logger.err('subway[' .. (slotId or 'NIL') .. '] not found')
						else
							if extraData.transf == nil then
								logger.err('subway[' .. (slotId or 'NIL') .. '] has no transf')
							else
								-- logger.print('extraData =') logger.debugPrint(extraData)
								table.insert(result.slots, {
									-- height = 0,
									id = slotId,
									spacing = {1, 1, 1, 1},
									transf = transfUtilsUG.mul(params.inverseMainTransf, extraData.transf),
									type = _constants.subwayModuleType,
								})
							end
						end
					end
				end
				logger.print('_addSubwaySlots ending')
			end
			_addSubwaySlots()

			-- logger.print('params.upgrade =') logger.debugPrint(params.upgrade)

			result.terminateConstructionHook = function()
				logger.print('terminateConstructionHook starting')
		-- xpcall(
		-- 	function()
				local _getAllPositions_UndergroundTop_GroundBottom = function()
					local results = {}
					for t = 1, #params.terminals do
						results[t] = {}
						arrayUtils.concatValues(results[t], result.terminateConstructionHookInfo.underpassPositionsOnGround[t] or {})
						arrayUtils.concatValues(results[t], result.terminateConstructionHookInfo.tunnelStairsTopPositions[t] or {})
					end
					return results
				end

				local _getSegmentsBetweenPos2Links_AcrossTerminals = function(positionsA, positionsB, isOutputLog)
					-- for each combination of terminals, return the shortest paths.
					-- sort the results so that the first index is always < the second index
					local _isNorth = function(posTanX2, pos, distance)
						-- distance is only for debugging purposes
						-- We imagine walking along a platform from end to end, and checking connections heading left and right.
						-- We approximate posTanX2 (ie the bit of platform I am studying) with a segment; I can coz it's short.
						-- The direction ought to be irrelevant coz the calc is based on absolute positions
						-- LOLLO NOTE
						-- Suppose I have two curvy tracks, or 2 tracks that cross, maybe at different heights.
						-- Imagine two pos2Links in the left part of the cross and two in the right.
						-- Terminal 1 goes from NW to SE, terminal 2 goes from SW to NE.
						-- The SE point is south of any segments in terminal 2.
						-- The SW point is south of any segments in terminal 1.
						-- Imagine I have two curvx tracks, parallel. They go from SW to N and SE.
						-- Terminal 1 is above, terminal 2 is below.
						-- Take the T1 SE segment: the T2 SE position is south, the T2 SW position too.
						-- Take the T2 SE segment: the T1 SE position is north, the T1 SW position is north.
						-- As you see, this function needs calculating for each reference segment and point
						-- of a pair of bits to join.
						-- a + b * x = y
						-- b = dY / dX
						-- a = y - dY / dX * x
						local x0, x1 = posTanX2[1][1][1], posTanX2[2][1][1]
						local y0, y1 = posTanX2[1][1][2], posTanX2[2][1][2]
						local dX = x1 - x0
						local dY = y1 - y0
						if isOutputLog then
							print('_isNorth received posTanX2 =') debugPrint(posTanX2)
							print(', pos =') debugPrint(pos)
							print(', dX =', dX, 'dY =', dY)
							print(', distance =', distance or 'NIL')
						end
						if dX == 0 then
							local isNorthResult = pos[1] < x0
							if isOutputLog then
								print('_isNorth has calculated result = ', isNorthResult)
							end
							return isNorthResult
						end
						local b = dY / dX
						local a = y0 - b * x0
						local isNorthResult = a + b * pos[1] < pos[2]
						if isOutputLog then
							print('_isNorth has calculated a =', a, ', b =', b, ', result = ', isNorthResult)
						end
						return isNorthResult
					end
					local _maxT = #params.terminals
					local _getMinDistanceSegments = function()
					-- For each terminal, then for each connected point,
					-- get the shortest segment on the left and the shortest segment on the right.
						local results = {}
						for t = 1, _maxT do
							local positionsInT = positionsA[t]
							if positionsInT ~= nil then
								for i = 1, #positionsInT do
									local minDistance_T_I_SegmentLeft = nil
									local minDistance_T_I_SegmentRight = nil
									for tt = 1, _maxT do
										if t ~= tt then
											local positionsInTT = positionsB[tt]
											if positionsInTT ~= nil then
												for ii = 1, #positionsInTT do
													local distance = transfUtils.getPositionsDistance(positionsInT[i].pos2Link, positionsInTT[ii].pos2Link)
													local isNorthOfT1 = _isNorth(positionsInT[i].lanePosTanX2, positionsInTT[ii].pos2Link, distance)
													local isNorthOfT2 = _isNorth(positionsInTT[ii].lanePosTanX2, positionsInT[i].pos2Link, distance)
													local newSegment = {
														t1 = t,
														t2 = tt,
														t1Index = i,
														t2Index = ii,
														distance = distance,
														isNorthOfT1 = isNorthOfT1, -- these two isNorthOfTN may have the same value, see the note above
														isNorthOfT2 = isNorthOfT2,
														pos2Link1 = positionsInT[i].pos2Link,
														pos2Link2 = positionsInTT[ii].pos2Link,
														eraOfT1 = positionsInT[i].era,
														eraOfT2 = positionsInTT[ii].era,
													}
													if isNorthOfT1 then
														if minDistance_T_I_SegmentLeft == nil or minDistance_T_I_SegmentLeft.distance > distance then
															minDistance_T_I_SegmentLeft = newSegment
														end
													else
														if minDistance_T_I_SegmentRight == nil or minDistance_T_I_SegmentRight.distance > distance then
															minDistance_T_I_SegmentRight = newSegment
														end
													end
												end
											end
										end
									end
									-- We now calc isNothfOfT1 and isNorthOfT2, so we don't need this anymore.
									-- for _, newMds in pairs({minDistance_T_I_SegmentLeft, minDistance_T_I_SegmentRight}) do
									-- 	if newMds ~= nil then
									-- 		local isAlreadyThere = false
									-- 		-- isNorth tells if a point is above or below a line.
									-- 		-- if you have curved tracks, their tangents  at the connection points will cross.
									-- 		-- Imagine they form an X.
									-- 		-- bottom left of the X, I have a connection point
									-- 		-- and another one at the bottom right, on either side of the point where the tangents cross.
									-- 		-- both will have the same isNorth, which is correct per se but results in duplicates
									-- 		-- See the note above for more details.
									-- 		for _, prevMds in pairs(results) do
									-- 			-- if prevMds.distance == newMds.distance -- check this first for performance -- not pretty but it works
									-- 			-- and prevMds.t1 == newMds.t2 and prevMds.t1Index == newMds.t2Index
									-- 			-- and prevMds.t2 == newMds.t1 and prevMds.t2Index == newMds.t1Index
									-- 			if prevMds.t1 == newMds.t2 and prevMds.t1Index == newMds.t2Index
									-- 			and prevMds.t2 == newMds.t1 and prevMds.t2Index == newMds.t1Index
									-- 			then
									-- 				isAlreadyThere = true
									-- 				break
									-- 			end
									-- 		end
									-- 		if not(isAlreadyThere) then
									-- 			table.insert(results, newMds)
									-- 		end
									-- 	end
									-- end
									for _, newMds in pairs({minDistance_T_I_SegmentLeft, minDistance_T_I_SegmentRight}) do
										if newMds ~= nil then
											table.insert(results, newMds)
										end
									end
								end
							end
						end
						return results
					end
					local minDistanceSegments = _getMinDistanceSegments()
					if isOutputLog then
						print('minDistanceSegments =') debugPrint(minDistanceSegments)
					end
					-- Now we put all segments together, avoiding duplicates or redundant links.

                    local _getSegmentWithT1AndT2Sorted = function (oldSegment, isMakeT1LessThanT2)
                        local newSegment = {}
						if ((oldSegment.t1 < oldSegment.t2 and isMakeT1LessThanT2)
                        or (oldSegment.t1 > oldSegment.t2 and not(isMakeT1LessThanT2))) then
							newSegment.t1 = oldSegment.t1
							newSegment.t2 = oldSegment.t2
							newSegment.t1Index = oldSegment.t1Index
							newSegment.t2Index = oldSegment.t2Index
							newSegment.distance = oldSegment.distance
							newSegment.isNorthOfT1 = oldSegment.isNorthOfT1
							newSegment.isNorthOfT2 = oldSegment.isNorthOfT2
							newSegment.pos2Link1 = oldSegment.pos2Link1
							newSegment.pos2Link2 = oldSegment.pos2Link2
							newSegment.eraOfT1 = oldSegment.eraOfT1
							newSegment.eraOfT2 = oldSegment.eraOfT2
						else
							newSegment.t1 = oldSegment.t2
							newSegment.t2 = oldSegment.t1
							newSegment.t1Index = oldSegment.t2Index
							newSegment.t2Index = oldSegment.t1Index
							newSegment.distance = oldSegment.distance
							newSegment.isNorthOfT1 = oldSegment.isNorthOfT2
							newSegment.isNorthOfT2 = oldSegment.isNorthOfT1
							newSegment.pos2Link1 = oldSegment.pos2Link2
							newSegment.pos2Link2 = oldSegment.pos2Link1
							newSegment.eraOfT1 = oldSegment.eraOfT2
							newSegment.eraOfT2 = oldSegment.eraOfT1
						end
                        return newSegment
                    end
					local minDistance_T_I_Segments_SmallTFirst = {}
					for _, segment in pairs(minDistanceSegments) do
						local newSegment = _getSegmentWithT1AndT2Sorted(segment, true)
						local t1 = newSegment.t1
						local t1Index = newSegment.t1Index
						if minDistance_T_I_Segments_SmallTFirst[t1] == nil then minDistance_T_I_Segments_SmallTFirst[t1] = {} end
						if minDistance_T_I_Segments_SmallTFirst[t1][t1Index] == nil then minDistance_T_I_Segments_SmallTFirst[t1][t1Index] = {} end
						table.insert(minDistance_T_I_Segments_SmallTFirst[t1][t1Index], newSegment)
					end

					if isOutputLog then
						print('minDistance_T_I_Segments_SmallTFirst =') debugPrint(minDistance_T_I_Segments_SmallTFirst)
					end
					-- minDistance_T_I_Segments_SmallTFirst is indexed by t1 (lowest terminal of each link)
					-- and t1Index (index of connection point along it).
					-- In the following, I:
					-- remove duplicate links (eg terminal 1, index 1 to terminal 2, index 1 and viceversa)
					-- remove redundant links (eg if there are two or more links heading left or right, I only keep the shortest)
					-- index the remaining links by terminal 1 and then terminal 2
					local short_T_TT_Segments_SmallTFirst = {}
                    for t = 1, _maxT do
						if minDistance_T_I_Segments_SmallTFirst[t] then
							for _, segmentsTouchingPointWithIndex in pairs(minDistance_T_I_Segments_SmallTFirst[t]) do
								for _, isNorthOfT1 in pairs({true, false}) do
									local testSegment = {distance = 9999}
									local isNewSegmentThere = false
									for _, segment in pairs(segmentsTouchingPointWithIndex) do
										if segment.isNorthOfT1 == isNorthOfT1
										and segment.distance < testSegment.distance
										then
											testSegment = segment
											isNewSegmentThere = true
										end
									end
									if isNewSegmentThere then
                                        local newSegment = _getSegmentWithT1AndT2Sorted(testSegment, true)
										local t1 = newSegment.t1
										local t2 = newSegment.t2
										if short_T_TT_Segments_SmallTFirst[t1] == nil then short_T_TT_Segments_SmallTFirst[t1] = {} end
										if short_T_TT_Segments_SmallTFirst[t1][t2] == nil then short_T_TT_Segments_SmallTFirst[t1][t2] = {} end
										table.insert(short_T_TT_Segments_SmallTFirst[t1][t2], newSegment)
										if isOutputLog then
											print('isNorthOfT1 =', isNorthOfT1, ', inserted segment ') debugPrint(newSegment) print('with t1 =', t1, 'and t2 =', t2)
										end
									end
								end
							end
						end
					end
					if isOutputLog then
						print('short_T_TT_Segments_SmallTFirst =') debugPrint(short_T_TT_Segments_SmallTFirst)
					end

					return short_T_TT_Segments_SmallTFirst
				end

				local _linkUnderpassesAndStairs = function()
					-- link all underpasses along each platform, except on bridges
					-- repeat with stairs 2 subway
					-- not necessary, it can look ugly => we turn it off for now
					-- local _linkAlong = function(positions)
					-- 	for t = 1, #params.terminals do
					-- 		local positionsInTerminal = positions[t]
					-- 		if positionsInTerminal ~= nil and #positionsInTerminal > 1 then
					-- 			local previousPosition = positionsInTerminal[1]
					-- 			for i = 2, #positionsInTerminal do
					-- 				local currentPosition = positionsInTerminal[i]
					-- 				result.models[#result.models+1] = {
					-- 					id = _constants.passengerLaneModelId,
					-- 					transf = transfUtils.get1MLaneTransf(
					-- 						previousPosition.pos2Link,
					-- 						currentPosition.pos2Link
					-- 					)
					-- 				}
					-- 				previousPosition = currentPosition
					-- 			end
					-- 		end
					-- 	end
					-- end
					-- _linkAlong(result.terminateConstructionHookInfo.tunnelStairsTopPositions)
					-- _linkAlong(result.terminateConstructionHookInfo.underpassPositionsOnGround)

					-- link the underpasses and the stairs 2 subway across terminals, underground
					-- I link each terminal to 1 other terminal only, the closest with an underpass.
					-- There can be multiple links if they are short enough
					-- On bridges, I only link platform lifts (no side lifts) and underpasses that are close enough.
					-- Different terminals on bridges and on or under ground are not connected together: the user must build lifts.
					local _linkedTerminals = {}
					local function _linkAcross(segments, maxDistance, getModelId, linkedTerminals)
						local maxT = #params.terminals
						for t = 1, maxT do
							if segments[t] ~= nil then
								for tt = t + 1, maxT do
									if segments[t][tt] ~= nil then
										for _, value in pairs(segments[t][tt]) do
											if not(maxDistance) or value.distance <= maxDistance then
												-- LOLLO NOTE this estimator could be improved to check indirect connections,
												-- but I like it simple
												if not(linkedTerminals) or not(linkedTerminals[t]) or not(arrayUtils.arrayHasValue(linkedTerminals[t], tt)) then
													if getModelId then
														result.models[#result.models+1] = {
															id = getModelId(value.distance, value.eraOfT1, value.eraOfT2),
															transf = transfUtils.get1MModelTransf(
																value.pos2Link1,
																value.pos2Link2
															)
														}
													else
														result.models[#result.models+1] = {
															id = _constants.passengerLaneModelId,
															transf = transfUtils.get1MLaneTransf(
																value.pos2Link1,
																value.pos2Link2
															)
														}
													end
													if _linkedTerminals[t] == nil then _linkedTerminals[t] = {} end
													if _linkedTerminals[tt] == nil then _linkedTerminals[tt] = {} end
													arrayUtils.addUnique(_linkedTerminals[t], tt)
													arrayUtils.addUnique(_linkedTerminals[tt], t)
												end
											end
										end
									end
								end
							end
						end
					end

					local shortSegmentsOpenStairsOrLifts = _getSegmentsBetweenPos2Links_AcrossTerminals(
						result.terminateConstructionHookInfo.openStairsOrLiftsPositions,
						result.terminateConstructionHookInfo.openStairsOrLiftsPositions
						-- true
					)

					local shortSegmentsOnBridge = _getSegmentsBetweenPos2Links_AcrossTerminals(
						result.terminateConstructionHookInfo.underpassPositionsOnBridge,
						result.terminateConstructionHookInfo.underpassPositionsOnBridge
					)

					local shortSegmentsTunnelTops2BridgeBottoms = _getSegmentsBetweenPos2Links_AcrossTerminals(
                        result.terminateConstructionHookInfo.tunnelStairsTopPositions,
                        result.terminateConstructionHookInfo.liftBottomPositions
					)

					-- local underpassPositionsOnGround_and_tunnelStairsTopPositions_and_tunnelStairsBottomPositions = _getAllPositions_UndergroundTop_UndergroundBottom_GroundBottom()
					-- local shortSegmentsUnderpassOnGroundAndTunnelStairsTopsAndTunnelStairsBottoms = _getSegmentsBetweenPos2Links_AcrossTerminals(
                    --     underpassPositionsOnGround_and_tunnelStairsTopPositions_and_tunnelStairsBottomPositions,
                    --     underpassPositionsOnGround_and_tunnelStairsTopPositions_and_tunnelStairsBottomPositions,
					-- 	true
					-- )
					local shortSegmentsOnGround = _getSegmentsBetweenPos2Links_AcrossTerminals(
						result.terminateConstructionHookInfo.underpassPositionsOnGround,
						result.terminateConstructionHookInfo.underpassPositionsOnGround
						-- true
					)
					local shortSegmentsTunnelTops2Tops = _getSegmentsBetweenPos2Links_AcrossTerminals(
						result.terminateConstructionHookInfo.tunnelStairsTopPositions,
						result.terminateConstructionHookInfo.tunnelStairsTopPositions
						-- true
					)
					local shortSegmentsTunnelTops2Surface = _getSegmentsBetweenPos2Links_AcrossTerminals(
                        result.terminateConstructionHookInfo.tunnelStairsTopPositions,
                        result.terminateConstructionHookInfo.underpassPositionsOnGround
						-- true
					)
					local shortSegmentsTunnelTops2Bottoms = _getSegmentsBetweenPos2Links_AcrossTerminals(
                        result.terminateConstructionHookInfo.tunnelStairsTopPositions,
                        result.terminateConstructionHookInfo.tunnelStairsBottomPositions
						-- true
                    )

                    -- Remove redundant up-down connectors.
                    -- There could be trouble with a steep underground station with two levels:
                    -- the stairs of a platform may try to join the underpass of its opposite twin,
                    -- and we cannot just check the height of either coz there is too much freedom.
					-- We try to get past it choosing the shortest path and always associating stairs down to stairs up
					-- - we never have stairs down without stairs up.
					local _reduceUpDownConnectors = function()
						local maxT = #params.terminals
						logger.print('shortSegmentsTunnelTops2Bottoms before reducing =') logger.debugPrint(shortSegmentsTunnelTops2Bottoms)
						logger.print('shortSegmentsTunnelTops2Tops before reducing =') logger.debugPrint(shortSegmentsTunnelTops2Tops)
						for t = 1, maxT do
							local top2BottomsT = shortSegmentsTunnelTops2Bottoms[t]
							if top2BottomsT ~= nil then
								for tt = t+1, maxT do
									local top2BottomsT_TT = top2BottomsT[tt]
									if top2BottomsT_TT ~= nil then
										local minDistanceTops2BottomsT_TT = nil
										for _, top2Bottom in pairs(top2BottomsT_TT) do
											if minDistanceTops2BottomsT_TT == nil or minDistanceTops2BottomsT_TT > top2Bottom.distance then
												minDistanceTops2BottomsT_TT = top2Bottom.distance
											end
										end
										local minDistanceTops2TopsT_TT = nil
										if shortSegmentsTunnelTops2Tops[t] and shortSegmentsTunnelTops2Tops[t][tt] then
											for _, top2Top in pairs(shortSegmentsTunnelTops2Tops[t][tt]) do
												if minDistanceTops2TopsT_TT == nil or minDistanceTops2TopsT_TT > top2Top.distance then
													minDistanceTops2TopsT_TT = top2Top.distance
												end
											end
										end
										if minDistanceTops2BottomsT_TT ~= nil and minDistanceTops2TopsT_TT ~= nil then
											if minDistanceTops2BottomsT_TT < minDistanceTops2TopsT_TT then
												shortSegmentsTunnelTops2Tops[t][tt] = {}
											else
												shortSegmentsTunnelTops2Bottoms[t][tt] = {}
											end
										end
									end
								end
							end
						end
						logger.print('shortSegmentsTunnelTops2Bottoms after reducing =') logger.debugPrint(shortSegmentsTunnelTops2Bottoms)
						logger.print('shortSegmentsTunnelTops2Tops after reducing =') logger.debugPrint(shortSegmentsTunnelTops2Tops)
					end
					_reduceUpDownConnectors()

					logger.print('shortSegmentsOpenStairsOrLifts =') logger.debugPrint(shortSegmentsOpenStairsOrLifts)
					_linkAcross(shortSegmentsOpenStairsOrLifts, 99, moduleHelpers.openStairs.getPedestrianBridgeModelId_Compressed)

					logger.print('shortSegmentsOnBridge =') logger.debugPrint(shortSegmentsOnBridge)
					-- lifts can connect to other lifts on other terminals, even if they are far away and there is an S bend:
					-- we try to avoid this with maxDistance
					_linkAcross(shortSegmentsOnBridge, 40.0)

					logger.print('shortSegmentsTunnelTops2BridgeBottoms =') logger.debugPrint(shortSegmentsTunnelTops2BridgeBottoms)
					_linkAcross(shortSegmentsTunnelTops2BridgeBottoms)

					-- logger.print('shortSegmentsUnderpassOnGroundAndTunnelStairsTopsAndTunnelStairsBottoms =') logger.debugPrint(shortSegmentsUnderpassOnGroundAndTunnelStairsTopsAndTunnelStairsBottoms)
					-- _linkAcross(shortSegmentsUnderpassOnGroundAndTunnelStairsTopsAndTunnelStairsBottoms)

					logger.print('shortSegmentsOnGround =') logger.debugPrint(shortSegmentsOnGround)
					_linkAcross(shortSegmentsOnGround)

					logger.print('shortSegmentsTunnelTops2Tops =') logger.debugPrint(shortSegmentsTunnelTops2Tops)
					_linkAcross(shortSegmentsTunnelTops2Tops)

					logger.print('shortSegmentsTunnelTops2Bottoms =') logger.debugPrint(shortSegmentsTunnelTops2Bottoms)
					_linkAcross(shortSegmentsTunnelTops2Bottoms)

					logger.print('shortSegmentsTunnelTops2Surface =') logger.debugPrint(shortSegmentsTunnelTops2Surface)
					-- only make these connections if there are no other peer-to-peer connections between the terminals
					_linkAcross(shortSegmentsTunnelTops2Surface, nil, nil, _linkedTerminals)
				end
				_linkUnderpassesAndStairs()
				logger.print('passengers and stairs linked')

				local _linkPassengerPlatforms = function(maxLinkLength, positions, modelId, raiseHowMuch)
					-- link platforms across terminals, on the ground, if they are close enough
					local maxT = #params.terminals
					for t = 1, maxT do
						local positionsInT = positions[t]
						if positionsInT ~= nil then
							for tt = t + 1, maxT do
								local positionsInTT = positions[tt]
								if positionsInTT ~= nil then
									for i = 1, #positionsInT do
										for ii = 1, #positionsInTT do
											if maxLinkLength == nil or transfUtils.getPositionsDistance(positionsInT[i].pos, positionsInTT[ii].pos) < maxLinkLength then
												local tr = transfUtils.get1MLaneTransf(
													positionsInT[i].pos,
													positionsInTT[ii].pos
												)
												if raiseHowMuch and raiseHowMuch > 0 then
													tr[15] = tr[15] + _constants.trackCrossingRaise
													logger.print('tr[15] = ', tr[15])
												end
												result.models[#result.models+1] = {
													id = modelId,
													transf = tr
												}
											end
										end
									end
								end
							end
						end
					end
				end
				_linkPassengerPlatforms(
					6,
					result.terminateConstructionHookInfo.crossConnectorPositions,
					_constants.passengerLaneModelId
				)
				_linkPassengerPlatforms(
					8,
					result.terminateConstructionHookInfo.trackCrossingPositions,
					_constants.passengerLaneModelId,
					_constants.trackCrossingRaise
				)
				logger.print('passenger platforms linked')

				local _linkSubways = function()
					if not(params.subways) then return end

					local _linkSubways2 = function(positions)
						for slotId, subway in pairs(params.subways) do
							if subway == nil then
								logger.err('subway[' .. (slotId or 'NIL') .. '] not found')
							elseif subway.transf == nil then
								logger.err('subway[' .. (slotId or 'NIL') .. '] has no transf')
							elseif params.modules[slotId] ~= nil then
								local subwayPos2Link = transfUtils.transf2Position(transfUtilsUG.mul(params.inverseMainTransf, subway.transf2Link))
								local isThisSubwayConnected = false
								-- connect each subway to the nearest terminal
								local minDistance = nil
								local minDistanceI = nil
								local minDistanceT = nil
								for t = 1, #params.terminals do
									if positions[t] ~= nil then
										for i = 1, #positions[t] do
											local distance = transfUtils.getPositionsDistance(subwayPos2Link, positions[t][i].pos2Link)
											if minDistance == nil or minDistance > distance then
												minDistance = distance
												minDistanceI = i
												minDistanceT = t
											end
										end
									end
								end
								-- logger.print('terminal t = ', minDistanceT, 'about to link to subway')
								if minDistanceT ~= nil and minDistanceI ~= nil then
									-- logger.print('allPositionsUnderground[minDistanceT][minDistanceI] =') logger.debugPrint(allPositionsUnderground[minDistanceT][minDistanceI])
									result.models[#result.models+1] = {
										id = _constants.passengerLaneModelId,
										transf = transfUtils.get1MLaneTransf(
											positions[minDistanceT][minDistanceI].pos2Link,
											subwayPos2Link
										)
									}
									isThisSubwayConnected = true
								end
								if not(isThisSubwayConnected) then
									result.models[#result.models+1] = {
										id = _constants.redMessageModelFileName,
										-- transf = _constants.idTransf
										transf = transfUtilsUG.mul(params.inverseMainTransf, subway.transf),
									}
									result.labelText[#result.models - 1] = { _('SubwayCannotConnect'), _('SubwayCannotConnect') }
								end
							end
						end
					end
					_linkSubways2(_getAllPositions_UndergroundTop_GroundBottom())
					-- _linkSubways2(result.terminateConstructionHookInfo.liftBottomPositions)
				end
				_linkSubways()
				logger.print('subways linked')

		-- 	end,
		-- 	logger.xpErrorHandler
		-- )
				-- LOLLO NOTE stations with mixed cargo and passengers seem impossible by design.
				-- There are some assertions, like allPersonEdgesHaveTransportModePerson != allPersonEdgesHaveTransportModeCargo,
				-- that point at this.
				local _groupTerminals = function()
					result.stations = { }
					if result.terminateConstructionHookInfo.isAnyCargoTerminal then
						result.stations[#result.stations+1] = {
							tag = _constants.stationCargoTag, -- in the stock station, this is 1 for cargo and 2 for passengers
							terminals = { } -- the indexes of the linked terminal groups, in base 0
						}
					end
					if result.terminateConstructionHookInfo.isAnyPassengerTerminal then
						result.stations[#result.stations+1] = {
							tag = _constants.stationPassengerTag, -- in the stock station, this is 1 for cargo and 2 for passengers
							terminals = { } -- the indexes of the linked terminal groups, in base 0
						}
					end

					for t = 1, #params.terminals do
						local isCargoTerminal = params.terminals[t].isCargo
						table.insert(
							result.terminalGroups,
							{
								tag = t - 1,
								terminals = {
									-- { 0, 0 }
								},
								-- UG TODO ask UG if they can make a parameter similar to the following,
								-- to override personEdges and personNodes.
								-- This way, I won't be bound to using a model to assign a waiting area.
								-- LOLLO NOTE there can be 1 terminal 4 1 vehicle node,
								-- n terminals 4 1 person edge,
								-- n terminals 4 1 person node
								vehicleNodeOverride = result.terminateConstructionHookInfo.vehicleNodes[t]
							}
						)

						local modelIndexesBase0 = {}
						for i = 1, #result.models do
							if slotHelpers.getTerminalFromModelTag(result.models[i].tag) == t then
								modelIndexesBase0[#modelIndexesBase0+1] = i - 1
							end
						end
						for _, modelIndex in pairs(modelIndexesBase0) do
							-- table.insert(result.terminalGroups[#result.terminalGroups].terminals, {modelIndex, t - 1}) -- NO!
							table.insert(result.terminalGroups[#result.terminalGroups].terminals, {modelIndex, 0})
						end

						local stationIndex = arrayUtils.findIndex(result.stations, 'tag', isCargoTerminal and _constants.stationCargoTag or _constants.stationPassengerTag)
						table.insert(result.stations[stationIndex].terminals, t - 1)
					end
				end
				_groupTerminals()
				logger.print('terminals grouped')

				-- it should output something like (this example has one terminal made of two adjacent bits)
				-- stock result.stations =
				-- 	{
				-- 		{
				-- 			tag = 1, -- in the stock station, this is 1 for cargo and 2 for passengers
				-- 			terminals = { 0, 2 } -- 0 and 2 are the indexes of the linked terminal groups, in base 0
				-- 		}
				-- 	}
				-- stock result.terminalGroups =
				-- {
				-- 	{
				-- 		tag = -1, -- possibly useless, try to keep them all different tho
				-- 		terminals = {
				-- 			{ 22, 0 }, -- 22 is the index of a model with a terminal, in base 0
				-- 			{ 25, 0 }, -- 0 is always 0 in the stock station, it is something like a terminal number
				-- 		},
				--		vehicleNodeOverride { 10 }, -- 10 is the index of a node in the edge lists
				-- 	}
				-- }

				-- logger.print('LOLLO lollo_freestyle_train_station leaving terminateConstructionHook')
				-- logger.print('LOLLO result = ') logger.debugPrint(result)
				-- logger.print('LOLLO result.stations = ') logger.debugPrint(result.stations)
				-- logger.print('LOLLO result.models = ') logger.debugPrint(result.models)
				-- logger.print('LOLLO result.terminalGroups = ') logger.debugPrint(result.terminalGroups)
			end -- end of terminateConstructionHook()

			-- logger.print('freestyleTrainStation.updateFn about to return')
			-- logger.print('freestyleTrainStation result =') logger.debugPrint(result)
			-- logger.print('freestyleTrainStation result.terrainAlignmentLists =') logger.debugPrint(result.terrainAlignmentLists)
			return result
		end,
 		preProcessFn = function(modules, change, three)
			-- this fires when the user adds or removes a module
			-- logger.print('LOLLO preProcessFn')
			-- logger.print('modules =') logger.debugPrint(modules)
			-- logger.print('change =') logger.debugPrint(change)

			-- default behaviour
			-- if change.added then
			-- 	modules[change.slotId] = change.module
			-- else
			-- 	modules[change.slotId] = nil
			-- end

			if change.added then
				-- remove the older platform era modules whenever one is added, in each terminal
				local nTerminalNew, _, baseIdNew = slotHelpers.demangleId(change.slotId)
				if baseIdNew == _constants.idBases.platformEraASlotId
				or baseIdNew == _constants.idBases.platformEraBSlotId
				or baseIdNew == _constants.idBases.platformEraCSlotId
				then
					for slotIdOld, _ in pairs(modules) do
						local nTerminalOld, _, baseIdOld = slotHelpers.demangleId(slotIdOld)
						if nTerminalOld == nTerminalNew
						and (baseIdOld == _constants.idBases.platformEraASlotId
							or baseIdOld == _constants.idBases.platformEraBSlotId
							or baseIdOld == _constants.idBases.platformEraCSlotId)
						then
							modules[slotIdOld] = nil
						end
					end
				end
				modules[change.slotId] = change.module
			else
				-- bar removal of modules for upgrading tracks...
				local nTerminal, _, baseId = slotHelpers.demangleId(change.slotId)
				if baseId == _constants.idBases.trackElectrificationSlotId or baseId == _constants.idBases.trackSpeedSlotId then
					local terminalSlotId = slotHelpers.mangleId(nTerminal, 0, _constants.idBases.terminalSlotId)
					-- ... if their terminal is present
					if modules[terminalSlotId] ~= nil then
						-- logger.print('barring removal of modules for upgrading tracks')
						return modules
					-- else
						-- logger.print('allowing removal of modules for upgrading tracks coz terminal does not exist')
					end
				end
				modules[change.slotId] = nil
			end
			-- airport behaviour
			-- if change.added then
			-- 	if change.slotId == landingSlotId + 1 then
			-- 		modules[landingSlotId + 0] = nil
			-- 	elseif change.slotId == landingSlotId + 0 then
			-- 		modules[landingSlotId + 1] = nil
			-- 	elseif change.slotId == landingSlotId + 2 then
			-- 		modules[landingSlotId + 3] = nil
			-- 	elseif change.slotId == landingSlotId + 3 then
			-- 		modules[landingSlotId + 2] = nil
			-- 	end
			-- 	modules[change.slotId] = change.module
			-- else
			-- 	modules[change.slotId] = nil
			-- end
			return modules
        end,
        upgradeFn = function(args)
			-- args contains the params and slotId, which is sometimes correct and sometimes -1, and no transf.
			-- it also contains:
			-- catenaryToggle = 1,
			-- catenary = 1,
			-- trackTypeToggle = 1,
			-- trackType = 1,
			-- logger.print('LOLLO upgradeFn starting, args.slotId =') logger.debugPrint(args.slotId)

			-- LOLLO NOTE when hovering on a station with the track upgrade tool,
			-- some terminals are recognised and others are not (ie args.slotId = -1)
			-- This makes upgrading tracks impossible.
			-- Workaround: let's upgrade them all!

			-- logger.print('args.catenaryToggle =') logger.debugPrint(args.catenaryToggle)
			-- logger.print('args.catenary =') logger.debugPrint(args.catenary)
			-- logger.print('args.trackTypeToggle =') logger.debugPrint(args.trackTypeToggle)
			-- logger.print('args.trackType =') logger.debugPrint(args.trackType)
			-- logger.print('args =') logger.debugPrint(arrayUtils.cloneOmittingFields(args, {'modules'}, true)) -- hangs!

			-- if args.slotId == nil or args.slotId < 0 then return {} end

			local affectedTerminals = {}
			-- logger.print('args.slotId =') logger.debugPrint(args.slotId)
			if args.slotId ~= nil and args.slotId > 0 then
				local nTerminal, _, _ = slotHelpers.demangleId(args.slotId)
				if nTerminal == nil then return {} end
				affectedTerminals[1] = nTerminal
			else
				for t = 1, #args.terminals do
					affectedTerminals[t] = t
				end
			end
			-- logger.print('affectedTerminals =') logger.debugPrint(affectedTerminals)

			local upgradeResults = {}
			for _, nTerminal in pairs(affectedTerminals) do
				local newModuleFileName = nil
				if args.catenaryToggle == 1 then
					local moduleKey = slotHelpers.mangleId(nTerminal, 0, _constants.idBases.trackElectrificationSlotId)
					local oldModuleValue = args.modules[moduleKey]
					-- logger.print('oldModuleValue =') logger.debugPrint(oldModuleValue)

					if oldModuleValue ~= nil and oldModuleValue.name ~= nil then
						if oldModuleValue.name == _constants.trackElectrificationNoModuleFileName
						or oldModuleValue.name == _constants.trackElectrificationUndefinedModuleFileName
						then
							newModuleFileName = _constants.trackElectrificationYesModuleFileName
						else
							newModuleFileName = _constants.trackElectrificationNoModuleFileName
						end
					else
						newModuleFileName = _constants.trackElectrificationYesModuleFileName
						print('WARNING: upgradeFn could not find the old module')
					end

					upgradeResults[#upgradeResults+1] = { moduleKey, newModuleFileName }
				elseif args.trackTypeToggle == 1 then
					local moduleKey = slotHelpers.mangleId(nTerminal, 0, _constants.idBases.trackSpeedSlotId)
					local oldModuleValue = args.modules[moduleKey]
					-- logger.print('oldModuleValue =') logger.debugPrint(oldModuleValue)

					if oldModuleValue ~= nil and oldModuleValue.name ~= nil then
						if oldModuleValue.name == _constants.trackSpeedSlowModuleFileName
						or oldModuleValue.name == _constants.trackSpeedUndefinedModuleFileName
						then
							newModuleFileName = _constants.trackSpeedFastModuleFileName
						else
							newModuleFileName = _constants.trackSpeedSlowModuleFileName
						end
					else
						newModuleFileName = _constants.trackSpeedFastModuleFileName
						print('WARNING: upgradeFn could not find the old module')
					end

					upgradeResults[#upgradeResults+1] = { moduleKey, newModuleFileName }
				end
			end

			-- logger.print('results =') debugPrint(upgradeResults)
			return upgradeResults

			-- The return structure is a list like:
			-- return {
			-- 		{ 10001000, "station/rail/modular_station/platform_high_speed_track.module" },
			-- 		{ 10001010, "station/rail/modular_station/platform_high_speed_track.module" },
			-- }
        end,
	}
end