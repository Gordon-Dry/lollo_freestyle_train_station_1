local arrayUtils = require('lollo_freestyle_train_station.arrayUtils')
local edgeUtils = require('lollo_freestyle_train_station.edgeUtils')
local transfUtilUG = require 'transf'
local transfUtils = require('lollo_freestyle_train_station.transfUtils')
local vec3 = require 'vec3'


function data()
	return {
		type = 'RAIL_STATION',
		description = {
			name = _("Lollo Freestyle Train Station"),
			description = _("Lollo Freestyle Train Station."),
		},
		availability = {
			yearFrom = -1, -- 1925, -- -1,
			yearTo = -1, -- -1, -- 0
		},
		order = 5005,
		-- soundConfig = {
		-- 	soundSet = { name = "lollo_lorry_bay" }
		-- },
		autoRemovable = false,
		skipCollision = true, -- we need this to change the street type when reconfiguring
		params = { -- keep it empty or it will crash coz it won't find the params, which I pass when building the construction
            -- {
            --     key = 'fileName',
            --     name = 'File Name',
            --     values = {
            --         'dummy',
            --     },
            --     defaultIndex = 0
            -- }
        },
		updateFn = function(params)
			print('updateFn starting, params =')
			debugPrint(params)

			local sampleParams =
			{
			  myTransf = { 0.46245205402374, 0.88664430379868, 0, 0, -0.88664430379868, 0.46245205402374, 0, 0, 0, 0, 1, 0, -987.02911376953, -1698.1489257813, 11.531784057617, 1, },
			  platformEdgeIds = { 25291, 24152, 25282, },
			  seed = 1230000,
			  state = {
				groups = {
				  random_large_tree = { "tree/european_linden.mdl", "tree/scots_pine.mdl", "tree/sugar_maple.mdl", },
				  random_large_tree_town = { "tree/european_linden.mdl", "tree/sugar_maple.mdl", },
				  random_medium_tree = { "tree/red_delicious_apple.mdl", "tree/shingle_oak.mdl", },
				  random_medium_tree_airport = { "tree/shingle_oak.mdl", },
				  random_medium_tree_town = { "tree/red_delicious_apple.mdl", "tree/shingle_oak.mdl", },
				  random_shrub = { "tree/azalea.mdl", "tree/common_hazel.mdl", "tree/elderberry.mdl", },
				  random_shrub_airport = { "tree/azalea.mdl", "tree/elderberry.mdl", },
				  random_shrub_town = { "tree/azalea.mdl", "tree/elderberry.mdl", },
				  random_shrub_town_fence = { "tree/azalea.mdl", },
				  random_small_tree = { "tree/azalea.mdl", "tree/common_hazel.mdl", "tree/elderberry.mdl", },
				  random_small_tree_town = { "tree/azalea.mdl", "tree/elderberry.mdl", },
				},
				track = {
				  ballastCutOff = 0.10000000149012,
				  ballastHeight = 0.30000001192093,
				  ballastMaterial = "track/ballast.mtl",
				  borderGroundTex = "ballast.lua",
				  bumperModel = "railroad/bumper.mdl",
				  catenaryBase = 6.4470000267029,
				  catenaryHeight = 1.3500000238419,
				  catenaryMaterial = "track/catenary.mtl",
				  catenaryMaxPoleDistance = 2,
				  catenaryMinPoleDistance = 0.80000001192093,
				  catenaryMultiGirderModel = "railroad/power_pole_us_1a_repeat.mdl",
				  catenaryMultiInnerPoleModel = "railroad/power_pole_us_1b_pole2.mdl",
				  catenaryMultiPoleModel = "railroad/power_pole_us_1_pole.mdl",
				  catenaryPoleDistance = 32,
				  catenaryPoleModel = "railroad/power_pole_us_2.mdl",
				  cost = 75,
				  desc = "Standard tracks with limited speed capabilities.",
				  fillGroundTex = "ballast_fill.lua",
				  icon = "ui/tracks/standard.tga",
				  maxSlope = 0.11999999731779,
				  maxSlopeBuild = 0.075000002980232,
				  maxSlopeShape = 0.15000000596046,
				  minCurveRadius = 44,
				  minCurveRadiusBuild = 60,
				  name = "Standard tracks",
				  railBase = 0.37999999523163,
				  railCutOff = 0.019999999552965,
				  railHeight = 0.15000000596046,
				  railMaterial = "track/rail.mtl",
				  railModel = "railroad/tracks/single_rail.mdl",
				  railTrackWidth = 1.4349999427795,
				  railWidth = 0.070000000298023,
				  shapeSleeperStep = 0.66666668653488,
				  shapeStep = 4,
				  shapeWidth = 4,
				  sleeperBase = 0.30000001192093,
				  sleeperCutOff = 0.019999999552965,
				  sleeperHeight = 0.079999998211861,
				  sleeperLength = 0.25999999046326,
				  sleeperMaterial = "track/sleeper.mtl",
				  sleeperModel = "railroad/tracks/single_sleeper_base.mdl",
				  sleeperWidth = 2.5999999046326,
				  slopeBuildSteps = 2,
				  speedCoeffs = { 0.85000002384186, 30, 0.60000002384186, },
				  speedLimit = 33.333332061768,
				  switchSignalModel = "railroad/switch_box.mdl",
				  trackDistance = 5,
				  trackStraightModel = { "railroad/tracks/2m_base.mdl", "railroad/tracks/4m_base.mdl", "railroad/tracks/8m_base.mdl", "railroad/tracks/16m_base.mdl", },
				  tunnelHullMaterial = "track/tunnel_hull.mtl",
				  tunnelWallMaterial = "track/tunnel_rail_ug.mtl",
				  yearFrom = 0,
				  yearTo = 0,
				},
			  },
			  trackEdgeLists = {
				{
				  catenary = true,
				  posTanX2 = {
					{
					  { -1016.0612182617, -1724.4984130859, 12.625776290894, },
					  { 43.891380310059, 27.93595123291, -2.9827115535736, },
					},
					{
					  { -985.90667724609, -1682.0408935547, 10.668236732483, },
					  { 14.657909393311, 50.000553131104, -0.92598873376846, },
					},
				  },
				  trackType = 0,
				  trackTypeName = "high_speed.lua",
				  type = 0,
				  typeIndex = -1,
				},
				{
				  catenary = true,
				  posTanX2 = {
					{
					  { -985.90667724609, -1682.0408935547, 10.668236732483, },
					  { 13.101428031921, 44.691135406494, -0.8276606798172, },
					},
					{
					  { -986.13043212891, -1635.4637451172, 10.286678314209, },
					  { -15.766356468201, 43.829719543457, -0.088118009269238, },
					},
				  },
				  trackType = 0,
				  trackTypeName = "high_speed.lua",
				  type = 0,
				  typeIndex = -1,
				},
			  },
			}

            -- LOLLO NOTE I cannot call the api from here, sigh.
			local result = {
				colliders = {},
				-- coord2terminalInfo = {},
                cost = 1000,
                -- demangleId = slotHelpers.demangleId,
                edgeLists = {},
                groundFaces = {},
                -- mangleId = slotHelpers.mangleId,
				models = {
					{
						id = 'lollo_freestyle_train_station/icon/blue.mdl',
						tag = 'stationTag',
                        transf = {1, 0, 0, 0,
                            0, 1, 0, 0,
                            0, 0, 1, 0,
                            0, 0, 0, 1},
					},
                },
                -- slotConfig = {},
                -- slots = {},
				stations = {},
				terminalGroups = {},
				terrainAlignmentLists = {},
			}

			local inverseTransf = transfUtils.getInverseTransf(params.myTransf)
			print('inverseTransf =')
			debugPrint(inverseTransf)
			for i = 1, #params.trackEdgeLists do
				local tel = params.trackEdgeLists[i]
				local newEdgeList = {
					edges = transfUtils.getPosTanX2Transformed(tel.posTanX2, inverseTransf),
					freeNodes = {},
					params = {
						type = tel.trackTypeName,
						catenary = tel.catenary
					},
					snapNodes = {},
					tag2Nodes = {},
					type = 'TRACK'
				}

				-- add tunnel or bridge if set
				if tel.edgeType ~= nil then newEdgeList.edgeType = tel.edgeType end
				if tel.edgeTypeName ~= nil then newEdgeList.edgeTypeName = tel.edgeTypeName end

				if i == 1 then
					newEdgeList.freeNodes[#newEdgeList.freeNodes+1] = 0
					newEdgeList.snapNodes[#newEdgeList.snapNodes+1] = 0
				end
				if i == #params.trackEdgeLists then
					newEdgeList.freeNodes[#newEdgeList.freeNodes+1] = 1
					newEdgeList.snapNodes[#newEdgeList.snapNodes+1] = 1
				end

				-- LOLLO TODO the edges don't snap to the neighbours
				-- I tried adding a tiny edge at the beginning, to make tracks snap to those outside the construction
				-- Instead of making more edges, I also tried shortening the 0 and N edge and see if they snap.
				-- I also tried both things together, to no avail.
				-- this does not help: adjacent tracks must be snapped by hand
				-- ask UG how to get these edges to snap; or better,
				-- ask them how to build this station without going through the construction.con file

				result.edgeLists[#result.edgeLists+1] = newEdgeList
			end
print('result.edgeLists =')
debugPrint(result.edgeLists)

			-- this is only a test to see if the transformation was ok. They match beautifully! Use this when talking to UG.
			-- if #result.edgeLists > 0 then
			-- 	local firstPosTanX2 = result.edgeLists[1].edges
			-- 	print('firstPosTanX2 =')
			-- 	debugPrint(firstPosTanX2)
			-- 	local retransformedFirstEdge = transfUtils.getPosTanX2Transformed(firstPosTanX2, params.myTransf)
			-- 	print('retransformed first edge =')
			-- 	debugPrint(retransformedFirstEdge)
			-- end

			for i = 1, #params.platformEdgeLists do
				local pel = params.platformEdgeLists[i]

				local newEdgeList = {
					edges = transfUtils.getPosTanX2Transformed(pel.posTanX2, inverseTransf),
					freeNodes = {},
					params = {
						type = pel.trackTypeName,
						catenary = false --pel.catenary
					},
					snapNodes = {},
					tag2Nodes = {},
					type = 'TRACK'
				}
				-- add tunnel or bridge if set
				if pel.edgeType ~= nil then newEdgeList.edgeType = pel.edgeType end
				if pel.edgeTypeName ~= nil then newEdgeList.edgeTypeName = pel.edgeTypeName end

				result.edgeLists[#result.edgeLists+1] = newEdgeList

				local platformPosTanX2 = transfUtils.getPosTanX2Transformed(pel.posTanX2, inverseTransf)
				local length = edgeUtils.getVectorLength({
					platformPosTanX2[1][1][1] - platformPosTanX2[2][1][1],
					platformPosTanX2[1][1][2] - platformPosTanX2[2][1][2],
					platformPosTanX2[1][1][3] - platformPosTanX2[2][1][3],
				})
				result.models[#result.models+1] = {
					id = 'lollo_freestyle_train_station/cargo_waiting_area.mdl',
					tag = 'platformTag',
					transf = transfUtilUG.mul(
                        {
                            length, 0, 0, 0,
                            0, length, 0, 0,
                            0, 0, 1, 0,
                            platformPosTanX2[1][1][1], platformPosTanX2[1][1][2], platformPosTanX2[1][1][3], 1
                        },
                        transfUtilUG.rotZ(math.atan2(platformPosTanX2[1][2][2], platformPosTanX2[1][2][1]))
                    )
				}
			end

			print('game =')
			if game ~= nil then
				print('game is there')
				if game.interface ~= nil then
					print('game.interface is there too')
				else
					print('game.interface is NIL')
				end
			else
				print('NIL')
			end

			print('api =')
			if api ~= nil then
                print('api is there')
            else
                print('NIL')
			end

			local _terminateConstructionHook = function()
				local allCargoAreaModelIndexesBase0 = {}
				for i = 1, #result.models do
					if result.models[i].tag == 'platformTag' then
						allCargoAreaModelIndexesBase0[#allCargoAreaModelIndexesBase0+1] = i - 1
					end
				end

				result.stations = {
					{
						tag = 0, -- in the stock station, this is 0 for cargo and 1 for passengers
						terminals = { } -- 0 is the position of the linked terminal group, in base 0
					}
				}

				table.insert(
					result.terminalGroups,
					{
						tag = 0,
						terminals = {
							{ 0, 0 }
						},
						-- LOLLO TODO ask UG if they can make a parameter similar to the following,
						-- to override personEdges and personNodes.
						-- This way, I won't be bound to using a model to assign a waiting area.
						vehicleNodeOverride = #params.trackEdgeLists - 1 --#result.edgeLists - 1
					}
				)

				for _, modelIndex in pairs(allCargoAreaModelIndexesBase0) do
					table.insert(result.terminalGroups[#result.terminalGroups].terminals, {modelIndex, 0})
				end

				table.insert(result.stations[1].terminals, 0)

				-- avoid dump when configuring
				if #(result.stations[1].terminals) == 0 then
					table.insert(result.stations[1].terminals, 0)
				end

				-- it should output something like (this example has one terminal made of two adjacent bits)
				-- stock result.stations =
				-- 	{
				-- 		{
				-- 			tag = 0, -- in the stock station, this is 0 for cargo and 1 for passengers
				-- 			terminals = { 0 } -- 0 is the position of the linked terminal group, in base 0
				-- 		}
				-- 	}
				-- stock result.terminalGroups =
				-- {
				-- 	{
				-- 		tag = -1, -- possibly useless, try to keep the m all different tho
				-- 		terminals = {
				-- 			{ 22, 0 }, -- 22 is the position of a model with a terminal, in base 0
				-- 			{ 25, 0 }, -- 0 is always 0 in the stock station, it is something like a terminal number
				-- 		}
				-- 	}
				-- }

				-- print('LOLLO lollo_freestyle_train_station leaving terminateConstructionHook')
				-- print('LOLLO result.models = ')
				-- debugPrint(result.models)
				-- print('LOLLO result.stations = ')
				-- debugPrint(result.stations)
				-- print('LOLLO result.terminalGroups = ')
				-- debugPrint(result.terminalGroups)
			end
			_terminateConstructionHook()

print('result =')
debugPrint(result)

			return result
		end,
--[[ 		preProcessFn = function(modules, change, three)
			-- this fires when the user adds or removes a module
			-- print('LOLLO preProcessFn')
			-- print('modules =')
			-- debugPrint(modules)
			-- print('change =')
			-- debugPrint(change)
			-- default behaviour
			if change.added then
				modules[change.slotId] = change.module
			else
				modules[change.slotId] = nil
			end
			-- airport behaviour
			-- if change.added then
			-- 	if change.slotId == landingSlotId + 1 then
			-- 		modules[landingSlotId + 0] = nil
			-- 	elseif change.slotId == landingSlotId + 0 then
			-- 		modules[landingSlotId + 1] = nil
			-- 	elseif change.slotId == landingSlotId + 2 then
			-- 		modules[landingSlotId + 3] = nil
			-- 	elseif change.slotId == landingSlotId + 3 then
			-- 		modules[landingSlotId + 2] = nil
			-- 	end
			-- 	modules[change.slotId] = change.module
			-- else
			-- 	modules[change.slotId] = nil
			-- end
			return modules
        end, ]]
        upgradeFn = function(params)
            print('LOLLO upgradeFn')
            local modules = {}

            local SwapModule = function(slotId, from, to)
                if params.modules[slotId] and params.modules[slotId].name == from then
                    table.insert(modules, {slotId, to})
                    return true
                end
                return false
            end
            local SwapRow = function(slotId, from, to)
                local slotId2 = slotId
                while SwapModule(slotId2, from, to) do 
                    slotId2 = slotId2 + 10
                end
                slotId2 = slotId
                while SwapModule(slotId2, from, to) do 
                    slotId2 = slotId2 - 10
                end
            end

            if params.modules[params.slotId] == nil then return {} end

            if params.catenaryToggle == 1 then 
                SwapRow(params.slotId, "station/rail/modular_station/platform_high_speed_track.module",
                    "station/rail/modular_station/platform_high_speed_track_catenary.module")
                SwapRow(params.slotId, "station/rail/modular_station/platform_track.module",
                    "station/rail/modular_station/platform_track_catenary.module")
                SwapRow(params.slotId, "station/rail/modular_station/platform_high_speed_track_catenary.module", 
                    "station/rail/modular_station/platform_high_speed_track.module")
                SwapRow(params.slotId, "station/rail/modular_station/platform_track_catenary.module", 
                    "station/rail/modular_station/platform_track.module")
            end
            if params.trackTypeToggle == 1 then 
                SwapRow(params.slotId, "station/rail/modular_station/platform_high_speed_track.module",
                    "station/rail/modular_station/platform_track.module")
                SwapRow(params.slotId, "station/rail/modular_station/platform_track.module",
                    "station/rail/modular_station/platform_high_speed_track.module")
                SwapRow(params.slotId, "station/rail/modular_station/platform_high_speed_track_catenary.module",
                    "station/rail/modular_station/platform_track_catenary.module")
                SwapRow(params.slotId, "station/rail/modular_station/platform_track_catenary.module",
                    "station/rail/modular_station/platform_high_speed_track_catenary.module")
            end

            return modules
        end,
	}
end