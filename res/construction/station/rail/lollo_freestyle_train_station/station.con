local _constants = require('lollo_freestyle_train_station.constants')
local arrayUtils = require('lollo_freestyle_train_station.arrayUtils')
local edgeUtils = require('lollo_freestyle_train_station.edgeUtils')
local moduleHelpers = require('lollo_freestyle_train_station.moduleHelpers')
local slotHelpers = require('lollo_freestyle_train_station.slotHelpers')
local stringUtils = require('lollo_freestyle_train_station.stringUtils')
local transfUtilsUG = require 'transf'
local transfUtils = require('lollo_freestyle_train_station.transfUtils')
local vec3 = require 'vec3'


function data()
	return {
		type = 'RAIL_STATION',
		description = {
			name = _("LolloFreestyleTrainStationName"),
			description = _("LolloFreestyleTrainStationDesc"),
		},
		availability = {
			yearFrom = -1, -- 1925, -- -1,
			yearTo = -1, -- -1, -- 0
		},
		order = 5005,
		soundConfig = {
			soundSet = { name = "station_cargo_old" }
		},
		autoRemovable = false,
		skipCollision = true, -- we need this when reconfiguring
		params = { -- keep it empty or it will crash coz it won't find the params, which I pass when building the construction
            -- {
            --     key = 'fileName',
            --     name = 'File Name',
            --     values = {
            --         'dummy',
            --     },
            --     defaultIndex = 0
            -- }
        },
		updateFn = function(params)
			-- print('updateFn starting, params =') debugPrint(params)
			print('updateFn starting, params.modules =') debugPrint(params.modules)
			if not params.modules then params.modules = {} end

			-- LOLLO NOTE I cannot call the api from here, sigh. api is there, but api.res is NIL. Also game is there, but game.interface is NIL
			local result = {
				colliders = {},
				-- coord2terminalInfo = {},
                cost = 1000,
                demangleId = slotHelpers.demangleId,
                edgeLists = {},
				groundFaces = {},
				labelText = {},
                mangleId = slotHelpers.mangleId,
				models = {
					-- {
					-- 	id = 'lollo_freestyle_train_station/icon/blue.mdl',
					-- 	tag = 'stationTag',
                    --     transf = {1, 0, 0, 0,
                    --         0, 1, 0, 0,
                    --         0, 0, 1, 0,
                    --         0, 0, 0, 1},
					-- },
                },
				slotConfig = {
					[_constants.flatStairsModuleType] = {
						maxModules = -1,
						message = nil, --'LOLLO slotConfig message',
						skipCollisionCheck = true,
					},
					[_constants.flatPassengerArea5x5ModuleType] = {
						maxModules = -1,
						message = nil, --'LOLLO slotConfig message',
						skipCollisionCheck = true,
					},
					[_constants.flatPassengerArea10x5ModuleType] = {
						maxModules = -1,
						message = nil, --'LOLLO slotConfig message',
						skipCollisionCheck = true,
					},
					[_constants.flatPassengerArea10x10ModuleType] = {
						maxModules = -1,
						message = nil, --'LOLLO slotConfig message',
						skipCollisionCheck = true,
					},
					[_constants.slopedPassengerArea1x5ModuleType] = {
						maxModules = -1,
						message = nil, --'LOLLO slotConfig message',
						skipCollisionCheck = true,
					},
					[_constants.slopedPassengerArea1x10ModuleType] = {
						maxModules = -1,
						message = nil, --'LOLLO slotConfig message',
						skipCollisionCheck = true,
					},
					[_constants.slopedPassengerArea1x20ModuleType] = {
						maxModules = -1,
						message = nil, --'LOLLO slotConfig message',
						skipCollisionCheck = true,
					},
					[_constants.cargoTerminalModuleType] = {
						maxModules = -1,
						message = nil, --'LOLLO slotConfig message',
						skipCollisionCheck = true,
					},
					[_constants.passengerTerminalModuleType] = {
						maxModules = -1,
						message = nil, --'LOLLO slotConfig message',
						skipCollisionCheck = true,
					},
					[_constants.underpassModuleType] = {
						maxModules = -1,
						message = nil, --'LOLLO slotConfig message',
						skipCollisionCheck = true,
					}
				},
                slots = {},
				stations = {},
				terminalGroups = {},
				terrainAlignmentLists = { { -- LOLLO NOTE populate this, otherwise the game will make its own, with spikes and all
					type = "EQUAL",
					faces =  { }
				} }
			}

			local occupiedInfo = {
				crossConnectorsWithFlatAreas = { },
				crossConnectorsWithSlopedAreas = { },
			}
			local _getOccupiedInfo4FlatAreas = function(t, i)
				if occupiedInfo.crossConnectorsWithFlatAreas[t] == nil or occupiedInfo.crossConnectorsWithFlatAreas[t][i] == nil then
					return false
				else
					return occupiedInfo.crossConnectorsWithFlatAreas[t][i]
				end
			end
			local _setOccupiedInfo4FlatAreas = function(t, i, newValue)
				if occupiedInfo.crossConnectorsWithFlatAreas[t] == nil then
					occupiedInfo.crossConnectorsWithFlatAreas[t] = {}
				end
				occupiedInfo.crossConnectorsWithFlatAreas[t][i] = newValue
			end
			local _getOccupiedInfo4SlopedAreas = function(t, i)
				if occupiedInfo.crossConnectorsWithSlopedAreas[t] == nil or occupiedInfo.crossConnectorsWithSlopedAreas[t][i] == nil then
					return false
				else
					return occupiedInfo.crossConnectorsWithSlopedAreas[t][i]
				end
			end
			local _setOccupiedInfo4SlopedAreas = function(t, i, newValue)
				if occupiedInfo.crossConnectorsWithSlopedAreas[t] == nil then
					occupiedInfo.crossConnectorsWithSlopedAreas[t] = {}
				end
				occupiedInfo.crossConnectorsWithSlopedAreas[t][i] = newValue
			end
			local terminateConstructionHookInfo = {
				crossConnectorPositions = {},
				isAnyCargoTerminal = false,
				isAnyPassengerTerminal = false,
				underpassPositions = {},
				vehicleNodes = {}
			}
			-- LOLLO NOTE the coordinates in terminals are absolute
			local mainTransf = params.mainTransf
			local inverseMainTransf = transfUtils.getInverseTransf(mainTransf)
			-- print('inverseMainTransf =') debugPrint(inverseMainTransf)

			for t = 1, #params.terminals do
				local isCargoTerminal = params.terminals[t].isCargo
				if isCargoTerminal then terminateConstructionHookInfo.isAnyCargoTerminal = true else terminateConstructionHookInfo.isAnyPassengerTerminal = true end

				-- add track edges
				terminateConstructionHookInfo.vehicleNodes[t] = (#result.edgeLists + params.terminals[t].midTrackIndex) * 2 - 2
				for i = 1, #params.terminals[t].trackEdgeLists do
					local tel = params.terminals[t].trackEdgeLists[i]
					local newEdgeList = {
						-- alignTerrain = tel.type == 0, -- only align on ground, not on bridges or tunnels -- useless
						edges = transfUtils.getPosTanX2Transformed(tel.posTanX2, inverseMainTransf),
						edgeType = tel.edgeType,
						edgeTypeName = tel.edgeTypeName,
						freeNodes = {},
						params = {
							type = tel.trackTypeName,
							catenary = tel.catenary
						},
						snapNodes = {},
						-- tag2Nodes = {},
						type = 'TRACK'
					}

					if i == 1 then
						newEdgeList.snapNodes[#newEdgeList.snapNodes+1] = 0
					end
					if i == #params.terminals[t].trackEdgeLists then
						newEdgeList.snapNodes[#newEdgeList.snapNodes+1] = 1
					end

					-- LOLLO NOTE the edges won't snap to the neighbours
					-- unless you rebuild those neighbours, by hand or by script,
					-- and make them snap to the station own nodes.
					result.edgeLists[#result.edgeLists+1] = newEdgeList
				end

				-- this is only a test to see if the transformation was ok. They match beautifully! Use this when talking to UG.
				-- if #result.edgeLists > 0 then
				-- 	local firstPosTanX2 = result.edgeLists[1].edges
				-- 	print('firstPosTanX2 =') debugPrint(firstPosTanX2)
				-- 	local retransformedFirstEdge = transfUtils.getPosTanX2Transformed(firstPosTanX2, params.myTransf)
				-- 	print('retransformed first edge =') debugPrint(retransformedFirstEdge)
				-- end

				-- add platform edges
				for i = 1, #params.terminals[t].platformEdgeLists do
					local pel = params.terminals[t].platformEdgeLists[i]

					local newEdgeList = {
						-- alignTerrain = pel.type == 0, -- only align on ground, not on bridges or tunnels -- useless
						edges = transfUtils.getPosTanX2Transformed(pel.posTanX2, inverseMainTransf),
						edgeType = pel.edgeType,
						edgeTypeName = pel.edgeTypeName,
						freeNodes = {},
						params = {
							type = pel.trackTypeName,
							catenary = false --pel.catenary
						},
						snapNodes = {},
						-- tag2Nodes = {},
						type = 'TRACK'
					}

					if i == 1 then
						newEdgeList.snapNodes[#newEdgeList.snapNodes+1] = 0
					end
					if i == #params.terminals[t].platformEdgeLists then
						newEdgeList.snapNodes[#newEdgeList.snapNodes+1] = 1
					end

					result.edgeLists[#result.edgeLists+1] = newEdgeList
				end

				local isTrackOnPlatformLeft = params.terminals[t].isTrackOnPlatformLeft

				-- add alongside bits, trackside
				for ii = 1, #params.terminals[t].centrePlatformsFine do
					local yShiftTrackside = isTrackOnPlatformLeft and 0.5 or -0.5
					local cpf = params.terminals[t].centrePlatformsFine[ii]
					local posTanX2 = transfUtils.getPosTanX2Transformed(cpf.posTanX2, inverseMainTransf)
					result.models[#result.models+1] = {
						id = 'lollo_freestyle_train_station/railroad/track/era_c_passenger_platform_1m_base_2_5m_wide_stripes.mdl',
						-- tag = slotHelpers.mangleModelTag(t, false),
						transf = transfUtilsUG.mul(
							moduleHelpers.getPlatformObjectTransf_WithYRotation(posTanX2),
							{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, yShiftTrackside, _constants.tracksideBitsZ, 1 }
						)
					}
				end

				-- add alongside bits, outside
				for i = 2, #params.terminals[t].centrePlatforms, 3 do
					if params.terminals[t].centrePlatforms[i].type == 0 then -- only on ground
						local cpl = params.terminals[t].centrePlatforms[i]
						local posTanX2 = transfUtils.getPosTanX2Transformed(cpl.posTanX2, inverseMainTransf)
						local yShiftOutside = isTrackOnPlatformLeft and -3.4 or 3.4
						local myId = result.mangleId(t, i, _constants.idBases.slopedPassengerArea1x5SlotId)
						table.insert(result.slots, {
							-- height = 0,
							id = myId,
							spacing = isTrackOnPlatformLeft and {4.5, 1, 8, 8} or {1, 4.5, 8, 8},
							transf = transfUtilsUG.mul(
								moduleHelpers.getPlatformObjectTransf_WithYRotation(posTanX2),
								{ 0, 1, 0, 0,  -1, 0, 0, 0,  0, 0, 1, 0,  0, yShiftOutside, _constants.tracksideBitsZ, 1 }
							),
							type = _constants.slopedPassengerArea1x5ModuleType,
						})
						if params.modules[myId] ~= nil then
							-- local yShift = isTrackOnPlatformLeft and -5 or 5
							local yShift = 10
							_setOccupiedInfo4SlopedAreas(t, i-1, yShift)
							_setOccupiedInfo4SlopedAreas(t, i, yShift)
							_setOccupiedInfo4SlopedAreas(t, i+1, yShift)
						end
						yShiftOutside = isTrackOnPlatformLeft and -5.9 or 5.9
						myId = result.mangleId(t, i, _constants.idBases.slopedPassengerArea1x10SlotId)
						table.insert(result.slots, {
							-- height = 0,
							id = myId,
							spacing = isTrackOnPlatformLeft and {7, 3, 8, 8} or {3, 7, 8, 8},
							transf = transfUtilsUG.mul(
								moduleHelpers.getPlatformObjectTransf_WithYRotation(posTanX2),
								{ 0, 1, 0, 0,  -1, 0, 0, 0,  0, 0, 1, 0,  0, yShiftOutside, _constants.tracksideBitsZ, 1 }
							),
							type = _constants.slopedPassengerArea1x10ModuleType,
						})
						if params.modules[myId] ~= nil then
							-- local yShift = isTrackOnPlatformLeft and -10 or 10
							local yShift = 15
							_setOccupiedInfo4SlopedAreas(t, i-1, yShift)
							_setOccupiedInfo4SlopedAreas(t, i, yShift)
							_setOccupiedInfo4SlopedAreas(t, i+1, yShift)
						end
						yShiftOutside = isTrackOnPlatformLeft and -10.9 or 10.9
						myId = result.mangleId(t, i, _constants.idBases.slopedPassengerArea1x20SlotId)
						table.insert(result.slots, {
							-- height = 0,
							id = myId,
							spacing = isTrackOnPlatformLeft and {12, 5, 8, 8} or {5, 12, 8, 8},
							transf = transfUtilsUG.mul(
								moduleHelpers.getPlatformObjectTransf_WithYRotation(posTanX2),
								{ 0, 1, 0, 0,  -1, 0, 0, 0,  0, 0, 1, 0,  0, yShiftOutside, _constants.tracksideBitsZ, 1 }
							),
							type = _constants.slopedPassengerArea1x20ModuleType,
						})
						if params.modules[myId] ~= nil then
							-- local yShift = isTrackOnPlatformLeft and -20 or 20
							local yShift = 25
							_setOccupiedInfo4SlopedAreas(t, i-1, yShift)
							_setOccupiedInfo4SlopedAreas(t, i, yShift)
							_setOccupiedInfo4SlopedAreas(t, i+1, yShift)
						end
					end
				end

				-- add flat area slots on ground
				for i = 1, #params.terminals[t].centrePlatforms do
					if params.terminals[t].centrePlatforms[i].type == 0 then
						local isUnderpass = params.modules[result.mangleId(t, i, _constants.idBases.underpassSlotId)] ~= nil
						local isPreviousUnderpass = i > 1
							and params.modules[result.mangleId(t, i-1, _constants.idBases.underpassSlotId)] ~= nil
							or false
						local crossConnectorPosTanX2 = transfUtils.getPosTanX2Transformed(params.terminals[t].crossConnectors[i].posTanX2, inverseMainTransf)
						-- add small flat area slots on ground, away from underpasses
						if not(isUnderpass) and not(isPreviousUnderpass) then
							if not(_getOccupiedInfo4FlatAreas(t, i))
							or _getOccupiedInfo4FlatAreas(t, i) == _constants.idBases.flatStairsSlotId then
								local yShift = params.terminals[t].centrePlatforms[i].trackDistance + (_getOccupiedInfo4SlopedAreas(t, i) or 0)
								local myPosTanX2 = moduleHelpers.getExtrapolatedPosTanX2Continuation(crossConnectorPosTanX2, yShift)
								local myTransf = transfUtilsUG.mul(
									moduleHelpers.getPlatformObjectTransf_AlwaysVertical(myPosTanX2),
									{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, 0, 1 }
								)
								local myId = result.mangleId(t, i, _constants.idBases.flatStairsSlotId)
								table.insert(result.slots, {
									-- height = 0,
									id = myId,
									spacing = {1, 10, 2, 2},
									transf = myTransf,
									type = _constants.flatStairsModuleType,
								})
								if params.modules[myId] ~= nil then
									local lane2AreaTransf = moduleHelpers.get1MLaneTransf(
										{
											myPosTanX2[1][1][1],
											myPosTanX2[1][1][2],
											myPosTanX2[1][1][3] + _constants.passengerLaneZ,
										},
										transfUtils.transf2Position(myTransf)
									)
									result.models[#result.models+1] = {
										id = _constants.passengerLaneOnPlatformModelId,
										tag = slotHelpers.mangleModelTag(t, false),
										transf = lane2AreaTransf
									}
									_setOccupiedInfo4FlatAreas(t, i, _constants.idBases.flatStairsSlotId)
								end
							end

							if not(_getOccupiedInfo4FlatAreas(t, i))
							or _getOccupiedInfo4FlatAreas(t, i) == _constants.idBases.flatPassengerArea5x5SlotId then
								local yShift = params.terminals[t].centrePlatforms[i].trackDistance + 5 + (_getOccupiedInfo4SlopedAreas(t, i) or 0)
								local myPosTanX2 = moduleHelpers.getExtrapolatedPosTanX2Continuation(crossConnectorPosTanX2, yShift)
								local myTransf = transfUtilsUG.mul(
									moduleHelpers.getPlatformObjectTransf_AlwaysVertical(myPosTanX2),
									{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, -0.1, 1 } -- a lil lower for steeper stations
								)
								local myId = result.mangleId(t, i, _constants.idBases.flatPassengerArea5x5SlotId)
								table.insert(result.slots, {
									-- height = 0,
									id = myId,
									spacing = {1, 10, 2, 2},
									-- transf = moduleHelpers.getPlatformObjectTransf_AlwaysVertical(area5x5PosTanX2),
									-- transf = {
									-- 	1, 0, 0, 0,
									-- 	0, 1, 0, 0,
									-- 	0, 0, 1, 0,
									-- 	area5x5PosTanX2[2][1][1], area5x5PosTanX2[2][1][2], area5x5PosTanX2[2][1][3], 1
									-- },
									-- transf = transfUtilsUG.mul(
									-- 	moduleHelpers.getPlatformObjectTransf_WithYRotation(area5x5PosTanX2),
									-- 	{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, -1, 1 }
									-- ),
									transf = myTransf,
									type = _constants.flatPassengerArea5x5ModuleType,
								})
								-- LOLLO TODO make sure to avoid duplicating edges when naking these lanes
								-- LOLLO TODO make sure to avoid overlapping sloped and flat areas
								if params.modules[myId] ~= nil then
									local lane2AreaTransf = moduleHelpers.get1MLaneTransf(
										{
											myPosTanX2[1][1][1],
											myPosTanX2[1][1][2],
											myPosTanX2[1][1][3] + _constants.passengerLaneZ,
										},
										transfUtils.transf2Position(myTransf)
									)
									result.models[#result.models+1] = {
										id = _constants.passengerLaneOnPlatformModelId,
										tag = slotHelpers.mangleModelTag(t, false),
										transf = lane2AreaTransf
									}
									_setOccupiedInfo4FlatAreas(t, i, _constants.idBases.flatPassengerArea5x5SlotId)
								end
							end
						end
						-- add large flat area slots on ground
						if not(_getOccupiedInfo4FlatAreas(t, i))
						or _getOccupiedInfo4FlatAreas(t, i) == _constants.idBases.flatPassengerArea10x5SlotId then
							-- local yShift = 7.5 + (occupiedInfo.crossConnectorsWithSlopedArea[i] or 0)
							local yShift = params.terminals[t].centrePlatforms[i].trackDistance + 5 + (_getOccupiedInfo4SlopedAreas(t, i) or 0)
							local myPosTanX2 = moduleHelpers.getExtrapolatedPosTanX2Continuation(crossConnectorPosTanX2, yShift)
							local myTransf = transfUtilsUG.mul(
								moduleHelpers.getPlatformObjectTransf_AlwaysVertical(myPosTanX2),
								{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, 0.1, 1 }
							)
							local myId = result.mangleId(t, i, _constants.idBases.flatPassengerArea10x5SlotId)
							table.insert(result.slots, {
								-- height = 0,
								id = myId,
								spacing = {1, 10, 3, 3},
								transf = myTransf,
								type = _constants.flatPassengerArea10x5ModuleType,
							})
							if not(isUnderpass) and not(isPreviousUnderpass) and params.modules[myId] ~= nil then
								local lane2AreaTransf = moduleHelpers.get1MLaneTransf(
									{
										myPosTanX2[1][1][1],
										myPosTanX2[1][1][2],
										myPosTanX2[1][1][3] + _constants.passengerLaneZ,
									},
									transfUtils.transf2Position(myTransf)
								)
								result.models[#result.models+1] = {
									id = _constants.passengerLaneOnPlatformModelId,
									tag = slotHelpers.mangleModelTag(t, false),
									transf = lane2AreaTransf
								}
								_setOccupiedInfo4FlatAreas(t, i, _constants.idBases.flatPassengerArea10x5SlotId)
							end
						end
						if not(_getOccupiedInfo4FlatAreas(t, i))
						or _getOccupiedInfo4FlatAreas(t, i) == _constants.idBases.flatPassengerArea10x10SlotId then
							-- local yShift = 12.5 + (occupiedInfo.crossConnectorsWithSlopedArea[i] or 0)
							local yShift = params.terminals[t].centrePlatforms[i].trackDistance + 10 + (_getOccupiedInfo4SlopedAreas(t, i) or 0)
							local myPosTanX2 = moduleHelpers.getExtrapolatedPosTanX2Continuation(crossConnectorPosTanX2, yShift)
							local myTransf = transfUtilsUG.mul(
								moduleHelpers.getPlatformObjectTransf_AlwaysVertical(myPosTanX2),
								{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, 0.1, 1 }
							)
							local myId = result.mangleId(t, i, _constants.idBases.flatPassengerArea10x10SlotId)
							table.insert(result.slots, {
								-- height = 0,
								id = myId,
								spacing = {1, 10, 3, 3},
								transf = myTransf,
								type = _constants.flatPassengerArea10x10ModuleType,
							})
							if not(isUnderpass) and not(isPreviousUnderpass) and params.modules[myId] ~= nil then
								local lane2AreaTransf = moduleHelpers.get1MLaneTransf(
									{
										myPosTanX2[1][1][1],
										myPosTanX2[1][1][2],
										myPosTanX2[1][1][3] + _constants.passengerLaneZ,
									},
									transfUtils.transf2Position(myTransf)
								)
								result.models[#result.models+1] = {
									id = _constants.passengerLaneOnPlatformModelId,
									tag = slotHelpers.mangleModelTag(t, false),
									transf = lane2AreaTransf
								}
								_setOccupiedInfo4FlatAreas(t, i, _constants.idBases.flatPassengerArea10x10SlotId)
							end
						end
					end
				end

				-- add waiting areas and lanes
				-- Instead of different cargo platforms with different widths, we could only use 5m areas for all,
				-- and add new modules for extra space, parallel to the platform-tracks.
				-- However, it is easier to place more platform-tracks upfront than add modules later,
				-- so we go this way.
				-- print('add waiting areas and lanes')
				if isCargoTerminal then
					for _, cwa in pairs(params.terminals[t].cargoWaitingAreas) do
						for i = 1, #cwa do
							local posTanX2 = transfUtils.getPosTanX2Transformed(cwa[i].posTanX2, inverseMainTransf)
							local centreLaneTransf = moduleHelpers.get1MLaneTransf(posTanX2[1][1], posTanX2[2][1])
							result.models[#result.models+1] = {
								id = _constants.cargoWaitingAreaModelId,
								tag = slotHelpers.mangleModelTag(t, true),
								transf = transfUtilsUG.mul(centreLaneTransf, {1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _constants.cargoLaneZ, 1})
							}
						end
					end
				else
					for i = 1, #params.terminals[t].centrePlatforms do
						local isUnderpass = params.modules[result.mangleId(t, i, _constants.idBases.underpassSlotId)] ~= nil
						local posTanX2 = transfUtils.getPosTanX2Transformed(params.terminals[t].centrePlatforms[i].posTanX2, inverseMainTransf)
						local centreLaneTransf = moduleHelpers.get1MLaneTransf(posTanX2[1][1], posTanX2[2][1])
						result.models[#result.models+1] = {
							id = isUnderpass and _constants.passengerLaneUnderpassModelId or _constants.passengerLaneOnPlatformModelId,
							tag = slotHelpers.mangleModelTag(t, false, isUnderpass),
							transf = transfUtilsUG.mul(centreLaneTransf, {1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _constants.passengerLaneZ, 1})
						}

						local crossConnectorPosTanX2 = transfUtils.getPosTanX2Transformed(params.terminals[t].crossConnectors[i].posTanX2, inverseMainTransf)
						if isUnderpass then
							local underpassBottomTransf = transfUtilsUG.mul(
								centreLaneTransf,
								{ 0.1, 0, 0, 0,  0, 0.1, 0, 0,  0, 0, 1, 0,  _constants.underpassLengthM * 0.5, 0, _constants.passengerLaneZ - _constants.underpassDepthM, 1 }
							)
							if terminateConstructionHookInfo.underpassPositions[t] == nil then terminateConstructionHookInfo.underpassPositions[t] = {} end
							terminateConstructionHookInfo.underpassPositions[t][#terminateConstructionHookInfo.underpassPositions[t]+1] = {
								t = t,
								pos1 = posTanX2[1][1],
								pos2 = posTanX2[2][1],
								posBottom = {
									underpassBottomTransf[13],
									underpassBottomTransf[14],
									underpassBottomTransf[15]
								}
							}
						elseif params.modules[result.mangleId(t, i-1, _constants.idBases.underpassSlotId)] == nil then
							local crossConnectorTransf = transfUtilsUG.mul(
								moduleHelpers.get1MLaneTransf(crossConnectorPosTanX2[1][1], crossConnectorPosTanX2[2][1]),
								{1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _constants.passengerLaneZ, 1}
							)
							result.models[#result.models+1] = {
								id = _constants.passengerLaneOnPlatformModelId,
								tag = slotHelpers.mangleModelTag(t, false),
								transf = crossConnectorTransf
							}
							if terminateConstructionHookInfo.crossConnectorPositions[t] == nil then terminateConstructionHookInfo.crossConnectorPositions[t] = {} end
							table.insert(
								terminateConstructionHookInfo.crossConnectorPositions[t],
								{
									t = t,
									pos = {
										posTanX2[2][1][1],
										posTanX2[2][1][2],
										posTanX2[2][1][3] + _constants.passengerLaneZ,
									}
								}
							)
						end

					end
					if isTrackOnPlatformLeft then
						for i = 1, #params.terminals[t].leftPlatforms do
							local posTanX2Relative = transfUtils.getPosTanX2Transformed(params.terminals[t].leftPlatforms[i].posTanX2, inverseMainTransf)
							local leftLaneTransf = moduleHelpers.get1MLaneTransf(posTanX2Relative[1][1], posTanX2Relative[2][1])

							result.models[#result.models+1] = {
								id = _constants.passengerWaitingAreaModelId,
								tag = slotHelpers.mangleModelTag(t, false),
								transf = transfUtilsUG.mul(leftLaneTransf, {1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _constants.passengerLaneZ, 1})
							}
						end
					else
						for i = 1, #params.terminals[t].rightPlatforms do
							local posTanX2Relative = transfUtils.getPosTanX2Transformed(params.terminals[t].rightPlatforms[i].posTanX2, inverseMainTransf)
							local rightLaneTransf = moduleHelpers.get1MLaneTransf(posTanX2Relative[1][1], posTanX2Relative[2][1])

							result.models[#result.models+1] = {
								id = _constants.passengerWaitingAreaModelId,
								tag = slotHelpers.mangleModelTag(t, false),
								transf = transfUtilsUG.mul(rightLaneTransf, {1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _constants.passengerLaneZ, 1})
							}
						end
					end
				end

				local _addTerminalSlot = function()
					local i = params.terminals[t].midTrackIndex
					local wap = params.terminals[t].trackEdgeLists[i]
					local posTanX2 = transfUtils.getPosTanX2Transformed(wap.posTanX2, inverseMainTransf)
					local unitaryTangent = moduleHelpers.getPosTanX2Normalised(posTanX2)
					-- LOLLO TODO the underpasses turn yellow when the user wants to remove them:
					-- good, but these guys don't, unless there is only one terminal: why?
					-- A similar issue happens when you try to bulldoze a platform-track:
					-- the yellow area is there, but it is a surface below the top.
					-- For terminals, the yellow areas only turn up when there is one terminal only.
					-- Maybe height must be exact?
					table.insert(result.slots, {
						-- height = 0,
						id = result.mangleId(t, 0, _constants.idBases.terminalSlotId),
						spacing = _constants.trackSpacing,
						transf = moduleHelpers.getPlatformObjectTransf_WithYRotation(unitaryTangent),
						type = isCargoTerminal and _constants.cargoTerminalModuleType or _constants.passengerTerminalModuleType,
					})
				end
				_addTerminalSlot()

				local _addUnderpassSlots = function()
					-- add underpass slots, skipping the ends
					if not(isCargoTerminal) then
						for i = 2, #params.terminals[t].centrePlatforms - 1, 4 do
							local posTanX2 = transfUtils.getPosTanX2Transformed(params.terminals[t].centrePlatforms[i].posTanX2, inverseMainTransf)
							table.insert(result.slots, {
								-- height = 1,
								id = result.mangleId(t, i, _constants.idBases.underpassSlotId),
								-- shape 0 1 2 3, only graphical
								spacing = _constants.underpassSpacing,
								transf = moduleHelpers.getPlatformObjectTransf_AlwaysVertical(posTanX2),
								type = _constants.underpassModuleType,
							})
							if params.modules[result.mangleId(t, i, _constants.idBases.underpassSlotId)] ~= nil then
								result.models[#result.models+1] = {
									id = _constants.underpassGroundModelFileName,
									transf = transfUtilsUG.mul(
										moduleHelpers.getPlatformObjectTransf_WithYRotation(posTanX2),
										{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, 0.225, 1 }
									)
								}
							end
						end
					end
				end
				_addUnderpassSlots()
			end -- loop over terminals

			result.terminateConstructionHook = function()
				-- print('terminateConstructionHook starting')
				-- LOLLO NOTE stations with mixed cargo and passengers seem impossible by design.
				-- There are some assertions, like allPersonEdgesHaveTransportModePerson != allPersonEdgesHaveTransportModeCargo,
				-- that point at this.
				local _groupTerminals = function()
					result.stations = { }
					if terminateConstructionHookInfo.isAnyCargoTerminal then
						result.stations[#result.stations+1] = {
							tag = 0, -- in the stock station, this is 0 for cargo and 1 for passengers
							terminals = { } -- 0 is the position of the linked terminal group, in base 0
						}
					end
					if terminateConstructionHookInfo.isAnyPassengerTerminal then
						result.stations[#result.stations+1] = {
							tag = 1, -- in the stock station, this is 0 for cargo and 1 for passengers
							terminals = { } -- 0 is the position of the linked terminal group, in base 0
						}
					end

					for t = 1, #params.terminals do
						local isCargoTerminal = params.terminals[t].isCargo
						table.insert(
							result.terminalGroups,
							{
								tag = t - 1,
								terminals = {
									-- { 0, 0 }
								},
								-- UG TODO ask UG if they can make a parameter similar to the following,
								-- to override personEdges and personNodes.
								-- This way, I won't be bound to using a model to assign a waiting area.
								-- LOLLO NOTE there can be 1 terminal 4 1 vehicle node,
								-- n terminals 4 1 person edge,
								-- n terminals 4 1 person node
								-- vehicleNodeOverride = #params.terminals[t].trackEdgeLists - 1
								vehicleNodeOverride = terminateConstructionHookInfo.vehicleNodes[t]
							}
						)

						local modelIndexesBase0 = {}
						for i = 1, #result.models do
							if slotHelpers.getTerminalFromModelTag(result.models[i].tag) == t then
								modelIndexesBase0[#modelIndexesBase0+1] = i - 1
							-- elseif result.models[i].slotId ~= nil then
							-- 	local nTerminal, _, _ = slotHelpers.demangleId(result.models[i].slotId)
							-- 	if nTerminal == t then
							-- 		modelIndexesBase0[#modelIndexesBase0+1] = i - 1
							-- 	end
							end
						end
						for _, modelIndex in pairs(modelIndexesBase0) do
							-- table.insert(result.terminalGroups[#result.terminalGroups].terminals, {modelIndex, t - 1}) -- NO!
							table.insert(result.terminalGroups[#result.terminalGroups].terminals, {modelIndex, 0})
						end

						local stationIndex = arrayUtils.findIndex(result.stations, 'tag', isCargoTerminal and 0 or 1)
						table.insert(result.stations[stationIndex].terminals, t - 1)
					end
				end
				_groupTerminals()
				-- print('terminals grouped')
				local _linkUnderpasses = function()
					-- link the underpasses along terminals, underground
					for t = 1, #params.terminals do
						local positionsInTerminal = terminateConstructionHookInfo.underpassPositions[t]
						if positionsInTerminal ~= nil and #positionsInTerminal > 1 then
							local previousPosition = positionsInTerminal[1]
							for i = 2, #positionsInTerminal do
								local currentPosition = positionsInTerminal[i]
								result.models[#result.models+1] = {
									id = _constants.passengerLaneModelId,
									-- tag = slotHelpers.mangleModelTag(t, false),
									transf = moduleHelpers.get1MLaneTransf(
										previousPosition.posBottom,
										currentPosition.posBottom
									)
								}
								previousPosition = currentPosition
							end
						end
					end

					-- link the underpasses across terminals, underground
					-- for now, I link each terminal to 1 other terminal only, the closest with an underpass.
					local _getDistances = function()
						-- local allDistances = {}
						local minDistances = {}
						for t = 1, #params.terminals do
							local positionsInT = terminateConstructionHookInfo.underpassPositions[t]
							if positionsInT ~= nil then
								for i = 1, #positionsInT do
									for tt = t + 1, #params.terminals do
										local positionsInTT = terminateConstructionHookInfo.underpassPositions[tt]
										if positionsInTT ~= nil then
											for ii = 1, #positionsInTT do
												-- if allDistances[t] == nil then allDistances[t] = {} end
												-- if allDistances[t][tt] == nil then allDistances[t][tt] = {} end
												if minDistances[t] == nil then minDistances[t] = {} end

												local distance = edgeUtils.getVectorLength(
													{
														positionsInT[i].posBottom[1] - positionsInTT[ii].posBottom[1],
														positionsInT[i].posBottom[2] - positionsInTT[ii].posBottom[2],
														positionsInT[i].posBottom[3] - positionsInTT[ii].posBottom[3],
													}
												)
												-- table.insert(
												-- 	allDistances[t][tt],
												-- 	{
												-- 		t = t,
												-- 		tt = tt,
												-- 		i = i,
												-- 		ii = ii,
												-- 		distance = distance
												-- 	}
												-- )

												if minDistances[t][tt] == nil or minDistances[t][tt].distance > distance then
													minDistances[t][tt] = {
														t = t,
														tt = tt,
														i = i,
														ii = ii,
														distance = distance
													}
												end
											end
										end
									end
								end
							end
						end

						-- return allDistances, minDistances
						return minDistances
					end
					-- local allDistances, minDistances = _getDistances()
					local minDistances = _getDistances()
					-- print('allDistances =') debugPrint(allDistances)
					-- print('minDistances =') debugPrint(minDistances)

					for t = 1, #params.terminals do
						local positionsInT = terminateConstructionHookInfo.underpassPositions[t]
						if positionsInT ~= nil then
							local minDistance4T = nil
							for tt = t + 1, #params.terminals do
								local positionsInTT = terminateConstructionHookInfo.underpassPositions[tt]
								if positionsInTT ~= nil then
									if minDistances[t][tt] ~= nil then
										if minDistance4T == nil or minDistances[t][tt].distance < minDistance4T.distance then
											minDistance4T = minDistances[t][tt]
										end
									end
								end
							end
							if minDistance4T ~= nil then
								result.models[#result.models+1] = {
									id = _constants.passengerLaneModelId,
									-- tag = slotHelpers.mangleModelTag(t, false),
									transf = moduleHelpers.get1MLaneTransf(
										terminateConstructionHookInfo.underpassPositions[minDistance4T.t][minDistance4T.i].posBottom,
										terminateConstructionHookInfo.underpassPositions[minDistance4T.tt][minDistance4T.ii].posBottom
									)
								}
							end
						end
					end
				end
				_linkUnderpasses()
				local _linkPassengerPlatforms = function()
					-- link the underpasses across terminals, on the ground, if they are close enough
					for t = 1, #params.terminals do
						local positionsInT = terminateConstructionHookInfo.crossConnectorPositions[t]
						if positionsInT ~= nil then
							for tt = t + 1, #params.terminals do
								local positionsInTT = terminateConstructionHookInfo.crossConnectorPositions[tt]
								if positionsInTT ~= nil then
									for i = 1, #positionsInT do
										for ii = 1, #positionsInTT do
											if edgeUtils.getPositionsDistance(positionsInT[i].pos, positionsInTT[ii].pos) < 6 then
												result.models[#result.models+1] = {
													id = _constants.passengerLaneModelId,
													-- tag = slotHelpers.mangleModelTag(t, false),
													transf = moduleHelpers.get1MLaneTransf(
														positionsInT[i].pos,
														positionsInTT[ii].pos
													)
												}
											end
										end
									end
								end
							end
						end
					end
				end
				_linkPassengerPlatforms()
				-- print('underpasses linked')
				-- avoid dump when configuring
				-- if #(result.stations[1].terminals) == 0 then
				-- 	print('avoiding dump when configuring')
				-- 	table.insert(result.stations[1].terminals, 0)
				-- 	print('result.stations =') debugPrint(result.stations)
				-- end

				-- it should output something like (this example has one terminal made of two adjacent bits)
				-- stock result.stations =
				-- 	{
				-- 		{
				-- 			tag = 0, -- in the stock station, this is 0 for cargo and 1 for passengers
				-- 			terminals = { 0 } -- 0 is the position of the linked terminal group, in base 0
				-- 		}
				-- 	}
				-- stock result.terminalGroups =
				-- {
				-- 	{
				-- 		tag = -1, -- possibly useless, try to keep them all different tho
				-- 		terminals = {
				-- 			{ 22, 0 }, -- 22 is the position of a model with a terminal, in base 0
				-- 			{ 25, 0 }, -- 0 is always 0 in the stock station, it is something like a terminal number
				-- 		}
				-- 	}
				-- }

				-- print('LOLLO lollo_freestyle_train_station leaving terminateConstructionHook')
				-- print('LOLLO result = ') debugPrint(result)
				-- print('LOLLO result.stations = ') debugPrint(result.stations)
				-- print('LOLLO result.models = ') debugPrint(result.models)
				-- print('LOLLO result.terminalGroups = ') debugPrint(result.terminalGroups)
			end -- end of terminateConstructionHook()

			-- print('freestyleTrainStation.updateFn about to return')
			-- print('freestyleTrainStation result =') debugPrint(result)
			-- print('freestyleTrainStation result.terrainAlignmentLists =') debugPrint(result.terrainAlignmentLists)
			return result
		end,
 		-- preProcessFn = function(modules, change, three)
		-- 	-- this fires when the user adds or removes a module
		-- 	print('LOLLO preProcessFn')
		-- 	print('modules =') debugPrint(modules)
		-- 	print('change =') debugPrint(change)
		-- 	-- default behaviour
		-- 	if change.added then
		-- 		modules[change.slotId] = change.module
		-- 	else
		-- 		modules[change.slotId] = nil
		-- 	end
		-- 	-- airport behaviour
		-- 	-- if change.added then
		-- 	-- 	if change.slotId == landingSlotId + 1 then
		-- 	-- 		modules[landingSlotId + 0] = nil
		-- 	-- 	elseif change.slotId == landingSlotId + 0 then
		-- 	-- 		modules[landingSlotId + 1] = nil
		-- 	-- 	elseif change.slotId == landingSlotId + 2 then
		-- 	-- 		modules[landingSlotId + 3] = nil
		-- 	-- 	elseif change.slotId == landingSlotId + 3 then
		-- 	-- 		modules[landingSlotId + 2] = nil
		-- 	-- 	end
		-- 	-- 	modules[change.slotId] = change.module
		-- 	-- else
		-- 	-- 	modules[change.slotId] = nil
		-- 	-- end
		-- 	return modules
        -- end,
        upgradeFn = function(args, one)
            -- LOLLO TODO allow upgrading tracks.
            -- this sample is from the modular station, which puts edges in modules.
            -- I don't coz they are curved, so see what I can do.
			print('LOLLO upgradeFn starting, args =') debugPrint(args)
			print('one = ') debugPrint(one)
            local modules = {}

            local SwapModule = function(slotId, from, to)
                if args.modules[slotId] and args.modules[slotId].name == from then
                    table.insert(modules, {slotId, to})
                    return true
                end
                return false
            end
            local SwapRow = function(slotId, from, to)
                local slotId2 = slotId
                while SwapModule(slotId2, from, to) do 
                    slotId2 = slotId2 + 10
                end
                slotId2 = slotId
                while SwapModule(slotId2, from, to) do 
                    slotId2 = slotId2 - 10
                end
            end

            if args.modules[args.slotId] == nil then return {} end

            if args.catenaryToggle == 1 then 
                SwapRow(args.slotId, "station/rail/modular_station/platform_high_speed_track.module",
                    "station/rail/modular_station/platform_high_speed_track_catenary.module")
                SwapRow(args.slotId, "station/rail/modular_station/platform_track.module",
                    "station/rail/modular_station/platform_track_catenary.module")
                SwapRow(args.slotId, "station/rail/modular_station/platform_high_speed_track_catenary.module", 
                    "station/rail/modular_station/platform_high_speed_track.module")
                SwapRow(args.slotId, "station/rail/modular_station/platform_track_catenary.module", 
                    "station/rail/modular_station/platform_track.module")
            end
            if args.trackTypeToggle == 1 then 
                SwapRow(args.slotId, "station/rail/modular_station/platform_high_speed_track.module",
                    "station/rail/modular_station/platform_track.module")
                SwapRow(args.slotId, "station/rail/modular_station/platform_track.module",
                    "station/rail/modular_station/platform_high_speed_track.module")
                SwapRow(args.slotId, "station/rail/modular_station/platform_high_speed_track_catenary.module",
                    "station/rail/modular_station/platform_track_catenary.module")
                SwapRow(args.slotId, "station/rail/modular_station/platform_track_catenary.module",
                    "station/rail/modular_station/platform_high_speed_track_catenary.module")
            end

            return modules
        end,
	}
end