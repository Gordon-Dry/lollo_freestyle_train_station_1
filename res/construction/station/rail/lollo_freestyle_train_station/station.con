local _constants = require('lollo_freestyle_train_station.constants')
local arrayUtils = require('lollo_freestyle_train_station.arrayUtils')
local edgeUtils = require('lollo_freestyle_train_station.edgeUtils')
local moduleHelpers = require('lollo_freestyle_train_station.moduleHelpers')
local slotHelpers = require('lollo_freestyle_train_station.slotHelpers')
local stringUtils = require('lollo_freestyle_train_station.stringUtils')
local transfUtilsUG = require 'transf'
local transfUtils = require('lollo_freestyle_train_station.transfUtils')
local vec3 = require 'vec3'

-- LOLLO NOTE
-- Instead of different cargo platforms with different widths, we could only use 5m areas for all,
-- and add new modules for extra space, parallel to the platform-tracks.
-- However, it is easier to place more platform-tracks upfront than add modules later,
-- so we go this way.

-- LOLLO NOTE we need skipCollision = true in the construction
-- coz we don't want to check crazy stuff on a non-grid pattern.
-- However, it can be trouble.
-- Perhaps you bury the modules into the ground, like with the lorry station?
-- If I crop the platform tracks outside the station, there are no more collisions!
-- If I replace the track definition of my platform-track with the stock track, the problem still occurs.
-- If I add the edgeLists in terminateConstructionHook, it does not help.
-- The trick was to carefully avoid anything even grazing on the neighbour edge. Even a collision-free model with a path can make trouble.

-- LOLLO NOTE we add a "subways" indexed table with the same indexes as params.modules, to hold extra information
-- that is, the transf. If a module is deleted in the game, its matching subways[] entry may be still around.
-- As soon as a new subway is built, its subways[] will be updated.
-- So, when querying params.subways[slotId], make sure that params.modules[slotId] also exists.

function data()
	return {
		type = 'RAIL_STATION',
		description = {
			name = _("LolloFreestyleTrainStationName"),
			description = _("LolloFreestyleTrainStationDesc"),
		},
		availability = {
			yearFrom = -1, -- 1925, -- -1,
			yearTo = -1, -- -1, -- 0
		},
		order = 5005,
		soundConfig = {
			soundSet = { name = "station_cargo_old" }
		},
		autoRemovable = false,
		-- skipCollision = true, -- see the notes
		params = { -- keep it empty or it will crash coz it won't find the params, which I pass when building the construction
            -- {
            --     key = 'fileName',
            --     name = 'File Name',
            --     values = {
            --         'dummy',
            --     },
            --     defaultIndex = 0
            -- }
        },
		updateFn = function(params)
			-- print('updateFn starting, params =') debugPrint(params)
			print('updateFn starting, params.modules =') debugPrint(params.modules)
			if not params.modules then params.modules = {} end

			-- LOLLO NOTE I cannot call the api from here, sigh. api is there, but api.res is NIL. Also game is there, but game.interface is NIL
			local result = {
				colliders = {},
				-- coord2terminalInfo = {},
                cost = 1000,
                demangleId = slotHelpers.demangleId,
                edgeLists = {},
				groundFaces = {},
				labelText = {},
                mangleId = slotHelpers.mangleId,
				models = {
					-- {
					-- 	id = 'lollo_freestyle_train_station/icon/blue.mdl',
					-- 	tag = 'stationTag',
                    --     transf = {1, 0, 0, 0,
                    --         0, 1, 0, 0,
                    --         0, 0, 1, 0,
                    --         0, 0, 0, 1},
					-- },
                },
                slotConfig = {
					-- [_constants.flatStairsModuleType] = {
					-- 	maxModules = -1,
					-- 	message = nil, --'LOLLO slotConfig message',
					-- 	skipCollisionCheck = true,
					-- },
					-- [_constants.flatCargoArea5x5ModuleType] = {
					-- 	maxModules = -1,
					-- 	message = nil, --'LOLLO slotConfig message',
					-- 	skipCollisionCheck = true,
					-- },
					-- [_constants.flatPassengerArea5x5ModuleType] = {
					-- 	maxModules = -1,
					-- 	message = nil, --'LOLLO slotConfig message',
					-- 	skipCollisionCheck = true,
					-- },
					-- [_constants.flatCargoArea10x5ModuleType] = {
					-- 	maxModules = -1,
					-- 	message = nil, --'LOLLO slotConfig message',
					-- 	skipCollisionCheck = true,
					-- },
					-- [_constants.flatPassengerArea10x5ModuleType] = {
					-- 	maxModules = -1,
					-- 	message = nil, --'LOLLO slotConfig message',
					-- 	skipCollisionCheck = true,
					-- },
					-- [_constants.flatCargoArea10x10ModuleType] = {
					-- 	maxModules = -1,
					-- 	message = nil, --'LOLLO slotConfig message',
					-- 	skipCollisionCheck = true,
					-- },
					-- [_constants.flatPassengerArea10x10ModuleType] = {
					-- 	maxModules = -1,
					-- 	message = nil, --'LOLLO slotConfig message',
					-- 	skipCollisionCheck = true,
					-- },
					-- LOLLO NOTE these guys skip the collision check between the spacing rectangle
					-- of the module being placed and the spacing rectangles of the already built modules.
					-- it also skips the collision check between the spacing rectangle
					-- of the module being placed and the objects outside the construction (the slot does not turn red while proposing a placement).
					[_constants.slopedCargoArea1x5ModuleType] = {
						maxModules = -1,
						message = nil, --'LOLLO slotConfig message',
						skipCollisionCheck = true,
					},
					[_constants.slopedPassengerArea1x5ModuleType] = {
						maxModules = -1,
						message = nil, --'LOLLO slotConfig message',
						skipCollisionCheck = true,
					},
					[_constants.slopedCargoArea1x10ModuleType] = {
						maxModules = -1,
						message = nil, --'LOLLO slotConfig message',
						skipCollisionCheck = true,
					},
					[_constants.slopedPassengerArea1x10ModuleType] = {
						maxModules = -1,
						message = nil, --'LOLLO slotConfig message',
						skipCollisionCheck = true,
					},
					[_constants.slopedCargoArea1x20ModuleType] = {
						maxModules = -1,
						message = nil, --'LOLLO slotConfig message',
						skipCollisionCheck = true,
					},
					[_constants.slopedPassengerArea1x20ModuleType] = {
						maxModules = -1,
						message = nil, --'LOLLO slotConfig message',
						skipCollisionCheck = true,
					},
					-- [_constants.cargoTerminalModuleType] = {
					-- 	maxModules = -1,
					-- 	message = nil, --'LOLLO slotConfig message',
					-- 	skipCollisionCheck = true,
					-- },
					-- [_constants.passengerTerminalModuleType] = {
					-- 	maxModules = -1,
					-- 	message = nil, --'LOLLO slotConfig message',
					-- 	skipCollisionCheck = true,
					-- },
					-- [_constants.underpassModuleType] = {
					-- 	maxModules = -1,
					-- 	message = nil, --'LOLLO slotConfig message',
					-- 	skipCollisionCheck = true,
					-- }
				},
                slots = {},
				stations = {},
				terminalGroups = {},
				terrainAlignmentLists = { { -- LOLLO NOTE this thing with the empty faces is required , otherwise the game will make its own alignments, with spikes and all on bridges or tunnels.
					type = "EQUAL",
					faces =  { }
				} },
			}

			local occupiedInfo = {
				crossConnectorsWithFlatAreas = { },
				crossConnectorsWithSlopedAreas = { },
			}
			local _getOccupiedInfo4FlatAreas = function(t, i)
				if occupiedInfo.crossConnectorsWithFlatAreas[t] == nil or occupiedInfo.crossConnectorsWithFlatAreas[t][i] == nil then
					return nil
				else
					return occupiedInfo.crossConnectorsWithFlatAreas[t][i]
				end
			end
			local _setOccupiedInfo4FlatAreas = function(t, i, newId)
				if occupiedInfo.crossConnectorsWithFlatAreas[t] == nil then
					occupiedInfo.crossConnectorsWithFlatAreas[t] = {}
				end
				occupiedInfo.crossConnectorsWithFlatAreas[t][i] = newId
			end
			local _getOccupiedInfo4SlopedAreas = function(t, i)
				if occupiedInfo.crossConnectorsWithSlopedAreas[t] == nil or occupiedInfo.crossConnectorsWithSlopedAreas[t][i] == nil then
					return { id = nil, yShift = 0 }
				else
					-- print('get occupiedInfo.crossConnectorsWithSlopedAreas[t][i] =') debugPrint(occupiedInfo.crossConnectorsWithSlopedAreas[t][i])
					return occupiedInfo.crossConnectorsWithSlopedAreas[t][i]
				end
			end
			local _setOccupiedInfo4SlopedAreas = function(t, i, newId, yShift)
				if occupiedInfo.crossConnectorsWithSlopedAreas[t] == nil then
					occupiedInfo.crossConnectorsWithSlopedAreas[t] = {}
				end
				-- print('set occupiedInfo.crossConnectorsWithSlopedAreas[t][i] =') debugPrint(occupiedInfo.crossConnectorsWithSlopedAreas[t][i])
				occupiedInfo.crossConnectorsWithSlopedAreas[t][i] = { id = newId, yShift = yShift or 0 }
			end
			local _occupySlopedAreas = function(t, i, slotId, slotTypeId, yShift)
				if params.modules[slotId] ~= nil then
					_setOccupiedInfo4SlopedAreas(t, i-1, slotTypeId, yShift)
					_setOccupiedInfo4SlopedAreas(t, i, slotTypeId, yShift)
					if i+1 <= #params.terminals[t].centrePlatforms then _setOccupiedInfo4SlopedAreas(t, i+1, slotTypeId, yShift) end
					if i+2 <= #params.terminals[t].centrePlatforms then _setOccupiedInfo4SlopedAreas(t, i+2, slotTypeId, yShift) end
				end
			end

			result.terminateConstructionHookInfo = {
				crossConnectorPositions = {},
				isAnyCargoTerminal = false,
				isAnyPassengerTerminal = false,
				stairs2SubwayPositions = {},
				underpassPositions = {},
				underpassPositionsOnBridge = {},
				vehicleNodes = {}
			}

			-- LOLLO NOTE the coordinates in terminals are absolute
			-- local mainTransf = params.mainTransf
			local inverseMainTransf = transfUtils.getInverseTransf(params.mainTransf)
			-- print('inverseMainTransf =') debugPrint(inverseMainTransf)

			for t = 1, #params.terminals do
				-- this is only a test to see if the transformation was ok. They match beautifully! Use this when talking to UG.
				-- if #result.edgeLists > 0 then
				-- 	local firstPosTanX2 = result.edgeLists[1].edges
				-- 	print('firstPosTanX2 =') debugPrint(firstPosTanX2)
				-- 	local retransformedFirstEdge = transfUtils.getPosTanX2Transformed(firstPosTanX2, params.myTransf)
				-- 	print('retransformed first edge =') debugPrint(retransformedFirstEdge)
				-- end
				local _laneZ = _constants.platformHeight -- we could also make it vary for each terminal:
				-- everything except the platforms and the terminal deco will vary along with it.

				local isCargoTerminal = params.terminals[t].isCargo
				if isCargoTerminal then result.terminateConstructionHookInfo.isAnyCargoTerminal = true else result.terminateConstructionHookInfo.isAnyPassengerTerminal = true end

				local isTrackOnPlatformLeft = params.terminals[t].isTrackOnPlatformLeft

				-- LOLLO NOTE I can use a platform-track or dedicated models for the platform.
				-- The former is simpler, the latter requires adding an invisible track so the platform fits in bridges or tunnels.
				-- The former is a bit glitchy, the latter is prettier.
				local function _addPlatform()
					if isCargoTerminal then
						for ii = 1, #params.terminals[t].centrePlatformsFine, 1 do
							local cpf = params.terminals[t].centrePlatformsFine[ii]
							local posTanX2 = transfUtils.getPosTanX2Transformed(cpf.posTanX2, inverseMainTransf)
							local myTransf = moduleHelpers.getPlatformObjectTransf_WithYRotation(posTanX2)
							local myModelId = nil
							if cpf.width < 10 then
								myModelId = 'lollo_freestyle_train_station/railroad/track/era_c_cargo_platform_1m_base_5m_wide.mdl'
							elseif cpf.width < 20 then
								myModelId = 'lollo_freestyle_train_station/railroad/track/era_c_cargo_platform_1m_base_10m_wide.mdl'
							else
								myModelId = 'lollo_freestyle_train_station/railroad/track/era_c_cargo_platform_1m_base_20m_wide.mdl'
							end
							result.models[#result.models+1] = {
								id = myModelId,
								transf = myTransf
							}
						end
					else
						for ii = 1, #params.terminals[t].centrePlatformsFine, #params.terminals[t].centrePlatformsFine - 1 do
							local cpf = params.terminals[t].centrePlatformsFine[ii]
							local posTanX2 = transfUtils.getPosTanX2Transformed(cpf.posTanX2, inverseMainTransf)
							local myTransf = moduleHelpers.getPlatformObjectTransf_WithYRotation(posTanX2)
							if cpf.width < 5 then
								result.models[#result.models+1] = {
									id = 'lollo_freestyle_train_station/railroad/track/era_c_passenger_platform_1m_base_2_5m_wide.mdl',
									transf = myTransf
								}
							else
								result.models[#result.models+1] = {
									id = 'lollo_freestyle_train_station/railroad/track/era_c_passenger_platform_1m_base_5m_wide.mdl',								-- tag = slotHelpers.mangleModelTag(t, false),
									transf = myTransf
								}
							end
						end

						for ii = 2, #params.terminals[t].centrePlatformsFine - 1 do
							local cpf = params.terminals[t].centrePlatformsFine[ii]
							local posTanX2 = transfUtils.getPosTanX2Transformed(cpf.posTanX2, inverseMainTransf)
							local myTransf = moduleHelpers.getPlatformObjectTransf_WithYRotation(posTanX2)
							if cpf.width < 5 then
								result.models[#result.models+1] = {
									id = isTrackOnPlatformLeft
										and 'lollo_freestyle_train_station/railroad/platform/era_c_passenger_platform_1m_base_3_1m_wide_stripe_left.mdl'
										or 'lollo_freestyle_train_station/railroad/platform/era_c_passenger_platform_1m_base_3_1m_wide_stripe_right.mdl',
									transf = myTransf
								}
							elseif cpf.width < 10 then
								result.models[#result.models+1] = {
									id = isTrackOnPlatformLeft
										and 'lollo_freestyle_train_station/railroad/platform/era_c_passenger_platform_1m_base_5_6m_wide_stripe_left.mdl'
										or 'lollo_freestyle_train_station/railroad/platform/era_c_passenger_platform_1m_base_5_6m_wide_stripe_right.mdl',
									transf = myTransf
								}
							end
						end
					end
				end
				_addPlatform()

				local function _addOutsideExtensions()
					for i = 2, #params.terminals[t].centrePlatforms, 3 do
						if params.terminals[t].centrePlatforms[i].type ~= 2 then -- only on ground and bridges
							local cpl = params.terminals[t].centrePlatforms[i]
							local posTanX2 = transfUtils.getPosTanX2Transformed(cpl.posTanX2, inverseMainTransf)

							if not(_getOccupiedInfo4SlopedAreas(t, i).id) or _getOccupiedInfo4SlopedAreas(t, i).id == _constants.idBases.slopedArea1x5SlotId then
								local yShiftOutside, yShiftOutside4StreetAccess = moduleHelpers.getYShift4SlopedArea(params, t, i, 5)
								local myId = result.mangleId(t, i, _constants.idBases.slopedArea1x5SlotId)
								table.insert(result.slots, {
									-- height = 0,
									id = myId,
									-- spacing = isTrackOnPlatformLeft and {4.5, 0, 8, 8} or {0, 4.5, 8, 8},
									spacing = isTrackOnPlatformLeft and {2, 0, 7, 7} or {0, 2, 7, 7},
									transf = transfUtilsUG.mul(
										moduleHelpers.getPlatformObjectTransf_WithYRotation(posTanX2),
										{ 0, 1, 0, 0,  -1, 0, 0, 0,  0, 0, 1, 0,  0, yShiftOutside, _constants.platformSideBitsZ, 1 }
									),
									type = isCargoTerminal and _constants.slopedCargoArea1x5ModuleType or _constants.slopedPassengerArea1x5ModuleType,
								})
								_occupySlopedAreas(t, i, myId, _constants.idBases.slopedArea1x5SlotId, yShiftOutside4StreetAccess)
							end

							if params.terminals[t].centrePlatforms[i].type == 0 then -- only on ground
								if not(_getOccupiedInfo4SlopedAreas(t, i).id) or _getOccupiedInfo4SlopedAreas(t, i).id == _constants.idBases.slopedArea1x10SlotId then
									local yShiftOutside, yShiftOutside4StreetAccess = moduleHelpers.getYShift4SlopedArea(params, t, i, 10)
									local myId = result.mangleId(t, i, _constants.idBases.slopedArea1x10SlotId)
									table.insert(result.slots, {
										-- height = 0,
										id = myId,
										-- spacing = isTrackOnPlatformLeft and {7, 2, 8, 8} or {2, 7, 8, 8},
										spacing = isTrackOnPlatformLeft and {3, 2, 7, 7} or {2, 3, 7, 7},
										transf = transfUtilsUG.mul(
											moduleHelpers.getPlatformObjectTransf_WithYRotation(posTanX2),
											{ 0, 1, 0, 0,  -1, 0, 0, 0,  0, 0, 1, 0,  0, yShiftOutside, _constants.platformSideBitsZ, 1 }
										),
										type = isCargoTerminal and _constants.slopedCargoArea1x10ModuleType or _constants.slopedPassengerArea1x10ModuleType,
									})
									_occupySlopedAreas(t, i, myId, _constants.idBases.slopedArea1x10SlotId, yShiftOutside4StreetAccess)
								end

								if not(_getOccupiedInfo4SlopedAreas(t, i).id) or _getOccupiedInfo4SlopedAreas(t, i).id == _constants.idBases.slopedArea1x20SlotId then
									local yShiftOutside, yShiftOutside4StreetAccess = moduleHelpers.getYShift4SlopedArea(params, t, i, 20)
									local myId = result.mangleId(t, i, _constants.idBases.slopedArea1x20SlotId)
									table.insert(result.slots, {
										-- height = 0,
										id = myId,
										-- spacing = isTrackOnPlatformLeft and {12, 4, 8, 8} or {4, 12, 8, 8},
										spacing = isTrackOnPlatformLeft and {8, 4, 7, 7} or {4, 8, 7, 7},
										transf = transfUtilsUG.mul(
											moduleHelpers.getPlatformObjectTransf_WithYRotation(posTanX2),
											{ 0, 1, 0, 0,  -1, 0, 0, 0,  0, 0, 1, 0,  0, yShiftOutside, _constants.platformSideBitsZ, 1 }
										),
										type = isCargoTerminal and _constants.slopedCargoArea1x20ModuleType or _constants.slopedPassengerArea1x20ModuleType,
									})
									_occupySlopedAreas(t, i, myId, _constants.idBases.slopedArea1x20SlotId, yShiftOutside4StreetAccess)
								end
							end
						end
					end
				end
				_addOutsideExtensions()

				local function _addStreetAccess()
					for i = 2, #params.terminals[t].centrePlatforms do -- cross connectors, which are nodes, are 1 more then centre platforms, which are edges, so I go on until the end
						if params.terminals[t].centrePlatforms[i].type ~= 2 then -- no tunnels
							local isUnderpass = params.modules[result.mangleId(t, i, _constants.idBases.underpassSlotId)] ~= nil
							local isPreviousUnderpass = i > 1
								and params.modules[result.mangleId(t, i-1, _constants.idBases.underpassSlotId)] ~= nil
								or false
							local crossConnectorPosTanX2 = transfUtils.getPosTanX2Transformed(params.terminals[t].crossConnectors[i].posTanX2, inverseMainTransf)
							if not(isUnderpass) and not(isPreviousUnderpass) then
								if params.terminals[t].centrePlatforms[i].type == 0 then -- ground
									if not(_getOccupiedInfo4FlatAreas(t, i))
									or _getOccupiedInfo4FlatAreas(t, i) == _constants.idBases.flatStairsSlotId then
										local yShift = params.terminals[t].centrePlatforms[i].width + _getOccupiedInfo4SlopedAreas(t, i).yShift
										local myPosTanX2 = transfUtils.getExtrapolatedPosTanX2Continuation(crossConnectorPosTanX2, yShift)
										local myTransf = transfUtilsUG.mul(
											moduleHelpers.getPlatformObjectTransf_AlwaysVertical(myPosTanX2),
											{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ + _constants.platformSideBitsZ, 1 }
										)
										local myId = result.mangleId(t, i, _constants.idBases.flatStairsSlotId)
										table.insert(result.slots, {
											-- height = 0,
											id = myId,
											spacing = {-2, 6, 1, 1},
											transf = myTransf,
											type = _constants.flatStairsModuleType,
										})
										if params.modules[myId] ~= nil then
											local lane2AreaTransf = transfUtils.get1MLaneTransf(
												{
													myPosTanX2[1][1][1],
													myPosTanX2[1][1][2],
													myPosTanX2[1][1][3] + _laneZ,
												},
												transfUtils.transf2Position(myTransf)
											)
											result.models[#result.models+1] = {
												id = _constants.passengerLaneModelId,
												transf = lane2AreaTransf
											}
											_setOccupiedInfo4FlatAreas(t, i, _constants.idBases.flatStairsSlotId)
										end
									end
									if not(_getOccupiedInfo4FlatAreas(t, i))
									or _getOccupiedInfo4FlatAreas(t, i) == _constants.idBases.flatArea5x5SlotId then
										local yShift = params.terminals[t].centrePlatforms[i].width + 5 + _getOccupiedInfo4SlopedAreas(t, i).yShift
										local myPosTanX2 = transfUtils.getExtrapolatedPosTanX2Continuation(crossConnectorPosTanX2, yShift)
										local myTransf = transfUtilsUG.mul(
											moduleHelpers.getPlatformObjectTransf_AlwaysVertical(myPosTanX2),
											{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ + _constants.platformSideBitsZ, 1 }
										)
										local myId = result.mangleId(t, i, _constants.idBases.flatArea5x5SlotId)
										table.insert(result.slots, {
											-- height = 0,
											id = myId,
											spacing = {0, 6, 2, 2},
											transf = myTransf,
											type = isCargoTerminal and _constants.flatCargoArea5x5ModuleType or _constants.flatPassengerArea5x5ModuleType,
										})
										if params.modules[myId] ~= nil then
											local lane2AreaTransf = transfUtils.get1MLaneTransf(
												{
													myPosTanX2[1][1][1],
													myPosTanX2[1][1][2],
													myPosTanX2[1][1][3] + _laneZ,
												},
												transfUtils.transf2Position(myTransf)
											)
											result.models[#result.models+1] = {
												id = _constants.passengerLaneModelId,
												transf = lane2AreaTransf
											}
											_setOccupiedInfo4FlatAreas(t, i, _constants.idBases.flatArea5x5SlotId)
										end
									end
									if not(_getOccupiedInfo4FlatAreas(t, i))
									or _getOccupiedInfo4FlatAreas(t, i) == _constants.idBases.flatArea10x5SlotId then
										local yShift = params.terminals[t].centrePlatforms[i].width + 5 + _getOccupiedInfo4SlopedAreas(t, i).yShift
										local myPosTanX2 = transfUtils.getExtrapolatedPosTanX2Continuation(crossConnectorPosTanX2, yShift)
										local myTransf = transfUtilsUG.mul(
											moduleHelpers.getPlatformObjectTransf_AlwaysVertical(myPosTanX2),
											{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ + _constants.platformSideBitsZ, 1 }
										)
										local myId = result.mangleId(t, i, _constants.idBases.flatArea10x5SlotId)
										table.insert(result.slots, {
											-- height = 0,
											id = myId,
											spacing = {0, 6, 3, 3},
											transf = myTransf,
											type = isCargoTerminal and _constants.flatCargoArea10x5ModuleType or _constants.flatPassengerArea10x5ModuleType,
										})
										if not(isUnderpass) and not(isPreviousUnderpass) and params.modules[myId] ~= nil then
											local lane2AreaTransf = transfUtils.get1MLaneTransf(
												{
													myPosTanX2[1][1][1],
													myPosTanX2[1][1][2],
													myPosTanX2[1][1][3] + _laneZ,
												},
												transfUtils.transf2Position(myTransf)
											)
											result.models[#result.models+1] = {
												id = _constants.passengerLaneModelId,
												-- tag = slotHelpers.mangleModelTag(t, false),
												transf = lane2AreaTransf
											}
											_setOccupiedInfo4FlatAreas(t, i, _constants.idBases.flatArea10x5SlotId)
										end
									end
									if not(_getOccupiedInfo4FlatAreas(t, i))
									or _getOccupiedInfo4FlatAreas(t, i) == _constants.idBases.flatArea10x10SlotId then
										local yShift = params.terminals[t].centrePlatforms[i].width + 10 + _getOccupiedInfo4SlopedAreas(t, i).yShift
										local myPosTanX2 = transfUtils.getExtrapolatedPosTanX2Continuation(crossConnectorPosTanX2, yShift)
										local myTransf = transfUtilsUG.mul(
											moduleHelpers.getPlatformObjectTransf_AlwaysVertical(myPosTanX2),
											{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ + _constants.platformSideBitsZ, 1 }
										)
										local myId = result.mangleId(t, i, _constants.idBases.flatArea10x10SlotId)
										table.insert(result.slots, {
											-- height = 0,
											id = myId,
											spacing = {0, 6, 3, 3},
											transf = myTransf,
											type = isCargoTerminal and _constants.flatCargoArea10x10ModuleType or _constants.flatPassengerArea10x10ModuleType,
										})
										if not(isUnderpass) and not(isPreviousUnderpass) and params.modules[myId] ~= nil then
											local lane2AreaTransf = transfUtils.get1MLaneTransf(
												{
													myPosTanX2[1][1][1],
													myPosTanX2[1][1][2],
													myPosTanX2[1][1][3] + _laneZ,
												},
												transfUtils.transf2Position(myTransf)
											)
											result.models[#result.models+1] = {
												id = _constants.passengerLaneModelId,
												-- tag = slotHelpers.mangleModelTag(t, false),
												transf = lane2AreaTransf
											}
											_setOccupiedInfo4FlatAreas(t, i, _constants.idBases.flatArea10x10SlotId)
										end
									end
									if not(isCargoTerminal) then
										if not(_getOccupiedInfo4FlatAreas(t, i))
										or _getOccupiedInfo4FlatAreas(t, i) == _constants.idBases.flatStation0MSlotId then
											local yShift = params.terminals[t].centrePlatforms[i].width + _getOccupiedInfo4SlopedAreas(t, i).yShift
											local myPosTanX2 = transfUtils.getExtrapolatedPosTanX2Continuation(crossConnectorPosTanX2, yShift)
											local myTransf = transfUtilsUG.mul(
												moduleHelpers.getPlatformObjectTransf_AlwaysVertical(myPosTanX2),
												{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ + _constants.platformSideBitsZ, 1 }
											)
											local myId = result.mangleId(t, i, _constants.idBases.flatStation0MSlotId)
											table.insert(result.slots, {
												-- height = 0,
												id = myId,
												spacing = {-2, 4, 4, 4},
												transf = myTransf,
												type = _constants.flatPassengerStation0MModuleType,
											})
											if params.modules[myId] ~= nil then
												local lane2AreaTransf = transfUtils.get1MLaneTransf(
													{
														myPosTanX2[1][1][1],
														myPosTanX2[1][1][2],
														myPosTanX2[1][1][3] + _laneZ,
													},
													transfUtils.transf2Position(myTransf)
												)
												result.models[#result.models+1] = {
													id = _constants.passengerLaneModelId,
													-- tag = slotHelpers.mangleModelTag(t, false),
													transf = lane2AreaTransf
												}
												_setOccupiedInfo4FlatAreas(t, i, _constants.idBases.flatStation0MSlotId)

												local ssOuterPosTanX2 = transfUtils.getExtrapolatedPosTanX2Continuation(crossConnectorPosTanX2, yShift + 9.5)
												table.insert(result.slots, {
													-- height = 0,
													id = result.mangleId(t, i, _constants.idBases.stationSquareOuterSlotId),
													shape = 1,
													spacing = {-1, 4, 4, 4},
													transf = transfUtilsUG.mul(
														moduleHelpers.getPlatformObjectTransf_AlwaysVertical(ssOuterPosTanX2),
														{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, 5 + _laneZ + _constants.platformSideBitsZ - _constants.stairsHeight, 1 }
													),
													type = _constants.passengerStationSquareModuleType,
												})
											end
										end
										if not(_getOccupiedInfo4FlatAreas(t, i))
										or _getOccupiedInfo4FlatAreas(t, i) == _constants.idBases.flatStation5MSlotId then
											local yShift = params.terminals[t].centrePlatforms[i].width + _getOccupiedInfo4SlopedAreas(t, i).yShift
											local myPosTanX2 = transfUtils.getExtrapolatedPosTanX2Continuation(crossConnectorPosTanX2, yShift)
											local myTransf = transfUtilsUG.mul(
												moduleHelpers.getPlatformObjectTransf_AlwaysVertical(myPosTanX2),
												{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1 }
											)
											local myId = result.mangleId(t, i, _constants.idBases.flatStation5MSlotId)
											table.insert(result.slots, {
												-- height = 0,
												id = myId,
												spacing = {-2, 4, 4, 4},
												transf = myTransf,
												type = _constants.flatPassengerStation5MModuleType,
											})
											if params.modules[myId] ~= nil then
												local lane2AreaTransf = transfUtils.get1MLaneTransf(
													{
														myPosTanX2[1][1][1],
														myPosTanX2[1][1][2],
														myPosTanX2[1][1][3] + _laneZ,
													},
													transfUtils.transf2Position(myTransf)
												)
												result.models[#result.models+1] = {
													id = _constants.passengerLaneModelId,
													-- tag = slotHelpers.mangleModelTag(t, false),
													transf = lane2AreaTransf
												}
												_setOccupiedInfo4FlatAreas(t, i, _constants.idBases.flatStation5MSlotId)

												local ssOuterPosTanX2 = transfUtils.getExtrapolatedPosTanX2Continuation(crossConnectorPosTanX2, yShift + 9.5)
												table.insert(result.slots, {
													-- height = 0,
													id = result.mangleId(t, i, _constants.idBases.stationSquareOuterSlotId),
													shape = 1,
													spacing = {-1, 4, 4, 4},
													transf = transfUtilsUG.mul(
														moduleHelpers.getPlatformObjectTransf_AlwaysVertical(ssOuterPosTanX2),
														{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1 }
													),
													type = _constants.passengerStationSquareModuleType,
												})
											end
										end
									end
								elseif params.terminals[t].centrePlatforms[i].type == 1 then -- bridge
									if not(isCargoTerminal) then
										if not(_getOccupiedInfo4FlatAreas(t, i))
										or _getOccupiedInfo4FlatAreas(t, i) == _constants.idBases.sideLiftSlotId then
											local yShift = params.terminals[t].centrePlatforms[i].width + _getOccupiedInfo4SlopedAreas(t, i).yShift
											local myPosTanX2 = transfUtils.getExtrapolatedPosTanX2Continuation(crossConnectorPosTanX2, yShift)
											local myTransf = transfUtilsUG.mul(
												moduleHelpers.getPlatformObjectTransf_AlwaysVertical(myPosTanX2),
												{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1 }
											)
											local myId = result.mangleId(t, i, _constants.idBases.sideLiftSlotId)
											table.insert(result.slots, {
												-- height = 0,
												id = myId,
												spacing = {-2, 4, 4, 4},
												transf = myTransf,
												type = _constants.passengerSideLiftModuleType,
											})
											if params.modules[myId] ~= nil then
												local lane2AreaTransf = transfUtils.get1MLaneTransf(
													{
														myPosTanX2[1][1][1],
														myPosTanX2[1][1][2],
														myPosTanX2[1][1][3] + _laneZ,
													},
													transfUtils.transf2Position(myTransf)
												)
												result.models[#result.models+1] = {
													id = _constants.passengerLaneModelId,
													-- tag = slotHelpers.mangleModelTag(t, false),
													transf = lane2AreaTransf
												}
												_setOccupiedInfo4FlatAreas(t, i, _constants.idBases.sideLiftSlotId)

												local ssOuterPosTanX2 = transfUtils.getExtrapolatedPosTanX2Continuation(crossConnectorPosTanX2, yShift + 9.5)
												table.insert(result.slots, {
													-- height = 0,
													id = result.mangleId(t, i, _constants.idBases.stationSquareOuterSlotId),
													shape = 1,
													spacing = {-1, 4, 4, 4},
													transf = transfUtilsUG.mul(
														moduleHelpers.getPlatformObjectTransf_AlwaysVertical(ssOuterPosTanX2),
														{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1 }
													),
													type = _constants.passengerStationSquareModuleType,
												})
												local ssInnerPosTanX2 = transfUtils.getExtrapolatedPosTanX2Continuation(crossConnectorPosTanX2, yShift - 1.5)
												table.insert(result.slots, {
													-- height = 0,
													id = result.mangleId(t, i, _constants.idBases.stationSquareInnerSlotId),
													shape = 1,
													spacing = {-1, 4, 4, 4},
													transf = transfUtilsUG.mul(
														moduleHelpers.getPlatformObjectTransf_AlwaysVertical(ssInnerPosTanX2),
														{ -1, 0, 0, 0,  0, -1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1 }
													),
													type = _constants.passengerStationSquareModuleType,
												})
											end
										end
										if not(_getOccupiedInfo4FlatAreas(t, i))
										or _getOccupiedInfo4FlatAreas(t, i) == _constants.idBases.platformLiftSlotId then
											local myPosTanX2 = transfUtils.getPosTanX2Transformed(params.terminals[t].centrePlatforms[i].posTanX2, inverseMainTransf)
											local myTransf = transfUtilsUG.mul(
												moduleHelpers.getPlatformObjectTransf_AlwaysVertical(myPosTanX2),
												{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1 }
											)
											local myId = result.mangleId(t, i, _constants.idBases.platformLiftSlotId)
											table.insert(result.slots, {
												-- height = 0,
												id = myId,
												spacing = {4, 4, 2, 2},
												transf = myTransf,
												type = _constants.passengerPlatformLiftModuleType,
											})
											if params.modules[myId] ~= nil then
												local ssOuterPosTanX2 = transfUtils.getParallelSideways(myPosTanX2, 3.4)
												table.insert(result.slots, {
													-- height = 0,
													id = result.mangleId(t, i, _constants.idBases.stationSquareOuterSlotId),
													shape = 1,
													spacing = {-1, 4, 4, 4},
													transf = transfUtilsUG.mul(
														moduleHelpers.getPlatformObjectTransf_AlwaysVertical(ssOuterPosTanX2),
														{ 0, -1, 0, 0,  1, 0, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1 }
													),
													type = _constants.passengerStationSquareModuleType,
												})
												local ssInnerPosTanX2 = transfUtils.getParallelSideways(myPosTanX2, -2.9)
												table.insert(result.slots, {
													-- height = 0,
													id = result.mangleId(t, i, _constants.idBases.stationSquareInnerSlotId),
													shape = 1,
													spacing = {-1, 4, 4, 4},
													transf = transfUtilsUG.mul(
														moduleHelpers.getPlatformObjectTransf_AlwaysVertical(ssInnerPosTanX2),
														{ 0, 1, 0, 0,  -1, 0, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1 }
													),
													type = _constants.passengerStationSquareModuleType,
												})
											end
										end
									end
								end
							end
						end
					end
				end
				_addStreetAccess()

				local function _addLanesAcross()
					if isCargoTerminal then return end

					for i = 2, #params.terminals[t].centrePlatforms do -- cross connectors, which are nodes, are 1 more then centre platforms, which are edges, so I go on until the end
						local isUnderpass = params.modules[result.mangleId(t, i, _constants.idBases.underpassSlotId)] ~= nil
						local isPreviousUnderpass = i > 1
							and params.modules[result.mangleId(t, i-1, _constants.idBases.underpassSlotId)] ~= nil
							or false
						-- local isPlatformLift = params.modules[result.mangleId(t, i, _constants.idBases.platformLiftSlotId)] ~= nil
						-- local isPreviousPlatformLift = i > 1
						-- 	and params.modules[result.mangleId(t, i-1, _constants.idBases.platformLiftSlotId)] ~= nil
						-- 	or false

						-- if not(isUnderpass) and not(isPreviousUnderpass) and not(isPlatformLift) and not(isPreviousPlatformLift) then
						if not(isUnderpass) and not(isPreviousUnderpass) then
							local crossConnectorPosTanX2 = transfUtils.getPosTanX2Transformed(params.terminals[t].crossConnectors[i].posTanX2, inverseMainTransf)
							local crossConnectorTransf = transfUtilsUG.mul(
								transfUtils.get1MLaneTransf(crossConnectorPosTanX2[1][1], crossConnectorPosTanX2[2][1]),
								{1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1}
							)
							result.models[#result.models+1] = {
								id = _constants.passengerLaneModelId,
								-- tag = slotHelpers.mangleModelTag(t, false),
								transf = crossConnectorTransf
							}
							if result.terminateConstructionHookInfo.crossConnectorPositions[t] == nil then result.terminateConstructionHookInfo.crossConnectorPositions[t] = {} end
							table.insert(
								result.terminateConstructionHookInfo.crossConnectorPositions[t],
								{
									t = t,
									pos = {
										crossConnectorPosTanX2[2][1][1],
										crossConnectorPosTanX2[2][1][2],
										crossConnectorPosTanX2[2][1][3] + _laneZ,
									}
								}
							)
						end
					end
				end
				_addLanesAcross()

				local function _addLanesAlong()
					if isCargoTerminal then return end

					for i = 2, #params.terminals[t].centrePlatforms - 1 do -- skip the outermost edges to avoid collisions, the game is very picky here.
						local isOnBridge = params.terminals[t].centrePlatforms[i].type == 1
						local isUnderpass = params.modules[result.mangleId(t, i, _constants.idBases.underpassSlotId)] ~= nil
						local isPlatformLift = params.modules[result.mangleId(t, i, _constants.idBases.platformLiftSlotId)] ~= nil
						local isStairs2Subway = params.modules[result.mangleId(t, i, _constants.idBases.stairs2SubwaySlotId)] ~= nil

						local posTanX2 = transfUtils.getPosTanX2Transformed(params.terminals[t].centrePlatforms[i].posTanX2, inverseMainTransf)
						local centreLaneTransf = transfUtils.get1MLaneTransf(posTanX2[1][1], posTanX2[2][1])
						local myModelId = _constants.passengerLaneModelId
						if isPlatformLift then myModelId = _constants.passengerLaneLiftModelId
						elseif isUnderpass then myModelId = _constants.passengerLaneUnderpassModelId
						elseif isStairs2Subway then myModelId = _constants.passengerLaneStairs2SubwayModelId
						end
						result.models[#result.models+1] = {
							id = myModelId,
							transf = transfUtilsUG.mul(centreLaneTransf, {1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1})
						}

						if isStairs2Subway then
							local stairs2SubwayTopTransf = transfUtilsUG.mul(
								centreLaneTransf,
								{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  _constants.underpassLengthM * 0.5, 0, _laneZ + _constants.stairs2SubwayZ, 1 }
							)
							if result.terminateConstructionHookInfo.stairs2SubwayPositions[t] == nil then result.terminateConstructionHookInfo.stairs2SubwayPositions[t] = {} end
							result.terminateConstructionHookInfo.stairs2SubwayPositions[t][#result.terminateConstructionHookInfo.stairs2SubwayPositions[t]+1] = {
								t = t,
								pos1 = posTanX2[1][1],
								pos2 = posTanX2[2][1],
								pos2Link = {
									stairs2SubwayTopTransf[13],
									stairs2SubwayTopTransf[14],
									stairs2SubwayTopTransf[15]
								}
							}
						elseif isUnderpass and not(isOnBridge) then
							local underpassBottomTransf = transfUtilsUG.mul(
								centreLaneTransf,
								{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  _constants.underpassLengthM * 0.5, 0, _laneZ + _constants.underpassZ, 1 }
							)
							if result.terminateConstructionHookInfo.underpassPositions[t] == nil then result.terminateConstructionHookInfo.underpassPositions[t] = {} end
							result.terminateConstructionHookInfo.underpassPositions[t][#result.terminateConstructionHookInfo.underpassPositions[t]+1] = {
								t = t,
								pos1 = posTanX2[1][1],
								pos2 = posTanX2[2][1],
								pos2Link = {
									underpassBottomTransf[13],
									underpassBottomTransf[14],
									underpassBottomTransf[15]
								}
							}
						elseif (isUnderpass and isOnBridge) or isPlatformLift then
							local underpassBottomTransf = transfUtilsUG.mul(
								centreLaneTransf,
								{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  _constants.underpassLengthM * 0.5, 0, _laneZ + _constants.underpassZ, 1 }
							)
							if result.terminateConstructionHookInfo.underpassPositionsOnBridge[t] == nil then
								result.terminateConstructionHookInfo.underpassPositionsOnBridge[t] = {}
							end
							result.terminateConstructionHookInfo.underpassPositionsOnBridge[t][#result.terminateConstructionHookInfo.underpassPositionsOnBridge[t]+1] = {
								t = t,
								pos1 = posTanX2[1][1],
								pos2 = posTanX2[2][1],
								pos2Link = {
									underpassBottomTransf[13],
									underpassBottomTransf[14],
									underpassBottomTransf[15]
								}
							}
						end
					end
				end
				_addLanesAlong()

				local function _addWaitingAreas()
					if isCargoTerminal then
						for _, cwas in pairs(params.terminals[t].cargoWaitingAreas) do
							for i = 1, #cwas do
								local posTanX2 = transfUtils.getPosTanX2Transformed(cwas[i].posTanX2, inverseMainTransf)
								local centreLaneTransf = transfUtils.get1MLaneTransf(posTanX2[1][1], posTanX2[2][1])
								result.models[#result.models+1] = {
									id = _constants.cargoWaitingAreaModelId,
									tag = slotHelpers.mangleModelTag(t, true),
									transf = transfUtilsUG.mul(centreLaneTransf, {1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1})
								}
							end
						end
					else
						if isTrackOnPlatformLeft then
							for i = 1, #params.terminals[t].leftPlatforms do
								local posTanX2 = transfUtils.getPosTanX2Transformed(params.terminals[t].leftPlatforms[i].posTanX2, inverseMainTransf)
								local leftLaneTransf = transfUtils.get1MLaneTransf(posTanX2[1][1], posTanX2[2][1])

								result.models[#result.models+1] = {
									id = _constants.passengerWaitingAreaModelId,
									tag = slotHelpers.mangleModelTag(t, false),
									transf = transfUtilsUG.mul(leftLaneTransf, {1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1})
								}
							end
						else
							for i = 1, #params.terminals[t].rightPlatforms do
								local posTanX2 = transfUtils.getPosTanX2Transformed(params.terminals[t].rightPlatforms[i].posTanX2, inverseMainTransf)
								local rightLaneTransf = transfUtils.get1MLaneTransf(posTanX2[1][1], posTanX2[2][1])

								result.models[#result.models+1] = {
									id = _constants.passengerWaitingAreaModelId,
									tag = slotHelpers.mangleModelTag(t, false),
									transf = transfUtilsUG.mul(rightLaneTransf, {1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1})
								}
							end
						end
					end
				end
				_addWaitingAreas()

				local _addTerminalSlot = function()
					local i = params.terminals[t].midTrackIndex
					local tel = params.terminals[t].trackEdgeLists[i]
					local posTanX2 = transfUtils.getPosTanX2Transformed(tel.posTanX2, inverseMainTransf)
					local unitaryTangent = transfUtils.getPosTanX2Normalised(posTanX2)
					table.insert(result.slots, {
						-- height = 0,
						id = result.mangleId(t, 0, _constants.idBases.terminalSlotId),
						spacing = {2.5, 2.5, 1.5, 1.5},
						transf = transfUtilsUG.mul(
							moduleHelpers.getPlatformObjectTransf_WithYRotation(unitaryTangent),
							{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1 }
						),
						type = isCargoTerminal and _constants.cargoTerminalModuleType or _constants.passengerTerminalModuleType,
					})
				end
				_addTerminalSlot()

				local _addUnderpassSlots = function()
					-- add underpass slots, skipping the ends.
					if not(isCargoTerminal) then
						for i = 2, #params.terminals[t].centrePlatforms - 1, 4 do
							local posTanX2 = transfUtils.getPosTanX2Transformed(params.terminals[t].centrePlatforms[i].posTanX2, inverseMainTransf)
							local myId = result.mangleId(t, i, _constants.idBases.underpassSlotId)
							table.insert(result.slots, {
								-- height = 1,
								id = myId,
								-- shape 0 1 2 3, only graphical
								spacing = {2.5, 2.5, 1.5, 1.5},
								transf = transfUtilsUG.mul(
									moduleHelpers.getPlatformObjectTransf_AlwaysVertical(posTanX2),
									{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ + 1, 1 }
								),
								type = _constants.underpassModuleType,
							})
							if params.modules[myId] ~= nil then
								result.models[#result.models+1] = {
									id = _constants.underpassGroundModelFileName,
									transf = transfUtilsUG.mul(
										moduleHelpers.getPlatformObjectTransf_WithYRotation(posTanX2),
										{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ + 0.025, 1 }
									)
								}
							end
						end
					end
				end
				_addUnderpassSlots()

				-- LOLLO TODO if a terminal is all underground, build a default module of these to make life easier
				local _addStairs2SubwaySlots = function()
					if isCargoTerminal then return end

					for i = 2, #params.terminals[t].centrePlatforms - 1, 4 do
						if params.terminals[t].centrePlatforms[i].type == 2 then -- only in tunnels
							local posTanX2 = transfUtils.getPosTanX2Transformed(params.terminals[t].centrePlatforms[i].posTanX2, inverseMainTransf)
							table.insert(result.slots, {
								-- height = 1,
								id = result.mangleId(t, i, _constants.idBases.stairs2SubwaySlotId),
								spacing = {2.5, 2.5, 1.5, 1.5},
								transf = transfUtilsUG.mul(
									moduleHelpers.getPlatformObjectTransf_AlwaysVertical(posTanX2),
									{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1 }
								),
								type = _constants.stairs2SubwayModuleType,
							})
						end
					end
				end
				_addStairs2SubwaySlots()
			end -- loop over terminals

			local _addSubwaySlots = function()
				print('_addSubwaySlots starting, params.subways =') debugPrint(params.subways)
				if not(params.subways) then return end

				for slotId, subway in pairs(params.subways) do
					if params.modules[slotId] ~= nil then
						local extraData = params.subways[slotId]
						if extraData == nil then
							print ('ERROR: subway[', slotId, '] not found')
						else
							if extraData.transf == nil then
								print ('ERROR: subway[', slotId, '] has no transf')
							else
								table.insert(result.slots, {
									-- height = 0,
									id = slotId,
									spacing = {2.5, 2.5, 1.5, 1.5},
									transf = transfUtilsUG.mul(extraData.transf, inverseMainTransf),
									type = _constants.subwayModuleType,
								})
							end
						end
					end
				end
				print('_addSubwaySlots ending')
			end
			_addSubwaySlots()

			print('params.upgrade =') debugPrint(params.upgrade)

			result.terminateConstructionHook = function()
				print('terminateConstructionHook starting')

				-- local _getAllPositions = function()
				-- 	local results = {}
				-- 	for t = 1, #params.terminals do
				-- 		results[t] = {}
				-- 		arrayUtils.concatValues(results[t], result.terminateConstructionHookInfo.underpassPositionsOnBridge[t] or {})
				-- 		arrayUtils.concatValues(results[t], result.terminateConstructionHookInfo.underpassPositions[t] or {})
				-- 		arrayUtils.concatValues(results[t], result.terminateConstructionHookInfo.stairs2SubwayPositions[t] or {})
				-- 	end
				-- 	return results
				-- end

				local _getAllPositionsBelowPlatforms = function()
					local results = {}
					for t = 1, #params.terminals do
						results[t] = {}
						arrayUtils.concatValues(results[t], result.terminateConstructionHookInfo.underpassPositionsOnBridge[t] or {})
						arrayUtils.concatValues(results[t], result.terminateConstructionHookInfo.underpassPositions[t] or {})
					end
					return results
				end

				local _getAllPositionsUnderground = function()
					local results = {}
					for t = 1, #params.terminals do
						results[t] = {}
						arrayUtils.concatValues(results[t], result.terminateConstructionHookInfo.underpassPositions[t] or {})
						arrayUtils.concatValues(results[t], result.terminateConstructionHookInfo.stairs2SubwayPositions[t] or {})
					end
					return results
				end

				local _getDistancesBetweenPos2Links = function(positions)
					local allDistances = {}
					local minDistances = {}
					for t = 1, #params.terminals do
						local positionsInT = positions[t]
						for i = 1, #positionsInT do
							for tt = t + 1, #params.terminals do
								local positionsInTT = positions[tt]
								for ii = 1, #positionsInTT do
									if allDistances[t] == nil then allDistances[t] = {} end
									if allDistances[t][tt] == nil then allDistances[t][tt] = {} end
									if minDistances[t] == nil then minDistances[t] = {} end

                                    local distance = transfUtils.getPositionsDistance(positionsInT[i].pos2Link, positionsInTT[ii].pos2Link)
									table.insert(
										allDistances[t][tt],
										{
											t = t,
											tt = tt,
											i = i,
											ii = ii,
											distance = distance
										}
									)

									if minDistances[t][tt] == nil or minDistances[t][tt].distance > distance then
										minDistances[t][tt] = {
											t = t,
											tt = tt,
											i = i,
											ii = ii,
											distance = distance
										}
									end
								end
							end
						end
					end

                    local shortDistances = {}
                    for t = 1, #params.terminals do
                        for tt = t + 1, #params.terminals do
                            if minDistances[t] ~= nil and minDistances[t][tt] ~= nil then
                                if allDistances[t][tt].distance / minDistances[t][tt].distance < 1.11 then
                                    if shortDistances[t] == nil then shortDistances[t] = {} end
                                    shortDistances[t][tt] = allDistances[t][tt]
                                end
                            end
                        end
                    end
					return shortDistances, minDistances
					-- return minDistances
				end

				local _linkUnderpassesAndStairs = function()
					local _linkAlong = function(positions)
						for t = 1, #params.terminals do
							local positionsInTerminal = positions[t]
							if positionsInTerminal ~= nil and #positionsInTerminal > 1 then
								local previousPosition = positionsInTerminal[1]
								for i = 2, #positionsInTerminal do
									local currentPosition = positionsInTerminal[i]
									result.models[#result.models+1] = {
										id = _constants.passengerLaneModelId,
										transf = transfUtils.get1MLaneTransf(
											previousPosition.pos2Link,
											currentPosition.pos2Link
										)
									}
									previousPosition = currentPosition
								end
							end
						end
					end
					_linkAlong(result.terminateConstructionHookInfo.stairs2SubwayPositions)
					local positionsBelowPlatforms = _getAllPositionsBelowPlatforms()
					_linkAlong(positionsBelowPlatforms)

					-- link the underpasses across terminals, underground
					-- for now, I link each terminal to 1 other terminal only, the closest with an underpass.
					local allPositionsUnderground = _getAllPositionsUnderground()
					-- print('allPositionsExceptBridge =') debugPrint(allPositionsExceptBridge)
                    -- print('lalala')
                    local shortDistances, minDistances = _getDistancesBetweenPos2Links(allPositionsUnderground)
					-- local minDistances = _getDistancesBetweenPos2Links(allPositionsUnderground)
					-- print('shortDistances =') debugPrint(shortDistances)
					-- print('minDistances =') debugPrint(minDistances)

					local function _linkAcross(positions)
						for t = 1, #params.terminals do
							if positions[t] ~= nil then
								local positionsInT = positions[t]
                                local minDistance4T = nil
                                local shortDistances4T = nil
								for tt = t + 1, #params.terminals do
									if positions[tt] ~= nil then
										local positionsInTT = positions[tt]
										if minDistances[t] ~= nil and minDistances[t][tt] ~= nil then
											if minDistance4T == nil or minDistances[t][tt].distance < minDistance4T.distance then
                                                minDistance4T = minDistances[t][tt]
                                                shortDistances4T = shortDistances[t][tt]
											end
										end
									end
								end
								-- if minDistance4T ~= nil then
								-- 	result.models[#result.models+1] = {
								-- 		id = _constants.passengerLaneModelId,
								-- 		-- tag = slotHelpers.mangleModelTag(t, false),
								-- 		transf = transfUtils.get1MLaneTransf(
								-- 			positions[minDistance4T.t][minDistance4T.i].pos2Link,
								-- 			positions[minDistance4T.tt][minDistance4T.ii].pos2Link
								-- 		)
								-- 	}
                                -- end
                                -- LOLLO TODO check this
                                if shortDistances4T ~= nil then
                                    for _, value in pairs(shortDistances4T) do
                                        result.models[#result.models+1] = {
                                            id = _constants.passengerLaneModelId,
                                            transf = transfUtils.get1MLaneTransf(
                                                positions[value.t][value.i].pos2Link,
                                                positions[value.tt][value.ii].pos2Link
                                            )
                                        }
                                    end
                                end
                            end
						end
					end
					_linkAcross(allPositionsUnderground)
					_linkAcross(result.terminateConstructionHookInfo.underpassPositionsOnBridge)
				end
				_linkUnderpassesAndStairs()
				print('passengers and stairs linked')

				local _linkPassengerPlatforms = function()
					-- link the underpasses across terminals, on the ground, if they are close enough
					for t = 1, #params.terminals do
						local positionsInT = result.terminateConstructionHookInfo.crossConnectorPositions[t]
						if positionsInT ~= nil then
							for tt = t + 1, #params.terminals do
								local positionsInTT = result.terminateConstructionHookInfo.crossConnectorPositions[tt]
								if positionsInTT ~= nil then
									for i = 1, #positionsInT do
										for ii = 1, #positionsInTT do
											if transfUtils.getPositionsDistance(positionsInT[i].pos, positionsInTT[ii].pos) < 6 then
												result.models[#result.models+1] = {
													id = _constants.passengerLaneModelId,
													-- tag = slotHelpers.mangleModelTag(t, false),
													transf = transfUtils.get1MLaneTransf(
														positionsInT[i].pos,
														positionsInTT[ii].pos
													)
												}
											end
										end
									end
								end
							end
						end
					end
				end
				_linkPassengerPlatforms()
				print('passenger platforms linked')

				local _linkSubways = function()
					if not(params.subways) then return end
					local allPositionsUnderground = _getAllPositionsUnderground()
					-- print('allPositionsExceptBridge =') debugPrint(allPositionsExceptBridge)

					for slotId, subway in pairs(params.subways) do
						if subway == nil then
							print ('ERROR: subway[', slotId, '] not found')
						elseif subway.transf == nil then
							print ('ERROR: subway[', slotId, '] has no transf')
						elseif params.modules[slotId] ~= nil then
							local subwayPos2Link = transfUtils.transf2Position(transfUtilsUG.mul(subway.transf2Link, inverseMainTransf))
							for t = 1, #params.terminals do
								-- print('attempting to link terminal t =', t, 'to subway')
								local minDistance = nil
								local minDistanceI = nil
								for i = 1, #allPositionsUnderground[t] do
									local distance = transfUtils.getPositionsDistance(subwayPos2Link, allPositionsUnderground[t][i].pos2Link)
									if minDistance == nil or minDistance > distance then
										minDistance = distance
										minDistanceI = i
									end
								end

								-- print('terminal t = ', t, 'about to link to subway')
								if minDistanceI ~= nil then
									-- print('allPositionsExceptBridge[t][minDistanceI] =') debugPrint(allPositionsExceptBridge[t][minDistanceI])
									result.models[#result.models+1] = {
										id = _constants.passengerLaneModelId,
										-- tag = slotHelpers.mangleModelTag(t, false),
										transf = transfUtils.get1MLaneTransf(
											allPositionsUnderground[t][minDistanceI].pos2Link,
											subwayPos2Link
										)
									}
								end
							end
						end
					end
				end
				_linkSubways()
				print('subways linked')

				-- LOLLO NOTE stations with mixed cargo and passengers seem impossible by design.
				-- There are some assertions, like allPersonEdgesHaveTransportModePerson != allPersonEdgesHaveTransportModeCargo,
				-- that point at this.
				local _groupTerminals = function()
					result.stations = { }
					if result.terminateConstructionHookInfo.isAnyCargoTerminal then
						result.stations[#result.stations+1] = {
							tag = 0, -- in the stock station, this is 0 for cargo and 1 for passengers
							terminals = { } -- 0 is the position of the linked terminal group, in base 0
						}
					end
					if result.terminateConstructionHookInfo.isAnyPassengerTerminal then
						result.stations[#result.stations+1] = {
							tag = 1, -- in the stock station, this is 0 for cargo and 1 for passengers
							terminals = { } -- 0 is the position of the linked terminal group, in base 0
						}
					end

					for t = 1, #params.terminals do
						local isCargoTerminal = params.terminals[t].isCargo
						table.insert(
							result.terminalGroups,
							{
								tag = t - 1,
								terminals = {
									-- { 0, 0 }
								},
								-- UG TODO ask UG if they can make a parameter similar to the following,
								-- to override personEdges and personNodes.
								-- This way, I won't be bound to using a model to assign a waiting area.
								-- LOLLO NOTE there can be 1 terminal 4 1 vehicle node,
								-- n terminals 4 1 person edge,
								-- n terminals 4 1 person node
								-- vehicleNodeOverride = #params.terminals[t].trackEdgeLists - 1
								vehicleNodeOverride = result.terminateConstructionHookInfo.vehicleNodes[t]
							}
						)

						local modelIndexesBase0 = {}
						for i = 1, #result.models do
							if slotHelpers.getTerminalFromModelTag(result.models[i].tag) == t then
								modelIndexesBase0[#modelIndexesBase0+1] = i - 1
							-- elseif result.models[i].slotId ~= nil then
							-- 	local nTerminal, _, _ = slotHelpers.demangleId(result.models[i].slotId)
							-- 	if nTerminal == t then
							-- 		modelIndexesBase0[#modelIndexesBase0+1] = i - 1
							-- 	end
							end
						end
						for _, modelIndex in pairs(modelIndexesBase0) do
							-- table.insert(result.terminalGroups[#result.terminalGroups].terminals, {modelIndex, t - 1}) -- NO!
							table.insert(result.terminalGroups[#result.terminalGroups].terminals, {modelIndex, 0})
						end

						local stationIndex = arrayUtils.findIndex(result.stations, 'tag', isCargoTerminal and 0 or 1)
						table.insert(result.stations[stationIndex].terminals, t - 1)
					end
				end
				_groupTerminals()
				print('terminals grouped')

				-- avoid dump when configuring
				-- if #(result.stations[1].terminals) == 0 then
				-- 	print('avoiding dump when configuring')
				-- 	table.insert(result.stations[1].terminals, 0)
				-- 	print('result.stations =') debugPrint(result.stations)
				-- end

				-- it should output something like (this example has one terminal made of two adjacent bits)
				-- stock result.stations =
				-- 	{
				-- 		{
				-- 			tag = 0, -- in the stock station, this is 0 for cargo and 1 for passengers
				-- 			terminals = { 0 } -- 0 is the position of the linked terminal group, in base 0
				-- 		}
				-- 	}
				-- stock result.terminalGroups =
				-- {
				-- 	{
				-- 		tag = -1, -- possibly useless, try to keep them all different tho
				-- 		terminals = {
				-- 			{ 22, 0 }, -- 22 is the position of a model with a terminal, in base 0
				-- 			{ 25, 0 }, -- 0 is always 0 in the stock station, it is something like a terminal number
				-- 		}
				-- 	}
				-- }

				-- print('LOLLO lollo_freestyle_train_station leaving terminateConstructionHook')
				-- print('LOLLO result = ') debugPrint(result)
				-- print('LOLLO result.stations = ') debugPrint(result.stations)
				-- print('LOLLO result.models = ') debugPrint(result.models)
				-- print('LOLLO result.terminalGroups = ') debugPrint(result.terminalGroups)
			end -- end of terminateConstructionHook()

			-- print('freestyleTrainStation.updateFn about to return')
			-- print('freestyleTrainStation result =') debugPrint(result)
			-- print('freestyleTrainStation result.terrainAlignmentLists =') debugPrint(result.terrainAlignmentLists)
			return result
		end,
 		-- preProcessFn = function(modules, change, three)
		-- 	-- this fires when the user adds or removes a module
		-- 	print('LOLLO preProcessFn')
		-- 	-- print('modules =') debugPrint(modules)
		-- 	print('change =') debugPrint(change)
		-- 	-- default behaviour
		-- 	if change.added then
		-- 		modules[change.slotId] = change.module
		-- 	else
		-- 		modules[change.slotId] = nil
		-- 	end
		-- 	-- airport behaviour
		-- 	-- if change.added then
		-- 	-- 	if change.slotId == landingSlotId + 1 then
		-- 	-- 		modules[landingSlotId + 0] = nil
		-- 	-- 	elseif change.slotId == landingSlotId + 0 then
		-- 	-- 		modules[landingSlotId + 1] = nil
		-- 	-- 	elseif change.slotId == landingSlotId + 2 then
		-- 	-- 		modules[landingSlotId + 3] = nil
		-- 	-- 	elseif change.slotId == landingSlotId + 3 then
		-- 	-- 		modules[landingSlotId + 2] = nil
		-- 	-- 	end
		-- 	-- 	modules[change.slotId] = change.module
		-- 	-- else
		-- 	-- 	modules[change.slotId] = nil
		-- 	-- end
		-- 	return modules
        -- end,
        upgradeFn = function(args, one)
            -- LOLLO TODO allow upgrading tracks.
            -- this sample is from the modular station, which puts edges in modules.
			-- I don't coz they are curved, so see what I can do.
			-- args contains the params and slotId, which is now correct, and no transf.
			-- it also contains:
			-- trackType = 1,
			  -- trackTypeToggle = 1,
			  -- to keep things simple, I could apply the toggle to all track edges of all terminals.
			-- print('LOLLO upgradeFn starting, args =') debugPrint(args)
			print('LOLLO upgradeFn starting, args.slotId =') debugPrint(args.slotId)
			-- print('one = ') debugPrint(one) -- nil
            local modules = {}

            local SwapModule = function(slotId, from, to)
                if args.modules[slotId] and args.modules[slotId].name == from then
                    table.insert(modules, {slotId, to})
                    return true
                end
                return false
            end
            local SwapRow = function(slotId, from, to)
                local slotId2 = slotId
                while SwapModule(slotId2, from, to) do 
                    slotId2 = slotId2 + 10
                end
                slotId2 = slotId
                while SwapModule(slotId2, from, to) do 
                    slotId2 = slotId2 - 10
                end
            end

            if args.modules[args.slotId] == nil then return {} end

            if args.catenaryToggle == 1 then 
                SwapRow(args.slotId, "station/rail/modular_station/platform_high_speed_track.module",
                    "station/rail/modular_station/platform_high_speed_track_catenary.module")
                SwapRow(args.slotId, "station/rail/modular_station/platform_track.module",
                    "station/rail/modular_station/platform_track_catenary.module")
                SwapRow(args.slotId, "station/rail/modular_station/platform_high_speed_track_catenary.module", 
                    "station/rail/modular_station/platform_high_speed_track.module")
                SwapRow(args.slotId, "station/rail/modular_station/platform_track_catenary.module", 
                    "station/rail/modular_station/platform_track.module")
            end
            if args.trackTypeToggle == 1 then 
                SwapRow(args.slotId, "station/rail/modular_station/platform_high_speed_track.module",
                    "station/rail/modular_station/platform_track.module")
                SwapRow(args.slotId, "station/rail/modular_station/platform_track.module",
                    "station/rail/modular_station/platform_high_speed_track.module")
                SwapRow(args.slotId, "station/rail/modular_station/platform_high_speed_track_catenary.module",
                    "station/rail/modular_station/platform_track_catenary.module")
                SwapRow(args.slotId, "station/rail/modular_station/platform_track_catenary.module",
                    "station/rail/modular_station/platform_high_speed_track_catenary.module")
            end

            return modules
        end,
	}
end