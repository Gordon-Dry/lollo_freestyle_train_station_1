local _constants = require('lollo_freestyle_train_station.constants')
local arrayUtils = require('lollo_freestyle_train_station.arrayUtils')
local edgeUtils = require('lollo_freestyle_train_station.edgeUtils')
local logger = require('lollo_freestyle_train_station.logger')
local moduleHelpers = require('lollo_freestyle_train_station.moduleHelpers')
local slotHelpers = require('lollo_freestyle_train_station.slotHelpers')
local stringUtils = require('lollo_freestyle_train_station.stringUtils')
local trackUtils = require('lollo_freestyle_train_station.trackHelpers')
local transfUtilsUG = require 'transf'
local transfUtils = require('lollo_freestyle_train_station.transfUtils')
local vec3 = require 'vec3'

local function _myErrorHandler(err)
    print('lollo freestyle train station - station.con ERROR: ', err)
end

-- LOLLO NOTE
-- Instead of different cargo platforms with different widths, we could only use 5m areas for all,
-- and add new modules for extra space, parallel to the platform-tracks.
-- However, it is easier to place more platform-tracks upfront than add modules later,
-- so we go this way.

-- LOLLO NOTE we need skipCollision = false in the construction
-- coz we don't want to check for crazy stuff on a non-grid pattern.
-- However, it can be trouble.
-- Perhaps you bury the modules into the ground, like with the lorry station?
-- If I crop the platform tracks outside the station, there are no more collisions!
-- If I replace the track definition of my platform-track with the stock track,
-- the problem still occurs.
-- If I add the edgeLists in terminateConstructionHook, it does not help.
-- The trick was to carefully avoid anything even grazing on the neighbour edge:
-- even a collision-free model with a path can make trouble.
-- It's also important to assign void bounding boxes and colliders to certain models,
-- as opposed to not assigning any, which fails to turn off collisions.
-- When configuring a modular construction, the spacing is vital coz it covers the area that the game checks for collisions,
-- with own or third objects. The height assigns a height to this area, turning it into a collidable parallelepiped.

-- LOLLO NOTE we add a "subways" indexed table with the same indexes as params.modules, to hold extra information
-- that is, the transf. If a module is deleted in the game, its matching subways[] entry may be still around.
-- As soon as a new subway is built, its subways[] will be updated.
-- So, when querying params.subways[slotId], make sure that params.modules[slotId] also exists.

-- LOLLO NOTE try building a station next to a platform and onto a track
-- belonging to another terminal: you can. You shouldn't tho. Adding colliders into the modules does not help.
-- The proper way would be to check the neighbours before assigning a slot,
-- but this can be expensive and complicated in a free layout such as this.

function data()
	return {
		type = 'RAIL_STATION',
		description = {
			name = _("LolloFreestyleTrainStationName"),
			description = _("LolloFreestyleTrainStationDesc"),
		},
		availability = {
			yearFrom = -1, -- 1925, -- -1,
			yearTo = -1, -- -1, -- 0
		},
		order = 5005,
		soundConfig = {
			soundSet = { name = "station_cargo_old" }
		},
		autoRemovable = false,
		skipCollision = false, -- see the notes
		params = { -- keep it empty or it will crash coz it won't find the params, which I pass when building the construction
            -- {
            --     key = 'fileName',
            --     name = 'File Name',
            --     values = {
            --         'dummy',
            --     },
            --     defaultIndex = 0
            -- }
        },
		updateFn = function(params)
			logger.print('station.con updateFn starting')
			-- logger.print('updateFn starting, params =') logger.debugPrint(params)
			-- logger.print('station.con updateFn starting, params.modules =') logger.debugPrint(params.modules)
			-- LOLLO TODO sometimes, there are too many modules of type trackSpeed or trackElectrification
			-- It seems fixed, but keep checking it.
			if not params.modules then params.modules = {} end

			-- LOLLO NOTE I cannot call the api from here, sigh. api is there, but api.res is NIL. Also game is there, but game.interface is NIL
			local result = {
				colliders = {},
				-- coord2terminalInfo = {},
                cost = 1000,
                demangleId = slotHelpers.demangleId,
                edgeLists = {},
				groundFaces = {},
				labelText = {},
                mangleId = slotHelpers.mangleId,
				models = {
					-- {
					-- 	id = 'lollo_freestyle_train_station/icon/blue.mdl',
					-- 	tag = 'stationTag',
                    --     transf = {1, 0, 0, 0,
                    --         0, 1, 0, 0,
                    --         0, 0, 1, 0,
                    --         0, 0, 0, 1},
					-- },
                },
                slotConfig = {
					-- LOLLO NOTE these guys skip the collision check between the spacing rectangle
					-- of the module being placed and the spacing rectangles of the already built modules.
					-- they also skip the collision check between the spacing rectangle
					-- of the module being placed and the objects outside the construction (the slot does not turn red while proposing a placement).
					-- If I skip the sloped area collisions there will be trouble tho!
					-- [_constants.slopedCargoArea1x5ModuleType] = {
					-- 	maxModules = -1,
					-- 	message = nil, --'LOLLO slotConfig message',
					-- 	skipCollisionCheck = true,
					-- },
					-- [_constants.slopedPassengerArea1x5ModuleType] = {
					-- 	maxModules = -1,
					-- 	message = nil, --'LOLLO slotConfig message',
					-- 	skipCollisionCheck = true,
					-- },
					-- [_constants.slopedCargoArea1x10ModuleType] = {
					-- 	maxModules = -1,
					-- 	message = nil, --'LOLLO slotConfig message',
					-- 	skipCollisionCheck = true,
					-- },
					-- [_constants.slopedPassengerArea1x10ModuleType] = {
					-- 	maxModules = -1,
					-- 	message = nil, --'LOLLO slotConfig message',
					-- 	skipCollisionCheck = true,
					-- },
					-- [_constants.slopedCargoArea1x20ModuleType] = {
					-- 	maxModules = -1,
					-- 	message = nil, --'LOLLO slotConfig message',
					-- 	skipCollisionCheck = true,
					-- },
					-- [_constants.slopedPassengerArea1x20ModuleType] = {
					-- 	maxModules = -1,
					-- 	message = nil, --'LOLLO slotConfig message',
					-- 	skipCollisionCheck = true,
					-- },
					[_constants.trackElectrificationModuleType] = {
						maxModules = -1,
						message = nil, --'LOLLO slotConfig message',
						skipCollisionCheck = true,
					},
					[_constants.trackSpeedModuleType] = {
						maxModules = -1,
						message = nil, --'LOLLO slotConfig message',
						skipCollisionCheck = true,
					},
					-- [_constants.cargoTerminalModuleType] = {
					-- 	maxModules = -1,
					-- 	message = nil, --'LOLLO slotConfig message',
					-- 	skipCollisionCheck = true,
					-- },
					-- [_constants.passengerTerminalModuleType] = {
					-- 	maxModules = -1,
					-- 	message = nil, --'LOLLO slotConfig message',
					-- 	skipCollisionCheck = true,
					-- },
				},
                slots = {},
				stations = {},
				terminalGroups = {},
				terrainAlignmentLists = { { -- LOLLO NOTE this thing with the empty faces is required , otherwise the game will make its own alignments, with spikes and all on bridges or tunnels.
					type = "EQUAL",
					optional = true,
					faces =  { }
				} },
			}

			local occupiedInfo = {
				crossConnectorsWithFlatAreas = { },
				crossConnectorsWithSlopedAreas = { },
			}
			local _getOccupiedInfo4FlatAreas = function(t, i)
				if occupiedInfo.crossConnectorsWithFlatAreas[t] == nil or occupiedInfo.crossConnectorsWithFlatAreas[t][i] == nil then
					return nil
				else
					return occupiedInfo.crossConnectorsWithFlatAreas[t][i]
				end
			end
			local _setOccupiedInfo4FlatAreas = function(t, i, newId)
				if occupiedInfo.crossConnectorsWithFlatAreas[t] == nil then
					occupiedInfo.crossConnectorsWithFlatAreas[t] = {}
				end
				occupiedInfo.crossConnectorsWithFlatAreas[t][i] = newId
			end
			local _getOccupiedInfo4SlopedAreas = function(t, i)
				if occupiedInfo.crossConnectorsWithSlopedAreas[t] == nil or occupiedInfo.crossConnectorsWithSlopedAreas[t][i] == nil then
					return { id = nil, yShift = 0 }
				else
					-- logger.print('get occupiedInfo.crossConnectorsWithSlopedAreas[t][i] =') logger.debugPrint(occupiedInfo.crossConnectorsWithSlopedAreas[t][i])
					return occupiedInfo.crossConnectorsWithSlopedAreas[t][i]
				end
			end
			local _setOccupiedInfo4SlopedAreas = function(t, i, newId, yShift)
				if occupiedInfo.crossConnectorsWithSlopedAreas[t] == nil then
					occupiedInfo.crossConnectorsWithSlopedAreas[t] = {}
				end
				-- logger.print('set occupiedInfo.crossConnectorsWithSlopedAreas[t][i] =') logger.debugPrint(occupiedInfo.crossConnectorsWithSlopedAreas[t][i])
				occupiedInfo.crossConnectorsWithSlopedAreas[t][i] = { id = newId, yShift = yShift or 0 }
			end
			local _occupySlopedAreas = function(t, i, slotId, slotTypeId, yShift)
				if params.modules[slotId] ~= nil then
					if i > 1 then _setOccupiedInfo4SlopedAreas(t, i-1, slotTypeId, yShift) end
					_setOccupiedInfo4SlopedAreas(t, i, slotTypeId, yShift)
					if i+1 <= #params.terminals[t].centrePlatformsRelative then _setOccupiedInfo4SlopedAreas(t, i+1, slotTypeId, yShift) end
					if i+2 <= #params.terminals[t].centrePlatformsRelative then _setOccupiedInfo4SlopedAreas(t, i+2, slotTypeId, yShift) end
				end
			end

			local _getPlatformModelId = function (isCargo, isTrackOnPlatformLeft, width, era)
				local myModelId = ''
				if isCargo then
					if width < 10 then
						myModelId = 'lollo_freestyle_train_station/railroad/platform/era_c_cargo_platform_1m_base_5m_wide.mdl'
					elseif width < 20 then
						myModelId = 'lollo_freestyle_train_station/railroad/platform/era_c_cargo_platform_1m_base_10m_wide.mdl'
					else
						myModelId = 'lollo_freestyle_train_station/railroad/platform/era_c_cargo_platform_1m_base_20m_wide.mdl'
					end
				else
					if width < 5 then
						myModelId = isTrackOnPlatformLeft
							and 'lollo_freestyle_train_station/railroad/platform/era_c_passenger_platform_1m_base_3_1m_wide_stripe_left.mdl'
							or 'lollo_freestyle_train_station/railroad/platform/era_c_passenger_platform_1m_base_3_1m_wide_stripe_right.mdl'
					else
						myModelId = isTrackOnPlatformLeft
							and 'lollo_freestyle_train_station/railroad/platform/era_c_passenger_platform_1m_base_5_6m_wide_stripe_left.mdl'
							or 'lollo_freestyle_train_station/railroad/platform/era_c_passenger_platform_1m_base_5_6m_wide_stripe_right.mdl'
					end
				end

				if era == trackUtils.eras.era_a.prefix then
					return myModelId:gsub(trackUtils.eras.era_c.prefix, trackUtils.eras.era_a.prefix)
				elseif era == trackUtils.eras.era_b.prefix then
					return myModelId:gsub(trackUtils.eras.era_c.prefix, trackUtils.eras.era_b.prefix)
				else
					return myModelId
				end
			end

			result.terminateConstructionHookInfo = {
				crossConnectorPositions = {},
				isAnyCargoTerminal = false,
				isAnyPassengerTerminal = false,
				liftBottomPositions = {},
				trackCrossingPositions = {},
				tunnelStairsTopPositions = {},
				tunnelStairsBottomPositions = {},
				underpassPositionsOnGround = {},
				underpassPositionsOnBridge = {},
				vehicleNodes = {}
			}

			result.laneZs = {}

			for t = 1, #params.terminals do
				-- this is only a test to see if the transformation was ok. They match beautifully! Use this when talking to UG.
				-- if #result.edgeLists > 0 then
				-- 	local firstPosTanX2 = result.edgeLists[1].edges
				-- 	logger.print('firstPosTanX2 =') logger.debugPrint(firstPosTanX2)
				-- 	local retransformedFirstEdge = transfUtils.getPosTanX2Transformed(firstPosTanX2, params.myTransf)
				-- 	logger.print('retransformed first edge =') logger.debugPrint(retransformedFirstEdge)
				-- end
				local _laneZ = _constants.platformHeight -- we could also make it vary for each terminal:
				-- everything except the platforms and the terminal deco will vary along with it.
				result.laneZs[t] = _laneZ

				local isCargoTerminal = params.terminals[t].isCargo
				if isCargoTerminal then result.terminateConstructionHookInfo.isAnyCargoTerminal = true else result.terminateConstructionHookInfo.isAnyPassengerTerminal = true end

				local isTrackOnPlatformLeft = params.terminals[t].isTrackOnPlatformLeft

				-- LOLLO NOTE I can use a platform-track or dedicated models for the platform.
				-- The former is simpler, the latter requires adding an invisible track so the platform fits in bridges or tunnels.
				-- The former is a bit glitchy, the latter is prettier.
				local function _addPlatform()
					for _, cpf in pairs(params.terminals[t].centrePlatformsFineRelative) do
						local myTransf = moduleHelpers.getPlatformObjectTransf_WithYRotation(cpf.posTanX2)
						local era = moduleHelpers.getEraPrefix(params, t, cpf.leadingIndex)
						local myModelId = _getPlatformModelId(isCargoTerminal, isTrackOnPlatformLeft, cpf.width, era)
						result.models[#result.models+1] = {
							id = myModelId,
							transf = myTransf
						}
					end
				end
				_addPlatform()

				local function _addPlatformRoofs()
					if isCargoTerminal then return end

					for i = 2, #params.terminals[t].centrePlatformsRelative, 3 do
						local cpl = params.terminals[t].centrePlatformsRelative[i]
						if cpl.type ~= 2 then -- no platform roofs in tunnels
							local myId = result.mangleId(t, i, _constants.idBases.platformRoofSlotId)
							table.insert(result.slots, {
								-- height = 0,
								id = myId,
								spacing = {-0.1, 2, 1, 1},
								transf = moduleHelpers.getPlatformObjectTransf_WithYRotation(cpl.posTanX2),
								type = _constants.platformRoofModuleType,
							})
						end
					end
				end
				_addPlatformRoofs()

				local function _addOutsideExtensions()
					for i = 2, #params.terminals[t].centrePlatformsRelative, 3 do
						local cpl = params.terminals[t].centrePlatformsRelative[i]
						if cpl.type == 0 then -- only on ground
							if not(_getOccupiedInfo4SlopedAreas(t, i).id) or _getOccupiedInfo4SlopedAreas(t, i).id == _constants.idBases.slopedArea1x5SlotId then
								local yShiftOutside, yShiftOutside4StreetAccess = moduleHelpers.slopedAreas.getYShift(params, t, i, 5)
								local myId = result.mangleId(t, i, _constants.idBases.slopedArea1x5SlotId)
								table.insert(result.slots, {
									-- height = 0,
									id = myId,
									-- 0, 3} and 3, 0} shift this along the track so it avoids flat areas,
									-- which have the same thing reversed.
									-- This way, sloped areas and flat areas can be easily combined.
									spacing = isTrackOnPlatformLeft and {2, 0, 0, 3} or {0, 2, 3, 0},
									transf = transfUtilsUG.mul(
										moduleHelpers.getPlatformObjectTransf_WithYRotation(cpl.posTanX2),
										{ 0, 1, 0, 0,  -1, 0, 0, 0,  0, 0, 1, 0,  0, yShiftOutside, _constants.platformSideBitsZ, 1 }
									),
									type = isCargoTerminal and _constants.slopedCargoArea1x5ModuleType or _constants.slopedPassengerArea1x5ModuleType,
								})
								_occupySlopedAreas(t, i, myId, _constants.idBases.slopedArea1x5SlotId, yShiftOutside4StreetAccess)
							end

							if not(_getOccupiedInfo4SlopedAreas(t, i).id) or _getOccupiedInfo4SlopedAreas(t, i).id == _constants.idBases.slopedArea1x10SlotId then
								local yShiftOutside, yShiftOutside4StreetAccess = moduleHelpers.slopedAreas.getYShift(params, t, i, 10)
								local myId = result.mangleId(t, i, _constants.idBases.slopedArea1x10SlotId)
								table.insert(result.slots, {
									-- height = 0,
									id = myId,
									spacing = isTrackOnPlatformLeft and {3, 2, 0, 3} or {2, 3, 3, 0},
									transf = transfUtilsUG.mul(
										moduleHelpers.getPlatformObjectTransf_WithYRotation(cpl.posTanX2),
										{ 0, 1, 0, 0,  -1, 0, 0, 0,  0, 0, 1, 0,  0, yShiftOutside, _constants.platformSideBitsZ, 1 }
									),
									type = isCargoTerminal and _constants.slopedCargoArea1x10ModuleType or _constants.slopedPassengerArea1x10ModuleType,
								})
								_occupySlopedAreas(t, i, myId, _constants.idBases.slopedArea1x10SlotId, yShiftOutside4StreetAccess)
							end

							if not(_getOccupiedInfo4SlopedAreas(t, i).id) or _getOccupiedInfo4SlopedAreas(t, i).id == _constants.idBases.slopedArea1x20SlotId then
								local yShiftOutside, yShiftOutside4StreetAccess = moduleHelpers.slopedAreas.getYShift(params, t, i, 20)
								local myId = result.mangleId(t, i, _constants.idBases.slopedArea1x20SlotId)
								table.insert(result.slots, {
									-- height = 0,
									id = myId,
									spacing = isTrackOnPlatformLeft and {8, 4, 0, 3} or {4, 8, 3, 0},
									transf = transfUtilsUG.mul(
										moduleHelpers.getPlatformObjectTransf_WithYRotation(cpl.posTanX2),
										{ 0, 1, 0, 0,  -1, 0, 0, 0,  0, 0, 1, 0,  0, yShiftOutside, _constants.platformSideBitsZ, 1 }
									),
									type = isCargoTerminal and _constants.slopedCargoArea1x20ModuleType or _constants.slopedPassengerArea1x20ModuleType,
								})
								_occupySlopedAreas(t, i, myId, _constants.idBases.slopedArea1x20SlotId, yShiftOutside4StreetAccess)
							end
						end
					end
				end
				_addOutsideExtensions()

				local function _addStreetAccess()
					for i = 2, #params.terminals[t].centrePlatformsRelative do -- cross connectors, which are nodes, are 1 more then centre platforms, which are edges, so I go on until the end
						local cpl = params.terminals[t].centrePlatformsRelative[i]
						local cplPrevious = params.terminals[t].centrePlatformsRelative[i-1]
						if cpl.type ~= 2 and cplPrevious.type ~= 2 then -- no tunnels
							local isUnderpass = params.modules[result.mangleId(t, i, _constants.idBases.underpassSlotId)] ~= nil
							local isNextUnderpass = i < #params.terminals[t].centrePlatformsRelative
								and params.modules[result.mangleId(t, i+1, _constants.idBases.underpassSlotId)] ~= nil
								or false
							local isPreviousUnderpass = i > 1
								and params.modules[result.mangleId(t, i-1, _constants.idBases.underpassSlotId)] ~= nil
								or false
							local crossConnectorPosTanX2 = params.terminals[t].crossConnectorsRelative[i].posTanX2
							if not(isUnderpass) and not(isPreviousUnderpass) then
								if cpl.type == 0 then -- ground
									if not(_getOccupiedInfo4FlatAreas(t, i))
									or _getOccupiedInfo4FlatAreas(t, i) == _constants.idBases.flatStairsOrRampSlotId then
										local yShift = cpl.width + _getOccupiedInfo4SlopedAreas(t, i).yShift
										local myPosTanX2 = transfUtils.getExtrapolatedPosTanX2Continuation(crossConnectorPosTanX2, yShift)
										local myTransf = transfUtilsUG.mul(
											moduleHelpers.getPlatformObjectTransf_AlwaysVertical(myPosTanX2),
											{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1 }
										)
										local myId = result.mangleId(t, i, _constants.idBases.flatStairsOrRampSlotId)
										table.insert(result.slots, {
											-- height = 0,
											id = myId,
											-- spacing = {-0.1, 1.5, -0.1, 0.9},
											spacing = {0.5, 1.5, -0.1, 1},
											transf = myTransf,
											type = isCargoTerminal and _constants.flatCargoRampModuleType or _constants.flatPassengerStairsModuleType,
										})
										if params.modules[myId] ~= nil then
											_setOccupiedInfo4FlatAreas(t, i, _constants.idBases.flatStairsOrRampSlotId)
										end
									end
									if not(_getOccupiedInfo4FlatAreas(t, i))
									or _getOccupiedInfo4FlatAreas(t, i) == _constants.idBases.flatArea5x5SlotId then
										local yShift = cpl.width + 5 + _getOccupiedInfo4SlopedAreas(t, i).yShift
										local myPosTanX2 = transfUtils.getExtrapolatedPosTanX2Continuation(crossConnectorPosTanX2, yShift)
										local myTransf = transfUtilsUG.mul(
											moduleHelpers.getPlatformObjectTransf_AlwaysVertical(myPosTanX2),
											{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1 }
										)
										local myId = result.mangleId(t, i, _constants.idBases.flatArea5x5SlotId)
										table.insert(result.slots, {
											-- height = 0,
											id = myId,
											-- spacing = {-0.1, 3, -0.1, 2},
											spacing = {0.5, 3, -0.1, 2},
											transf = myTransf,
											type = isCargoTerminal and _constants.flatCargoArea5x5ModuleType or _constants.flatPassengerArea5x5ModuleType,
										})
										if params.modules[myId] ~= nil then
											_setOccupiedInfo4FlatAreas(t, i, _constants.idBases.flatArea5x5SlotId)
										end
									end
									if not(_getOccupiedInfo4FlatAreas(t, i))
									or _getOccupiedInfo4FlatAreas(t, i) == _constants.idBases.flatArea8x5SlotId then
										local yShift = cpl.width + 5 + _getOccupiedInfo4SlopedAreas(t, i).yShift
										local myPosTanX2 = transfUtils.getExtrapolatedPosTanX2Continuation(crossConnectorPosTanX2, yShift)
										local myTransf = transfUtilsUG.mul(
											moduleHelpers.getPlatformObjectTransf_AlwaysVertical(myPosTanX2),
											{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1 }
										)
										local myId = result.mangleId(t, i, _constants.idBases.flatArea8x5SlotId)
										table.insert(result.slots, {
											-- height = 0,
											id = myId,
											-- spacing = {-0.1, 3, -0.1, 3},
											spacing = {0.5, 3, -0.1, 3},
											transf = myTransf,
											type = isCargoTerminal and _constants.flatCargoArea8x5ModuleType or _constants.flatPassengerArea8x5ModuleType,
										})
										if not(isUnderpass) and not(isPreviousUnderpass) and params.modules[myId] ~= nil then
											_setOccupiedInfo4FlatAreas(t, i, _constants.idBases.flatArea8x5SlotId)
										end
									end
									if not(_getOccupiedInfo4FlatAreas(t, i))
									or _getOccupiedInfo4FlatAreas(t, i) == _constants.idBases.flatArea8x10SlotId then
										local yShift = cpl.width + 10 + _getOccupiedInfo4SlopedAreas(t, i).yShift
										local myPosTanX2 = transfUtils.getExtrapolatedPosTanX2Continuation(crossConnectorPosTanX2, yShift)
										local myTransf = transfUtilsUG.mul(
											moduleHelpers.getPlatformObjectTransf_AlwaysVertical(myPosTanX2),
											{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1 }
										)
										local myId = result.mangleId(t, i, _constants.idBases.flatArea8x10SlotId)
										table.insert(result.slots, {
											-- height = 0,
											id = myId,
											-- spacing = {-0.1, 3, -0.1, 3},
											spacing = {0.5, 3, -0.1, 3},
											transf = myTransf,
											type = isCargoTerminal and _constants.flatCargoArea8x10ModuleType or _constants.flatPassengerArea8x10ModuleType,
										})
										if not(isUnderpass) and not(isPreviousUnderpass) and params.modules[myId] ~= nil then
											_setOccupiedInfo4FlatAreas(t, i, _constants.idBases.flatArea8x10SlotId)
										end
									end
									if not(isCargoTerminal) then
										if not(_getOccupiedInfo4FlatAreas(t, i))
										or _getOccupiedInfo4FlatAreas(t, i) == _constants.idBases.flatStation0MSlotId then
											local yShift = cpl.width + _getOccupiedInfo4SlopedAreas(t, i).yShift
											local myPosTanX2 = transfUtils.getExtrapolatedPosTanX2Continuation(crossConnectorPosTanX2, yShift)
											local myTransf = transfUtilsUG.mul(
												moduleHelpers.getPlatformObjectTransf_AlwaysVertical(myPosTanX2),
												{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ + _constants.platformSideBitsZ, 1 }
											)
											local myId = result.mangleId(t, i, _constants.idBases.flatStation0MSlotId)
											table.insert(result.slots, {
												-- height = 0,
												id = myId,
												spacing = isTrackOnPlatformLeft and {1, 1, 3, -0.1} or {1, 1, -0.1, 3},
												transf = myTransf,
												type = _constants.flatPassengerStation0MModuleType,
											})
											if params.modules[myId] ~= nil then
												local lane2AreaTransf = transfUtils.get1MLaneTransf(
													{
														myPosTanX2[1][1][1],
														myPosTanX2[1][1][2],
														myPosTanX2[1][1][3] + _laneZ,
													},
													transfUtils.transf2Position(myTransf)
												)
												result.models[#result.models+1] = {
													id = _constants.passengerLaneModelId,
													transf = lane2AreaTransf
												}
												_setOccupiedInfo4FlatAreas(t, i, _constants.idBases.flatStation0MSlotId)
											end
										end
										if not(_getOccupiedInfo4FlatAreas(t, i))
										or _getOccupiedInfo4FlatAreas(t, i) == _constants.idBases.flatStation5MSlotId then
											local yShift = cpl.width + _getOccupiedInfo4SlopedAreas(t, i).yShift
											local myPosTanX2 = transfUtils.getExtrapolatedPosTanX2Continuation(crossConnectorPosTanX2, yShift)
											local myTransf = transfUtilsUG.mul(
												moduleHelpers.getPlatformObjectTransf_AlwaysVertical(myPosTanX2),
												{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1 }
											)
											local myId = result.mangleId(t, i, _constants.idBases.flatStation5MSlotId)
											table.insert(result.slots, {
												-- height = 0,
												id = myId,
												spacing = isTrackOnPlatformLeft and {1, 1, 3, -0.1} or {1, 1, -0.1, 3},
												transf = myTransf,
												type = _constants.flatPassengerStation5MModuleType,
											})
											if params.modules[myId] ~= nil then
												local lane2AreaTransf = transfUtils.get1MLaneTransf(
													{
														myPosTanX2[1][1][1],
														myPosTanX2[1][1][2],
														myPosTanX2[1][1][3] + _laneZ,
													},
													transfUtils.transf2Position(myTransf)
												)
												result.models[#result.models+1] = {
													id = _constants.passengerLaneModelId,
													transf = lane2AreaTransf
												}
												_setOccupiedInfo4FlatAreas(t, i, _constants.idBases.flatStation5MSlotId)
											end
										end
									end
								elseif cpl.type == 1 then -- bridge
									if not(isCargoTerminal) then
										if not(_getOccupiedInfo4FlatAreas(t, i))
										or _getOccupiedInfo4FlatAreas(t, i) == _constants.idBases.sideLiftSlotId then
											local yShift = cpl.width + _getOccupiedInfo4SlopedAreas(t, i).yShift
											local myPosTanX2 = transfUtils.getExtrapolatedPosTanX2Continuation(crossConnectorPosTanX2, yShift)
											local myTransf = transfUtilsUG.mul(
												moduleHelpers.getPlatformObjectTransf_AlwaysVertical(myPosTanX2),
												{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1 }
											)
											local myId = result.mangleId(t, i, _constants.idBases.sideLiftSlotId)
											table.insert(result.slots, {
												-- height = 0,
												id = myId,
												spacing = isTrackOnPlatformLeft and {1, 1, 3, -0.1} or {1, 1, -0.1, 3},
												transf = myTransf,
												type = _constants.passengerSideLiftModuleType,
											})
											if params.modules[myId] ~= nil then
												local underpassBottomTransf = transfUtilsUG.mul(
													myTransf,
													{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _constants.underpassZ, 1 }
												)
												if result.terminateConstructionHookInfo.underpassPositionsOnBridge[t] == nil then
													result.terminateConstructionHookInfo.underpassPositionsOnBridge[t] = {}
												end
												result.terminateConstructionHookInfo.underpassPositionsOnBridge[t][#result.terminateConstructionHookInfo.underpassPositionsOnBridge[t]+1] = {
													t = t,
													pos2Link = transfUtils.transf2Position(underpassBottomTransf)
												}

												result.models[#result.models+1] = {
													id = _constants.passengerLaneModelId,
													transf = transfUtils.get1MLaneTransf(
														transfUtils.getPositionRaisedBy(myPosTanX2[1][1], _laneZ),
														transfUtils.transf2Position(myTransf)
													)
												}
												_setOccupiedInfo4FlatAreas(t, i, _constants.idBases.sideLiftSlotId)
											end
										end
										if i < #params.terminals[t].centrePlatformsRelative
										and not(isNextUnderpass)
										and (not(_getOccupiedInfo4FlatAreas(t, i))
										or _getOccupiedInfo4FlatAreas(t, i) == _constants.idBases.platformLiftSlotId) then
											local xyZoomFactor = isTrackOnPlatformLeft and 1 or -1
											local myTransf = transfUtilsUG.mul(
												moduleHelpers.getPlatformObjectTransf_AlwaysVertical(cpl.posTanX2),
												{ xyZoomFactor, 0, 0, 0,  0, xyZoomFactor, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1 }
											)
											local myId = result.mangleId(t, i, _constants.idBases.platformLiftSlotId)
											table.insert(result.slots, {
												-- height = 0,
												id = myId,
												spacing = isTrackOnPlatformLeft and {3, -0.1, 1, 1} or {-0.1, 3, 1, 1},
												transf = myTransf,
												type = _constants.passengerPlatformLiftModuleType,
											})
										end
									end
								end
							end
						end
					end
				end
				_addStreetAccess()

				local function _addTrackCrossings()
					if isCargoTerminal then return end
					-- cross connectors, which are nodes, are 1 more then centre platforms, which are edges, so I go on until the end
					-- I work with centrePlatformsFineRelative instead of centrePlatformsRelative so I get more accurate angles
					for ii = 2, #params.terminals[t].centrePlatformsFineRelative do
						local cpf = params.terminals[t].centrePlatformsFineRelative[ii]
						local cpfPrevious = params.terminals[t].centrePlatformsFineRelative[ii-1]
						if cpf.leadingIndex ~= cpfPrevious.leadingIndex then
							local i = cpf.leadingIndex
							local isUnderpass = params.modules[result.mangleId(t, i, _constants.idBases.underpassSlotId)] ~= nil
							local isPreviousUnderpass = i > 1
								and params.modules[result.mangleId(t, i-1, _constants.idBases.underpassSlotId)] ~= nil
								or false

							if not(isUnderpass) and not(isPreviousUnderpass) then
								local crossConnectorPosTanX2 = params.terminals[t].crossConnectorsRelative[i].posTanX2
								-- a bit of a bodge: I take the position from the connector,
								-- which has no knowledge of the slope,
								-- and the slope from the centre platform fine,
								-- which is very slightly shifted from the connector. Not too bad.
								local trackCrossingPosTanX2 = transfUtils.getPosTanX2Normalised(
									transfUtils.getPosTanX2Reversed(crossConnectorPosTanX2), -- cross connectors go from the platform border to its centre, here we go toward the edge
									cpf.width * 0.5 + 2.5 -- half platform width plus half track width is the centre of the track
								)
								local trackCrossingTransf = moduleHelpers.getPlatformObjectTransf_WithYRotation(cpf.posTanX2)
								trackCrossingTransf[13] = trackCrossingPosTanX2[2][1][1]
								trackCrossingTransf[14] = trackCrossingPosTanX2[2][1][2]
								trackCrossingTransf[15] = trackCrossingPosTanX2[2][1][3]

								local trackCrossingId = result.mangleId(t, i, _constants.idBases.trackCrossingSlotId)
								table.insert(result.slots, {
									-- height = 0,
									id = trackCrossingId,
									spacing = {1.5, -0.5, 1, 1}, -- avoid module collisions with terminal slots
									transf = trackCrossingTransf,
									type = _constants.trackCrossingModuleType,
								})

								if params.modules[trackCrossingId] ~= nil then
									if result.terminateConstructionHookInfo.trackCrossingPositions[t] == nil then result.terminateConstructionHookInfo.trackCrossingPositions[t] = {} end
									table.insert(
										result.terminateConstructionHookInfo.trackCrossingPositions[t],
										{
											t = t,
											pos = transfUtils.getPositionRaisedBy(crossConnectorPosTanX2[1][1], _laneZ)
										}
									)
								end
							end
						end
					end
				end
				_addTrackCrossings()

				local function _addLanesAcross()
					if isCargoTerminal then return end

					for i = 2, #params.terminals[t].centrePlatformsRelative do -- cross connectors, which are nodes, are 1 more then centre platforms, which are edges, so I go on until the end
						local isUnderpass = params.modules[result.mangleId(t, i, _constants.idBases.underpassSlotId)] ~= nil
						local isPreviousUnderpass = i > 1
							and params.modules[result.mangleId(t, i-1, _constants.idBases.underpassSlotId)] ~= nil
							or false
						-- local isPlatformLift = params.modules[result.mangleId(t, i, _constants.idBases.platformLiftSlotId)] ~= nil
						-- local isPreviousPlatformLift = i > 1
						-- 	and params.modules[result.mangleId(t, i-1, _constants.idBases.platformLiftSlotId)] ~= nil
						-- 	or false

						-- if not(isUnderpass) and not(isPreviousUnderpass) and not(isPlatformLift) and not(isPreviousPlatformLift) then
						if not(isUnderpass) and not(isPreviousUnderpass) then
							local crossConnectorPosTanX2 = params.terminals[t].crossConnectorsRelative[i].posTanX2
							local crossConnectorTransf = transfUtilsUG.mul(
								transfUtils.get1MLaneTransf(crossConnectorPosTanX2[1][1], crossConnectorPosTanX2[2][1]),
								{1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1}
							)
							result.models[#result.models+1] = {
								id = _constants.passengerLaneModelId,
								transf = crossConnectorTransf
							}
							if result.terminateConstructionHookInfo.crossConnectorPositions[t] == nil then result.terminateConstructionHookInfo.crossConnectorPositions[t] = {} end
							table.insert(
								result.terminateConstructionHookInfo.crossConnectorPositions[t],
								{
									t = t,
									pos = transfUtils.getPositionRaisedBy(crossConnectorPosTanX2[2][1], _laneZ)
								}
							)
						end
					end
				end
				_addLanesAcross()

				local function _addLanesAlong()
					if isCargoTerminal then return end

					for i = 2, #params.terminals[t].centrePlatformsRelative - 1 do -- skip the outermost edges to avoid collisions, the game is very picky here.
						local cpl = params.terminals[t].centrePlatformsRelative[i]
						local isInTunnel = cpl.type == 2
						local isOnBridge = cpl.type == 1
						local isPlatformLift = params.modules[result.mangleId(t, i, _constants.idBases.platformLiftSlotId)] ~= nil
						local isStairsUp = params.modules[result.mangleId(t, i, _constants.idBases.tunnelStairsUpSlotId)] ~= nil
						local isStairsUpDown = params.modules[result.mangleId(t, i, _constants.idBases.tunnelStairsUpDownSlotId)] ~= nil
						local isUnderpass = params.modules[result.mangleId(t, i, _constants.idBases.underpassSlotId)] ~= nil

						local centreLaneTransf = transfUtils.get1MLaneTransf(cpl.posTanX2[1][1], cpl.posTanX2[2][1])
						local myModelId = _constants.passengerLaneLinkableModelId -- _constants.passengerLaneModelId
						if isPlatformLift then myModelId = _constants.passengerLaneLiftModelId
						elseif isUnderpass then myModelId = _constants.passengerLaneUnderpassModelId
						elseif isStairsUp then myModelId = _constants.passengerLaneTunnelStairsUpModelId
						elseif isStairsUpDown then myModelId = _constants.passengerLaneTunnelStairsUpDownModelId
						end
						result.models[#result.models+1] = {
							id = myModelId,
							transf = transfUtilsUG.mul(centreLaneTransf, {1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1})
						}

						if isStairsUp then
							if result.terminateConstructionHookInfo.tunnelStairsTopPositions[t] == nil then
								result.terminateConstructionHookInfo.tunnelStairsTopPositions[t] = {}
							end
							result.terminateConstructionHookInfo.tunnelStairsTopPositions[t][#result.terminateConstructionHookInfo.tunnelStairsTopPositions[t]+1] = {
								t = t,
								pos2Link = transfUtils.transf2Position(
									transfUtilsUG.mul(
										centreLaneTransf,
										{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  _constants.underpassLengthM * 0.5, 0, _laneZ + _constants.tunnelStairsUpZ, 1 }
									)
								)
							}
						elseif isStairsUpDown then
							if result.terminateConstructionHookInfo.tunnelStairsBottomPositions[t] == nil then
								result.terminateConstructionHookInfo.tunnelStairsBottomPositions[t] = {}
							end
							result.terminateConstructionHookInfo.tunnelStairsBottomPositions[t][#result.terminateConstructionHookInfo.tunnelStairsBottomPositions[t]+1] = {
								t = t,
								pos2Link = transfUtils.transf2Position(
									transfUtilsUG.mul(
										centreLaneTransf,
										{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  _constants.underpassLengthM * 0.5, 0, _laneZ + _constants.underpassZ, 1 }
									)
								)
							}
							if result.terminateConstructionHookInfo.tunnelStairsTopPositions[t] == nil then
								result.terminateConstructionHookInfo.tunnelStairsTopPositions[t] = {}
							end
							result.terminateConstructionHookInfo.tunnelStairsTopPositions[t][#result.terminateConstructionHookInfo.tunnelStairsTopPositions[t]+1] = {
								t = t,
								pos2Link = transfUtils.transf2Position(
									transfUtilsUG.mul(
										centreLaneTransf,
										{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  _constants.underpassLengthM * 0.5, 0, _laneZ + _constants.tunnelStairsUpZ, 1 }
									)
								)
							}
						elseif (isUnderpass and isOnBridge) or isPlatformLift then
							if result.terminateConstructionHookInfo.underpassPositionsOnBridge[t] == nil then
								result.terminateConstructionHookInfo.underpassPositionsOnBridge[t] = {}
							end
							result.terminateConstructionHookInfo.underpassPositionsOnBridge[t][#result.terminateConstructionHookInfo.underpassPositionsOnBridge[t]+1] = {
								t = t,
								pos2Link = transfUtils.transf2Position(
									transfUtilsUG.mul(
										centreLaneTransf,
										{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  _constants.underpassLengthM * 0.5, 0, _laneZ + _constants.underpassZ, 1 }
									)
								)
							}
						elseif isUnderpass then
							if result.terminateConstructionHookInfo.underpassPositionsOnGround[t] == nil then
								result.terminateConstructionHookInfo.underpassPositionsOnGround[t] = {}
							end
							result.terminateConstructionHookInfo.underpassPositionsOnGround[t][#result.terminateConstructionHookInfo.underpassPositionsOnGround[t]+1] = {
								t = t,
								pos2Link = transfUtils.transf2Position(
									transfUtilsUG.mul(
										centreLaneTransf,
										{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  _constants.underpassLengthM * 0.5, 0, _laneZ + _constants.underpassZ, 1 }
									)
								)
							}
						end
					end
				end
				_addLanesAlong()

				local function _addWaitingAreas()
					if isCargoTerminal then
						for _, cwas in pairs(params.terminals[t].cargoWaitingAreasRelative) do
							for i = 1, #cwas do
								local posTanX2 = cwas[i].posTanX2
								local centreLaneTransf = transfUtils.get1MLaneTransf(posTanX2[1][1], posTanX2[2][1])
								result.models[#result.models+1] = {
									id = _constants.cargoWaitingAreaModelId,
									tag = slotHelpers.mangleModelTag(t, true),
									transf = transfUtilsUG.mul(centreLaneTransf, {1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1})
								}
							end
						end
					else
						if isTrackOnPlatformLeft then
							for i = 1, #params.terminals[t].leftPlatformsRelative do
								local posTanX2 = params.terminals[t].leftPlatformsRelative[i].posTanX2
								local leftLaneTransf = transfUtils.get1MLaneTransf(posTanX2[1][1], posTanX2[2][1])

								result.models[#result.models+1] = {
									id = _constants.passengerWaitingAreaModelId,
									tag = slotHelpers.mangleModelTag(t, false),
									transf = transfUtilsUG.mul(leftLaneTransf, {1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1})
								}
							end
						else
							for i = 1, #params.terminals[t].rightPlatformsRelative do
								local posTanX2 = params.terminals[t].rightPlatformsRelative[i].posTanX2
								-- invert the lanes or the passengers will face away from the track when waiting
								-- local rightLaneTransf = transfUtils.get1MLaneTransf(posTanX2[1][1], posTanX2[2][1])
								local rightLaneTransf = transfUtils.get1MLaneTransf(posTanX2[2][1], posTanX2[1][1])

								result.models[#result.models+1] = {
									id = _constants.passengerWaitingAreaModelId,
									tag = slotHelpers.mangleModelTag(t, false),
									-- if you touch this, you screw things
									-- transf = transfUtilsUG.mul(rightLaneTransf, {-1, 0, 0, 0,  0, -1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1})
									transf = transfUtilsUG.mul(rightLaneTransf, {1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1})
								}
							end
						end
					end
				end
				_addWaitingAreas()

				local _addTerminalSlot = function()
					local i = params.terminals[t].trackEdgeListMidIndex
					local tel = params.terminals[t].trackEdgeLists[i]
					local posTanX2 = transfUtils.getPosTanX2Transformed(tel.posTanX2, params.inverseMainTransf)
					-- local nearlyCentredPosTanX2 = transfUtils.getPosTanX2Normalised(posTanX2, 2)
					local nearlyCentredPosTanX2 = transfUtils.getPosTanX2Normalised(posTanX2, 0.1) -- does not need to be perfectly centred
					local myTransf = transfUtilsUG.mul(
						moduleHelpers.getPlatformObjectTransf_WithYRotation(nearlyCentredPosTanX2),
						{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1 }
					)
					table.insert(result.slots, {
						-- height = 0,
						id = result.mangleId(t, 0, _constants.idBases.terminalSlotId),
						spacing = {0, 0, 0, 0}, -- this can collide so we keep it zero
						transf = myTransf,
						type = isCargoTerminal and _constants.cargoTerminalModuleType or _constants.passengerTerminalModuleType,
                    })
                    -- insert two undeletable dummy slots for upgrading tracks
					table.insert(result.slots, {
						-- height = 0,
						id = result.mangleId(t, 0, _constants.idBases.trackElectrificationSlotId),
						spacing = {0, 0, 0, 0}, -- this does not prevent deletion, it just makes it harder
						transf = myTransf,
						type = _constants.trackElectrificationModuleType
					})
					table.insert(result.slots, {
						-- height = 0,
						id = result.mangleId(t, 0, _constants.idBases.trackSpeedSlotId),
						spacing = {0, 0, 0, 0},
						transf = myTransf,
						type = _constants.trackSpeedModuleType
					})
					table.insert(result.slots, {
						-- height = 0,
						id = result.mangleId(t, 0, _constants.idBases.platformEraASlotId),
						spacing = {0, 0, 0, 0},
						transf = myTransf,
						type = _constants.era_a_platformModuleType
					})
					table.insert(result.slots, {
						-- height = 0,
						id = result.mangleId(t, 0, _constants.idBases.platformEraBSlotId),
						spacing = {0, 0, 0, 0},
						transf = myTransf,
						type = _constants.era_b_platformModuleType
					})
					table.insert(result.slots, {
						-- height = 0,
						id = result.mangleId(t, 0, _constants.idBases.platformEraCSlotId),
						spacing = {0, 0, 0, 0},
						transf = myTransf,
						type = _constants.era_c_platformModuleType
					})
				end
				_addTerminalSlot()

				local _addUpDownSlots = function()
					if isCargoTerminal then return end

					for i = 2, #params.terminals[t].centrePlatformsRelative - 1, 2 do
						local cpl = params.terminals[t].centrePlatformsRelative[i]
						-- local era = cpl.era or moduleHelpers.eras.era_c.prefix
						local era = moduleHelpers.getEraPrefix(params, t, i)
						local mySpacing = {3, -0.1, 1, 1}
						local myTransf = transfUtilsUG.mul(
								moduleHelpers.getPlatformObjectTransf_AlwaysVertical(cpl.posTanX2),
								{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1 }
							)
						if cpl.type == 2 then -- tunnels
							-- LOLLO TODO MAYBE place one automatically when... When? When adding a subway?
							table.insert(result.slots, {
								-- height = 0,
								id = result.mangleId(t, i, _constants.idBases.tunnelStairsUpSlotId),
								spacing = mySpacing,
								transf = myTransf,
								type = _constants.tunnelStairsUpModuleType,
							})
							table.insert(result.slots, {
								-- height = 0,
								id = result.mangleId(t, i, _constants.idBases.tunnelStairsUpDownSlotId),
								spacing = mySpacing,
								transf = myTransf,
								type = _constants.tunnelStairsUpDownModuleType,
							})
						else -- ground and bridges
							local myId = result.mangleId(t, i, _constants.idBases.underpassSlotId)
							table.insert(result.slots, {
								-- height = 0,
								id = myId,
								-- shape 0 1 2 3, only graphical
								spacing = mySpacing,
								transf = myTransf,
								type = _constants.underpassModuleType,
							})
							if params.modules[myId] ~= nil then
								local underpassFloorModelId = _constants.era_c_underpassGroundModelFileName
								if era == moduleHelpers.eras.era_b.prefix then underpassFloorModelId = _constants.era_b_underpassGroundModelFileName
								elseif era == moduleHelpers.eras.era_a.prefix then underpassFloorModelId = _constants.era_a_underpassGroundModelFileName
								end
								result.models[#result.models+1] = {
									id = underpassFloorModelId,
									transf = transfUtilsUG.mul(
										moduleHelpers.getPlatformObjectTransf_WithYRotation(cpl.posTanX2),
										{ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, _laneZ, 1 }
									),
								}
							end
						end
					end
				end
				_addUpDownSlots()
			end -- loop over terminals

			local _addSubwaySlots = function()
				-- logger.print('_addSubwaySlots starting, params.subways =') logger.debugPrint(params.subways)
				if not(params.subways) then return end

				for slotId, subway in pairs(params.subways) do
					if params.modules[slotId] ~= nil then
						local extraData = params.subways[slotId]
						if extraData == nil then
							print ('ERROR: subway[', slotId, '] not found')
						else
							if extraData.transf == nil then
								print ('ERROR: subway[', slotId, '] has no transf')
							else
								-- logger.print('extraData =') logger.debugPrint(extraData)
								table.insert(result.slots, {
									-- height = 0,
									id = slotId,
									spacing = {1, 1, 1, 1},
									transf = transfUtilsUG.mul(params.inverseMainTransf, extraData.transf),
									type = _constants.subwayModuleType,
								})
							end
						end
					end
				end
				logger.print('_addSubwaySlots ending')
			end
			_addSubwaySlots()

			-- logger.print('params.upgrade =') logger.debugPrint(params.upgrade)

			result.terminateConstructionHook = function()
				logger.print('terminateConstructionHook starting')
				-- xpcall(
				-- 	function()
				local _getAllPositions_UndergroundTop_GroundBottom = function()
					local results = {}
					for t = 1, #params.terminals do
						results[t] = {}
						arrayUtils.concatValues(results[t], result.terminateConstructionHookInfo.underpassPositionsOnGround[t] or {})
						arrayUtils.concatValues(results[t], result.terminateConstructionHookInfo.tunnelStairsTopPositions[t] or {})
					end
					return results
				end

				local _getSegmentsBetweenPos2Links_AcrossTerminals = function(positionsA, positionsB, tolerancePercent4ShortDistances, isOutputLog)
					-- for each combination of terminals, return the shortest paths.
					-- sort the results so that the first index is always < the second index
					local allSegments = {}
					local minDistanceSegments = {}
					local maxT = #params.terminals
					for t = 1, maxT do
						local positionsInT = positionsA[t]
						if positionsInT ~= nil then
							for tt = 1, maxT do
								if t ~= tt then
									local t1 = math.min(t, tt)
									local t2 = math.max(t, tt)
									if minDistanceSegments[t1] == nil or minDistanceSegments[t1][t2] == nil then -- avoid repeating the same thing twice
										local positionsInTT = positionsB[tt]
										if positionsInTT ~= nil then
											for i = 1, #positionsInT do
												for ii = 1, #positionsInTT do
                                                    local distance = transfUtils.getPositionsDistance(positionsInT[i].pos2Link, positionsInTT[ii].pos2Link)
                                                    if allSegments[t1] == nil then allSegments[t1] = {} end
                                                    if allSegments[t1][t2] == nil then allSegments[t1][t2] = {} end
                                                    table.insert(
                                                        allSegments[t1][t2],
                                                        {
                                                            t = t1,
                                                            tt = t2,
                                                            i = i,
                                                            ii = ii,
                                                            distance = distance,
                                                            pos2Link1 = positionsInT[i].pos2Link,
                                                            pos2Link2 = positionsInTT[ii].pos2Link
                                                        }
                                                    )

                                                    if minDistanceSegments[t1] == nil then minDistanceSegments[t1] = {} end
                                                    if minDistanceSegments[t1][t2] == nil or minDistanceSegments[t1][t2].distance > distance then
                                                        minDistanceSegments[t1][t2] = {
                                                            t = t1,
                                                            tt = t2,
                                                            i = i,
                                                            ii = ii,
                                                            distance = distance,
                                                            pos2Link1 = positionsInT[i].pos2Link,
                                                            pos2Link2 = positionsInTT[ii].pos2Link
                                                        }
                                                    end
												end
											end
										end
									end
								end
							end
						end
					end

					-- if I have a segment from A to B and one from B to C, and also a segment from A to C,
					-- and the latter is not much much shorter than the sum of the other two,
					-- ignore the latter.
					-- It would be finer if we run it on the short segments and check the position 1 and 2, but too expensive.
					-- remove long sides of connection triangles
					if isOutputLog then
						logger.print('allSegments before triangles=') logger.debugPrint(allSegments)
						logger.print('minDistanceSegments before triangles=') logger.debugPrint(minDistanceSegments)
					end
					for t = 1, maxT do
						for tt = t + 1, maxT do
							for ttt = tt + 1, maxT do
								if minDistanceSegments[t] ~= nil
								and minDistanceSegments[t][tt] ~= nil and minDistanceSegments[t][ttt] ~= nil
								and minDistanceSegments[tt] ~= nil
								and minDistanceSegments[tt][ttt] ~= nil
								then
									local t_tt_distance = minDistanceSegments[t][tt].distance
									local t_ttt_distance = minDistanceSegments[t][ttt].distance
									local tt_ttt_distance = minDistanceSegments[tt][ttt].distance
									local maxDistance = math.max(t_tt_distance, t_ttt_distance, tt_ttt_distance)
									if maxDistance == t_tt_distance and (maxDistance ~= t_ttt_distance or maxDistance ~= tt_ttt_distance) then
										minDistanceSegments[t][tt] = nil
									elseif maxDistance == t_ttt_distance and (maxDistance ~= t_tt_distance or maxDistance ~= tt_ttt_distance) then
										minDistanceSegments[t][ttt] = nil
									elseif maxDistance == tt_ttt_distance and (maxDistance ~= t_tt_distance or maxDistance ~= t_ttt_distance) then
										minDistanceSegments[tt][ttt] = nil
									end
								end
							end
						end
					end
					if isOutputLog then
						logger.print('minDistanceSegments after triangles=') logger.debugPrint(minDistanceSegments)
					end
                    local shortSegments = {}
                    for t = 1, maxT do
                        for tt = t + 1, maxT do
							if minDistanceSegments[t] ~= nil and minDistanceSegments[t][tt] ~= nil then
								for _, value in pairs(allSegments[t][tt]) do
									if tolerancePercent4ShortDistances == nil or value.distance / minDistanceSegments[t][tt].distance <= tolerancePercent4ShortDistances then
										if shortSegments[t] == nil then shortSegments[t] = {} end
										if shortSegments[t][tt] == nil then shortSegments[t][tt] = {} end
										table.insert(shortSegments[t][tt], value)
									end
								end
                            end
                        end
					end

					return shortSegments, minDistanceSegments
					-- return minDistances
				end

				local _linkUnderpassesAndStairs = function()
					-- link all underpasses along each platform, except on bridges
					-- repeat with stairs 2 subway
					local _linkAlong = function(positions)
						for t = 1, #params.terminals do
							local positionsInTerminal = positions[t]
							if positionsInTerminal ~= nil and #positionsInTerminal > 1 then
								local previousPosition = positionsInTerminal[1]
								for i = 2, #positionsInTerminal do
									local currentPosition = positionsInTerminal[i]
									result.models[#result.models+1] = {
										id = _constants.passengerLaneModelId,
										transf = transfUtils.get1MLaneTransf(
											previousPosition.pos2Link,
											currentPosition.pos2Link
										)
									}
									previousPosition = currentPosition
								end
							end
						end
					end
					_linkAlong(result.terminateConstructionHookInfo.tunnelStairsTopPositions)
					_linkAlong(result.terminateConstructionHookInfo.underpassPositionsOnGround)

					-- link the underpasses and the stairs 2 subway across terminals, underground
					-- I link each terminal to 1 other terminal only, the closest with an underpass.
					-- There can be multiple links if they are short enough
					-- On bridges, I only link platform lifts (no side lifts) and underpasses that are close enough.
					-- Different terminals on bridges and on or under ground are not connected together: the user must build lifts.
					local function _linkAcross(segments, maxDistance)
						local maxT = #params.terminals
						for t = 1, maxT do
							if segments[t] ~= nil then
								for tt = t + 1, maxT do
									if segments[t][tt] ~= nil then
										for _, value in pairs(segments[t][tt]) do
											if not(maxDistance) or value.distance <= maxDistance then
												result.models[#result.models+1] = {
													id = _constants.passengerLaneModelId,
													transf = transfUtils.get1MLaneTransf(
														value.pos2Link1,
														value.pos2Link2
													)
												}
											end
										end
									end
								end
							end
						end
					end

					local shortSegmentsOnGround, minDistanceSegmentsOnGround = _getSegmentsBetweenPos2Links_AcrossTerminals(
						result.terminateConstructionHookInfo.underpassPositionsOnGround,
						result.terminateConstructionHookInfo.underpassPositionsOnGround,
						1.42
					)

					-- logger.print('result.terminateConstructionHookInfo.underpassPositionsOnBridge =') logger.debugPrint(result.terminateConstructionHookInfo.underpassPositionsOnBridge)
					local shortSegmentsOnBridge, minDistanceSegmentsOnBridge = _getSegmentsBetweenPos2Links_AcrossTerminals(
						result.terminateConstructionHookInfo.underpassPositionsOnBridge,
						result.terminateConstructionHookInfo.underpassPositionsOnBridge,
						1.42
					)

					local shortSegmentsTunnelTops2Tops, minDistanceSegmentsInTunnel = _getSegmentsBetweenPos2Links_AcrossTerminals(
						result.terminateConstructionHookInfo.tunnelStairsTopPositions,
						result.terminateConstructionHookInfo.tunnelStairsTopPositions,
						1.42
					)

                    -- LOLLO TODO MAYBE link the following only once, like with subways
					local shortSegmentsTunnelTops2Surface, minDistanceSegmentsUnderground2Surface = _getSegmentsBetweenPos2Links_AcrossTerminals(
                        result.terminateConstructionHookInfo.tunnelStairsTopPositions,
                        result.terminateConstructionHookInfo.underpassPositionsOnGround,
						1.01
					)

					-- logger.print('result.terminateConstructionHookInfo.liftBottomPositions =') logger.debugPrint(result.terminateConstructionHookInfo.liftBottomPositions)
					-- logger.print('result.terminateConstructionHookInfo.tunnelStairsTopPositions =') logger.debugPrint(result.terminateConstructionHookInfo.tunnelStairsTopPositions)
					local shortSegmentsTunnelTops2BridgeBottoms, minDistanceSegments_UndergroundTop_BridgeBottom = _getSegmentsBetweenPos2Links_AcrossTerminals(
                        result.terminateConstructionHookInfo.tunnelStairsTopPositions,
                        result.terminateConstructionHookInfo.liftBottomPositions,
						1.01
					)

					local shortSegmentsTunnelTops2Bottoms, minDistanceSegmentsUnderground2Underground = _getSegmentsBetweenPos2Links_AcrossTerminals(
                        result.terminateConstructionHookInfo.tunnelStairsTopPositions,
                        result.terminateConstructionHookInfo.tunnelStairsBottomPositions,
                        1.01
                    )
                    -- Remove redundant up-down connectors.
                    -- There could be trouble with a steep underground station with two levels:
                    -- the stairs of a platform may try to join the underpass of its opposite twin,
                    -- and we cannot just check the height of either coz there is too much freedom.
					-- We try to get past it choosing the shortest path and always associating stairs down to stairs up
					-- - we never have stairs down without stairs up.
					local maxT = #params.terminals
					-- logger.print('shortSegmentsTunnelTops2Bottoms =') logger.debugPrint(shortSegmentsTunnelTops2Bottoms)
					-- logger.print('shortSegmentsTunnelTops2Tops =') logger.debugPrint(shortSegmentsTunnelTops2Tops)
					for t = 1, maxT do
						local top2BottomsT = shortSegmentsTunnelTops2Bottoms[t]
						if top2BottomsT ~= nil then
							for tt = t+1, maxT do
								local top2BottomsT_TT = top2BottomsT[tt]
								if top2BottomsT_TT ~= nil then
									local minDistanceTops2BottomsT_TT = nil
									for _, top2Bottom in pairs(top2BottomsT_TT) do
										if minDistanceTops2BottomsT_TT == nil or minDistanceTops2BottomsT_TT > top2Bottom.distance then
											minDistanceTops2BottomsT_TT = top2Bottom.distance
										end
									end
									local minDistanceTops2TopsT_TT = nil
									if shortSegmentsTunnelTops2Tops[t] and shortSegmentsTunnelTops2Tops[t][tt] then
										for _, top2Top in pairs(shortSegmentsTunnelTops2Tops[t][tt]) do
											if minDistanceTops2TopsT_TT == nil or minDistanceTops2TopsT_TT > top2Top.distance then
												minDistanceTops2TopsT_TT = top2Top.distance
											end
										end
									end
									if minDistanceTops2BottomsT_TT ~= nil and minDistanceTops2TopsT_TT ~= nil then
										if minDistanceTops2BottomsT_TT < minDistanceTops2TopsT_TT then
											shortSegmentsTunnelTops2Tops[t][tt] = {}
										else
											shortSegmentsTunnelTops2Bottoms[t][tt] = {}
										end
									end
								end
							end
						end
					end
					-- logger.print('shortSegmentsTunnelTops2Bottoms =') logger.debugPrint(shortSegmentsTunnelTops2Bottoms)
					-- logger.print('shortSegmentsTunnelTops2Tops =') logger.debugPrint(shortSegmentsTunnelTops2Tops)

                    -- logger.print('shortSegmentsOnGround =') logger.debugPrint(shortSegmentsOnGround)
					_linkAcross(shortSegmentsOnGround)
					-- logger.print('shortSegmentsOnBridge =') logger.debugPrint(shortSegmentsOnBridge)
					-- lifts can connect to other lifts on other terminals, even if they are far away and there is an S bend:
					-- we try to avoid this with maxDistance
					_linkAcross(shortSegmentsOnBridge, 40.0)
					-- logger.print('shortSegmentsTunnelTops2Tops =') logger.debugPrint(shortSegmentsTunnelTops2Tops)
					_linkAcross(shortSegmentsTunnelTops2Tops)
					-- logger.print('shortSegmentsTunnelTops2Surface =') logger.debugPrint(shortSegmentsTunnelTops2Surface)
					_linkAcross(shortSegmentsTunnelTops2Surface)
					-- logger.print('shortSegmentsTunnelTops2BridgeBottoms =') logger.debugPrint(shortSegmentsTunnelTops2BridgeBottoms)
					_linkAcross(shortSegmentsTunnelTops2BridgeBottoms)
					-- logger.print('shortSegmentsTunnelTops2Bottoms =') logger.debugPrint(shortSegmentsTunnelTops2Bottoms)
					_linkAcross(shortSegmentsTunnelTops2Bottoms)
				end
				_linkUnderpassesAndStairs()
				logger.print('passengers and stairs linked')

				local _linkPassengerPlatforms = function(maxLinkLength, positions, modelId)
					-- link platforms across terminals, on the ground, if they are close enough
					local maxT = #params.terminals
					for t = 1, maxT do
						local positionsInT = positions[t]
						if positionsInT ~= nil then
							for tt = t + 1, maxT do
								local positionsInTT = positions[tt]
								if positionsInTT ~= nil then
									for i = 1, #positionsInT do
										for ii = 1, #positionsInTT do
											if maxLinkLength == nil or transfUtils.getPositionsDistance(positionsInT[i].pos, positionsInTT[ii].pos) < maxLinkLength then
												result.models[#result.models+1] = {
													id = modelId,
													transf = transfUtils.get1MLaneTransf(
														positionsInT[i].pos,
														positionsInTT[ii].pos
													)
												}
											end
										end
									end
								end
							end
						end
					end
				end
				_linkPassengerPlatforms(6, result.terminateConstructionHookInfo.crossConnectorPositions, _constants.passengerLaneModelId)
				-- LOLLO TODO MAYBE this links a little too much coz it also crosses the platforms
				-- but it does not disturb.
				_linkPassengerPlatforms(12, result.terminateConstructionHookInfo.trackCrossingPositions, 'lollo_freestyle_train_station/passenger_lane_track_crossing.mdl')
				logger.print('passenger platforms linked')

				local _linkSubways = function()
					if not(params.subways) then return end

					local _linkSubways2 = function(positions)
						for slotId, subway in pairs(params.subways) do
							if subway == nil then
								print ('ERROR: subway[', slotId, '] not found')
							elseif subway.transf == nil then
								print ('ERROR: subway[', slotId, '] has no transf')
							elseif params.modules[slotId] ~= nil then
								local subwayPos2Link = transfUtils.transf2Position(transfUtilsUG.mul(params.inverseMainTransf, subway.transf2Link))
								local isThisSubwayConnected = false
								-- connect each subway to the nearest terminal
								local minDistance = nil
								local minDistanceI = nil
								local minDistanceT = nil
								for t = 1, #params.terminals do
									if positions[t] ~= nil then
										for i = 1, #positions[t] do
											local distance = transfUtils.getPositionsDistance(subwayPos2Link, positions[t][i].pos2Link)
											if minDistance == nil or minDistance > distance then
												minDistance = distance
												minDistanceI = i
												minDistanceT = t
											end
										end
									end
								end
								-- logger.print('terminal t = ', minDistanceT, 'about to link to subway')
								if minDistanceT ~= nil and minDistanceI ~= nil then
									-- logger.print('allPositionsUnderground[minDistanceT][minDistanceI] =') logger.debugPrint(allPositionsUnderground[minDistanceT][minDistanceI])
									result.models[#result.models+1] = {
										id = _constants.passengerLaneModelId,
										transf = transfUtils.get1MLaneTransf(
											positions[minDistanceT][minDistanceI].pos2Link,
											subwayPos2Link
										)
									}
									isThisSubwayConnected = true
								end
								if not(isThisSubwayConnected) then
									result.models[#result.models+1] = {
										id = _constants.redMessageModelFileName,
										-- transf = _constants.idTransf
										transf = transfUtilsUG.mul(params.inverseMainTransf, subway.transf),
									}
									result.labelText[#result.models - 1] = { _('SubwayCannotConnect'), _('SubwayCannotConnect') }
								end
							end
						end
					end
					_linkSubways2(_getAllPositions_UndergroundTop_GroundBottom())
					-- _linkSubways2(result.terminateConstructionHookInfo.liftBottomPositions)
				end
				_linkSubways()
				logger.print('subways linked')

		-- 	end,
		-- 	_myErrorHandler
		-- )
				-- LOLLO NOTE stations with mixed cargo and passengers seem impossible by design.
				-- There are some assertions, like allPersonEdgesHaveTransportModePerson != allPersonEdgesHaveTransportModeCargo,
				-- that point at this.
				local _groupTerminals = function()
					result.stations = { }
					if result.terminateConstructionHookInfo.isAnyCargoTerminal then
						result.stations[#result.stations+1] = {
							tag = _constants.stationCargoTag, -- in the stock station, this is 1 for cargo and 2 for passengers
							terminals = { } -- the indexes of the linked terminal groups, in base 0
						}
					end
					if result.terminateConstructionHookInfo.isAnyPassengerTerminal then
						result.stations[#result.stations+1] = {
							tag = _constants.stationPassengerTag, -- in the stock station, this is 1 for cargo and 2 for passengers
							terminals = { } -- the indexes of the linked terminal groups, in base 0
						}
					end

					for t = 1, #params.terminals do
						local isCargoTerminal = params.terminals[t].isCargo
						table.insert(
							result.terminalGroups,
							{
								tag = t - 1,
								terminals = {
									-- { 0, 0 }
								},
								-- UG TODO ask UG if they can make a parameter similar to the following,
								-- to override personEdges and personNodes.
								-- This way, I won't be bound to using a model to assign a waiting area.
								-- LOLLO NOTE there can be 1 terminal 4 1 vehicle node,
								-- n terminals 4 1 person edge,
								-- n terminals 4 1 person node
								vehicleNodeOverride = result.terminateConstructionHookInfo.vehicleNodes[t]
							}
						)

						local modelIndexesBase0 = {}
						for i = 1, #result.models do
							if slotHelpers.getTerminalFromModelTag(result.models[i].tag) == t then
								modelIndexesBase0[#modelIndexesBase0+1] = i - 1
							end
						end
						for _, modelIndex in pairs(modelIndexesBase0) do
							-- table.insert(result.terminalGroups[#result.terminalGroups].terminals, {modelIndex, t - 1}) -- NO!
							table.insert(result.terminalGroups[#result.terminalGroups].terminals, {modelIndex, 0})
						end

						local stationIndex = arrayUtils.findIndex(result.stations, 'tag', isCargoTerminal and _constants.stationCargoTag or _constants.stationPassengerTag)
						table.insert(result.stations[stationIndex].terminals, t - 1)
					end
				end
				_groupTerminals()
				logger.print('terminals grouped')

				-- it should output something like (this example has one terminal made of two adjacent bits)
				-- stock result.stations =
				-- 	{
				-- 		{
				-- 			tag = 1, -- in the stock station, this is 1 for cargo and 2 for passengers
				-- 			terminals = { 0, 2 } -- 0 and 2 are the indexes of the linked terminal groups, in base 0
				-- 		}
				-- 	}
				-- stock result.terminalGroups =
				-- {
				-- 	{
				-- 		tag = -1, -- possibly useless, try to keep them all different tho
				-- 		terminals = {
				-- 			{ 22, 0 }, -- 22 is the index of a model with a terminal, in base 0
				-- 			{ 25, 0 }, -- 0 is always 0 in the stock station, it is something like a terminal number
				-- 		},
				--		vehicleNodeOverride { 10 }, -- 10 is the index of a node in the edge lists
				-- 	}
				-- }

				-- logger.print('LOLLO lollo_freestyle_train_station leaving terminateConstructionHook')
				-- logger.print('LOLLO result = ') logger.debugPrint(result)
				-- logger.print('LOLLO result.stations = ') logger.debugPrint(result.stations)
				-- logger.print('LOLLO result.models = ') logger.debugPrint(result.models)
				-- logger.print('LOLLO result.terminalGroups = ') logger.debugPrint(result.terminalGroups)
			end -- end of terminateConstructionHook()

			-- logger.print('freestyleTrainStation.updateFn about to return')
			-- logger.print('freestyleTrainStation result =') logger.debugPrint(result)
			-- logger.print('freestyleTrainStation result.terrainAlignmentLists =') logger.debugPrint(result.terrainAlignmentLists)
			return result
		end,
 		preProcessFn = function(modules, change, three)
			-- this fires when the user adds or removes a module
			-- logger.print('LOLLO preProcessFn')
			-- logger.print('modules =') logger.debugPrint(modules)
			-- logger.print('change =') logger.debugPrint(change)

			-- default behaviour
			-- if change.added then
			-- 	modules[change.slotId] = change.module
			-- else
			-- 	modules[change.slotId] = nil
			-- end

			if change.added then
				-- remove the older platform era modules whenever one is added, in each terminal
				local nTerminalNew, _, baseIdNew = slotHelpers.demangleId(change.slotId)
				if baseIdNew == _constants.idBases.platformEraASlotId
				or baseIdNew == _constants.idBases.platformEraBSlotId
				or baseIdNew == _constants.idBases.platformEraCSlotId
				then
					for slotIdOld, _ in pairs(modules) do
						local nTerminalOld, _, baseIdOld = slotHelpers.demangleId(slotIdOld)
						if nTerminalOld == nTerminalNew
						and (baseIdOld == _constants.idBases.platformEraASlotId
							or baseIdOld == _constants.idBases.platformEraBSlotId
							or baseIdOld == _constants.idBases.platformEraCSlotId)
						then
							modules[slotIdOld] = nil
						end
					end
				end
				modules[change.slotId] = change.module
			else
				-- bar removal of modules for upgrading tracks...
				local nTerminal, _, baseId = slotHelpers.demangleId(change.slotId)
				if baseId == _constants.idBases.trackElectrificationSlotId or baseId == _constants.idBases.trackSpeedSlotId then
					local terminalSlotId = slotHelpers.mangleId(nTerminal, 0, _constants.idBases.terminalSlotId)
					-- ... if their terminal is present
					if modules[terminalSlotId] ~= nil then
						-- logger.print('barring removal of modules for upgrading tracks')
						return modules
					-- else
						-- logger.print('allowing removal of modules for upgrading tracks coz terminal does not exist')
					end
				end
				modules[change.slotId] = nil
			end
			-- airport behaviour
			-- if change.added then
			-- 	if change.slotId == landingSlotId + 1 then
			-- 		modules[landingSlotId + 0] = nil
			-- 	elseif change.slotId == landingSlotId + 0 then
			-- 		modules[landingSlotId + 1] = nil
			-- 	elseif change.slotId == landingSlotId + 2 then
			-- 		modules[landingSlotId + 3] = nil
			-- 	elseif change.slotId == landingSlotId + 3 then
			-- 		modules[landingSlotId + 2] = nil
			-- 	end
			-- 	modules[change.slotId] = change.module
			-- else
			-- 	modules[change.slotId] = nil
			-- end
			return modules
        end,
        upgradeFn = function(args)
			-- args contains the params and slotId, which is sometimes correct and sometimes -1, and no transf.
			-- it also contains:
			-- catenaryToggle = 1,
			-- catenary = 1,
			-- trackTypeToggle = 1,
			-- trackType = 1,
			-- logger.print('LOLLO upgradeFn starting, args.slotId =') logger.debugPrint(args.slotId)

			-- LOLLO NOTE when hovering on a station with the track upgrade tool,
			-- some terminals are recognised and others are not (ie args.slotId = -1)
			-- This makes upgrading tracks impossible.
			-- Workaround: let's upgrade them all!

			-- logger.print('args.catenaryToggle =') logger.debugPrint(args.catenaryToggle)
			-- logger.print('args.catenary =') logger.debugPrint(args.catenary)
			-- logger.print('args.trackTypeToggle =') logger.debugPrint(args.trackTypeToggle)
			-- logger.print('args.trackType =') logger.debugPrint(args.trackType)
			-- logger.print('args =') logger.debugPrint(arrayUtils.cloneOmittingFields(args, {'modules'}, true)) -- hangs!

			-- if args.slotId == nil or args.slotId < 0 then return {} end

			local affectedTerminals = {}
			-- logger.print('args.slotId =') logger.debugPrint(args.slotId)
			if args.slotId ~= nil and args.slotId > 0 then
				local nTerminal, _, _ = slotHelpers.demangleId(args.slotId)
				if nTerminal == nil then return {} end
				affectedTerminals[1] = nTerminal
			else
				for t = 1, #args.terminals do
					affectedTerminals[t] = t
				end
			end
			-- logger.print('affectedTerminals =') logger.debugPrint(affectedTerminals)

			local upgradeResults = {}
			for _, nTerminal in pairs(affectedTerminals) do
				local newModuleFileName = nil
				if args.catenaryToggle == 1 then
					local moduleKey = slotHelpers.mangleId(nTerminal, 0, _constants.idBases.trackElectrificationSlotId)
					local oldModuleValue = args.modules[moduleKey]
					-- logger.print('oldModuleValue =') logger.debugPrint(oldModuleValue)

					if oldModuleValue ~= nil and oldModuleValue.name ~= nil then
						if oldModuleValue.name == _constants.trackElectrificationNoModuleFileName
						or oldModuleValue.name == _constants.trackElectrificationUndefinedModuleFileName
						then
							newModuleFileName = _constants.trackElectrificationYesModuleFileName
						else
							newModuleFileName = _constants.trackElectrificationNoModuleFileName
						end
					else
						newModuleFileName = _constants.trackElectrificationYesModuleFileName
						print('WARNING: upgradeFn could not find the old module')
					end

					upgradeResults[#upgradeResults+1] = { moduleKey, newModuleFileName }
				elseif args.trackTypeToggle == 1 then
					local moduleKey = slotHelpers.mangleId(nTerminal, 0, _constants.idBases.trackSpeedSlotId)
					local oldModuleValue = args.modules[moduleKey]
					-- logger.print('oldModuleValue =') logger.debugPrint(oldModuleValue)

					if oldModuleValue ~= nil and oldModuleValue.name ~= nil then
						if oldModuleValue.name == _constants.trackSpeedSlowModuleFileName
						or oldModuleValue.name == _constants.trackSpeedUndefinedModuleFileName
						then
							newModuleFileName = _constants.trackSpeedFastModuleFileName
						else
							newModuleFileName = _constants.trackSpeedSlowModuleFileName
						end
					else
						newModuleFileName = _constants.trackSpeedFastModuleFileName
						print('WARNING: upgradeFn could not find the old module')
					end

					upgradeResults[#upgradeResults+1] = { moduleKey, newModuleFileName }
				end
			end

			-- logger.print('results =') debugPrint(upgradeResults)
			return upgradeResults

			-- The return structure is a list like:
			-- return {
			-- 		{ 10001000, "station/rail/modular_station/platform_high_speed_track.module" },
			-- 		{ 10001010, "station/rail/modular_station/platform_high_speed_track.module" },
			-- }
        end,
	}
end