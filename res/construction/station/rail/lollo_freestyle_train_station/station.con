local _constants = require('lollo_freestyle_train_station.constants')
local arrayUtils = require('lollo_freestyle_train_station.arrayUtils')
local edgeUtils = require('lollo_freestyle_train_station.edgeUtils')
local moduleHelpers = require('lollo_freestyle_train_station.moduleHelpers')
local slotHelpers = require('lollo_freestyle_train_station.slotHelpers')
local stringUtils = require('lollo_freestyle_train_station.stringUtils')
local transfUtilsUG = require 'transf'
local transfUtils = require('lollo_freestyle_train_station.transfUtils')
local vec3 = require 'vec3'


function data()
	return {
		type = 'RAIL_STATION',
		description = {
			name = _("Lollo Freestyle Train Station"),
			description = _("Lollo Freestyle Train Station."),
		},
		availability = {
			yearFrom = -1, -- 1925, -- -1,
			yearTo = -1, -- -1, -- 0
		},
		order = 5005,
		soundConfig = {
			soundSet = { name = "station_cargo_old" }
		},
		autoRemovable = false,
		skipCollision = true, -- we need this when reconfiguring
		params = { -- keep it empty or it will crash coz it won't find the params, which I pass when building the construction
            -- {
            --     key = 'fileName',
            --     name = 'File Name',
            --     values = {
            --         'dummy',
            --     },
            --     defaultIndex = 0
            -- }
        },
		updateFn = function(params)
			local getUnderpassTransf = function(posTanX2)
				print('getUnderpassTransf starting, posTanX2 =') debugPrint(posTanX2)
				local pos1 = posTanX2[1][1]
				local pos2 = posTanX2[2][1]
				-- local newTransf1 = transfUtilsUG.rotZYXTransl(
				-- 	{
				-- 		x = 0,
				-- 		y = -math.atan(pos2[3] - pos1[3], pos2[1] - pos1[1]),
				-- 		z = math.atan2(pos2[2] - pos1[2], pos2[1] - pos1[1]),
				-- 	},
				-- 	{
				-- 		x = (pos1[1] + pos2[1]) * 0.5,
				-- 		y = (pos1[2] + pos2[2]) * 0.5,
				-- 		z = (pos1[3] + pos2[3]) * 0.5,
				-- 	}
				-- )
				-- print('newTransf 1 =') debugPrint(newTransf1)
				local newTransf2 = transfUtilsUG.rotZTransl(
					math.atan2(pos2[2] - pos1[2], pos2[1] - pos1[1]),
					-- {
					-- 	x = pos1[1],
					-- 	y = pos1[2],
					-- 	z = pos1[3] + 1,
					-- }
					{
						x = (pos1[1] + pos2[1]) * 0.5,
						y = (pos1[2] + pos2[2]) * 0.5,
						z = (pos1[3] + pos2[3]) * 0.5 + 1,
					}
				)
				if true then return newTransf2 end
				print('newTransf 2 =') debugPrint(newTransf2)

				-- print('angle on Y axis (deg) with atan =') debugPrint(math.atan((pos2[3] - pos1[3]) / (pos2[1] - pos1[1])) * 180 / math.pi)
				-- print('angle on Y axis (deg) with atan2 =') debugPrint(math.atan2(pos2[3] - pos1[3], pos2[1] - pos1[1]) * 180 / math.pi)
				-- print('rotY =') debugPrint(transfUtilsUG.rotY(math.atan2(pos2[3] - pos1[3], pos2[1] - pos1[1])))

				-- if true then return newTransf2 end

				-- LOLLO TODO this is wrong. The log shows:
--[[
 				getUnderpassTransf starting, posTanX2 =
				{
					{
						{ 112.94583432614, 52.74210043538, -1.839821820744, },
						{ -4.2869175992319, -2.3746321067699, 0.092825916435686, },
					},
					{
						{ 108.64070527488, 50.402910568881, -1.7481150535168, },
						{ -4.3231888201262, -2.3036847898209, 0.090554455586243, },
					},
				}
				newTransf 1 =
				{ -0.99977319498448, -0, 0.021296915047328, 0, 0.010167700978762, -0.87867196030975, 0.47731771811051, 0, 0.018713002093186, 0.47742600072202, 0.87847267310215, 0, 110.79326980051, 51.57250550213, -1.7939684371304, 1, }
				newTransf 2 =
				{ -0.87867196030975, -0.47742600072202, 0, 0, 0.47742600072202, -0.87867196030975, 0, 0, 0, 0, 1, 0, 112.94583432614, 52.74210043538, 0.16017817925604, 1, }
				angle on Y axis (deg) =
				178.77968439184
 ]]
				-- local angle = -math.atan2(pos2[3] - pos1[3], pos2[1] - pos1[1])
				-- while angle > math.pi * 0.5 do angle = angle - math.pi end
				-- while angle < -math.pi * 0.5 do angle = angle + math.pi end
				local angle = math.atan((pos2[3] - pos1[3]) / (pos2[1] - pos1[1]))
				print('angle around Y axis, deg =', angle * 180 / math.pi)
				local newTransf3 = transfUtilsUG.mul(
					newTransf2,
					transfUtilsUG.rotY(angle)
				)
				print('newTransf 3 =') debugPrint(newTransf3)
				return newTransf3
			end

			print('updateFn starting, params =')
			-- debugPrint(params)
			debugPrint(params.modules)

			if not params.modules then params.modules = {} end

			-- LOLLO NOTE I cannot call the api from here, sigh.
			print('game =')
			if game ~= nil then
				print('game is there')
				if game.interface ~= nil then
					print('game.interface is there too')
				else
					print('game.interface is NIL')
				end
			else
				print('NIL')
			end

			print('api =')
			if api ~= nil then
                print('api is there')
            else
                print('NIL')
			end

			local result = {
				colliders = {},
				-- coord2terminalInfo = {},
                cost = 1000,
                demangleId = slotHelpers.demangleId,
                edgeLists = {},
				groundFaces = {},
				labelText = {},
                mangleId = slotHelpers.mangleId,
				models = {
					{
						id = 'lollo_freestyle_train_station/icon/blue.mdl',
						tag = 'stationTag',
                        transf = {1, 0, 0, 0,
                            0, 1, 0, 0,
                            0, 0, 1, 0,
                            0, 0, 0, 1},
					},
                },
				slotConfig = {
					[_constants.cargoTerminalModuleType] = {
						maxModules = -1,
						message = nil, --'LOLLO slotConfig message',
						skipCollisionCheck = true,
					},
					[_constants.passengerTerminalModuleType] = {
						maxModules = -1,
						message = nil, --'LOLLO slotConfig message',
						skipCollisionCheck = true,
					},
					[_constants.underpassModuleType] = {
						maxModules = -1,
						message = nil, --'LOLLO slotConfig message',
						skipCollisionCheck = true,
					}
				},
                slots = {},
				stations = {},
				terminalGroups = {},
				terrainAlignmentLists = {},
			}

			local terminateConstructionHookInfo = {
				isAnyCargoTerminal = false,
				isAnyPassengerTerminal = false,
				vehicleNodes = {}
			}
			-- LOLLO NOTE the coordinates in terminals are absolute
			local mainTransf = params.mainTransf
			local inverseMainTransf = transfUtils.getInverseTransf(mainTransf)
			-- print('inverseMainTransf =') debugPrint(inverseMainTransf)

			for t = 1, #params.terminals do
				local isCargoTerminal = params.terminals[t].isCargo
				if isCargoTerminal then terminateConstructionHookInfo.isAnyCargoTerminal = true else terminateConstructionHookInfo.isAnyPassengerTerminal = true end

				-- add track edges
				for i = 1, #params.terminals[t].trackEdgeLists do
					local tel = params.terminals[t].trackEdgeLists[i]
					local newEdgeList = {
						edges = transfUtils.getPosTanX2Transformed(tel.posTanX2, inverseMainTransf),
						edgeType = tel.edgeType,
						edgeTypeName = tel.edgeTypeName,
						freeNodes = {},
						params = {
							type = tel.trackTypeName,
							catenary = tel.catenary
						},
						snapNodes = {},
						-- tag2Nodes = {},
						type = 'TRACK'
					}

					if i == 1 then
						newEdgeList.snapNodes[#newEdgeList.snapNodes+1] = 0
					end
					if i == #params.terminals[t].trackEdgeLists then
						newEdgeList.snapNodes[#newEdgeList.snapNodes+1] = 1
					end

					-- LOLLO NOTE the edges won't snap to the neighbours
					-- unless you rebuild those neighbours, by hand or by script,
					-- and make them snap to the station own nodes.
					result.edgeLists[#result.edgeLists+1] = newEdgeList
				end
				terminateConstructionHookInfo.vehicleNodes[t] = #result.edgeLists * 2 - 2

				-- this is only a test to see if the transformation was ok. They match beautifully! Use this when talking to UG.
				-- if #result.edgeLists > 0 then
				-- 	local firstPosTanX2 = result.edgeLists[1].edges
				-- 	print('firstPosTanX2 =') debugPrint(firstPosTanX2)
				-- 	local retransformedFirstEdge = transfUtils.getPosTanX2Transformed(firstPosTanX2, params.myTransf)
				-- 	print('retransformed first edge =') debugPrint(retransformedFirstEdge)
				-- end

				-- add platform edges
				for i = 1, #params.terminals[t].platformEdgeLists do
					local pel = params.terminals[t].platformEdgeLists[i]

					local newEdgeList = {
						edges = transfUtils.getPosTanX2Transformed(pel.posTanX2, inverseMainTransf),
						edgeType = pel.edgeType,
						edgeTypeName = pel.edgeTypeName,
						freeNodes = {},
						params = {
							type = pel.trackTypeName,
							catenary = false --pel.catenary
						},
						snapNodes = {},
						-- tag2Nodes = {},
						type = 'TRACK'
					}

					result.edgeLists[#result.edgeLists+1] = newEdgeList
				end

				-- add waiting areas
				if isCargoTerminal then
					for i = 1, #params.terminals[t].waitingAreaPositions do
						result.models[#result.models+1] = {
							id = _constants.cargoWaitingAreaModelId,
							tag = slotHelpers.mangleModelTag(t, true),
							transf = moduleHelpers.getWaitingAreaTransf(
								params.terminals[t].waitingAreaPositions[i],
								inverseMainTransf
							)
						}
					end
				else
					for i = 1, #params.terminals[t].waitingAreaPositions do
						local slotId = result.mangleId(t, i, _constants.idBases.underpassSlotId)
						result.models[#result.models+1] = {
							id = params.modules[slotId] == nil and _constants.passengersWaitingAreaModelId or _constants.passengersWaitingAreaUnderpassModelId,
							tag = slotHelpers.mangleModelTag(t, false),
							transf = moduleHelpers.getWaitingAreaTransf(
								params.terminals[t].waitingAreaPositions[i],
								inverseMainTransf
							)
						}
					end
				end

				-- add terminal slots
				local midTransf = moduleHelpers.getWaitingAreaTransf(
					params.terminals[t].waitingAreaPositions[math.ceil(#params.terminals[t].waitingAreaPositions * 0.5)],
					inverseMainTransf
				)
				-- print('midTransf = ') debugPrint(midTransf)
				table.insert(result.slots, {
					-- height = 0.6,
					id = result.mangleId(t, 0, _constants.idBases.terminalSlotId),
					-- shape 0 1 2 3
					shape = 3,
					spacing = _constants.trackSpacing,
					-- transf = _constants.idTransf,
					transf = midTransf,
					type = isCargoTerminal and _constants.cargoTerminalModuleType or _constants.passengerTerminalModuleType,
				})

				-- add underpass slots
				-- LOLLO TODO link the underpasses: 1 underground 2 overground
				-- To make the paths clean, replace one waiting area with an underpass.
				-- LOLLO TODO fix the transf, it rotates too much around the Y axis
				if not(isCargoTerminal) then
					for i = 2, #params.terminals[t].waitingAreaPositions - 1, 4 do
						local wap = params.terminals[t].waitingAreaPositions[i]
						local posTanX2 = transfUtils.getPosTanX2Transformed(wap.posTanX2, inverseMainTransf)
						table.insert(result.slots, {
							-- height = 1,
							id = result.mangleId(t, i, _constants.idBases.underpassSlotId),
							-- shape 0 1 2 3
							-- shape = 3,
							spacing = _constants.underpassSpacing,
							transf = getUnderpassTransf(posTanX2),
							type = _constants.underpassModuleType,
						})
					end
				end
			end -- loop over terminals

			result.terminateConstructionHook = function()
				-- print('terminateConstructionHook starting')
				-- LOLLO NOTE stations with mixed cargo and passengers seem impossible by design.
				-- There are some assertions, like allPersonEdgesHaveTransportModePerson != allPersonEdgesHaveTransportModeCargo,
				-- that point at this.
				result.stations = { }
				if terminateConstructionHookInfo.isAnyCargoTerminal then
					result.stations[#result.stations+1] = {
						tag = 0, -- in the stock station, this is 0 for cargo and 1 for passengers
						terminals = { } -- 0 is the position of the linked terminal group, in base 0
					}
				end
				if terminateConstructionHookInfo.isAnyPassengerTerminal then
					result.stations[#result.stations+1] = {
						tag = 1, -- in the stock station, this is 0 for cargo and 1 for passengers
						terminals = { } -- 0 is the position of the linked terminal group, in base 0
					}
				end

				for t = 1, #params.terminals do
					local isCargoTerminal = params.terminals[t].isCargo
					table.insert(
						result.terminalGroups,
						{
							tag = t - 1,
							terminals = {
								-- { 0, 0 }
							},
							-- UG TODO ask UG if they can make a parameter similar to the following,
							-- to override personEdges and personNodes.
							-- This way, I won't be bound to using a model to assign a waiting area.
							-- LOLLO NOTE there can be 1 terminal 4 1 vehicle node,
							-- n terminals 4 1 person edge,
							-- n terminals 4 1 person node
							-- vehicleNodeOverride = #params.terminals[t].trackEdgeLists - 1
							vehicleNodeOverride = terminateConstructionHookInfo.vehicleNodes[t]
						}
					)

					local modelIndexesBase0 = {}
					for i = 1, #result.models do
						if slotHelpers.getTerminalFromModelTag(result.models[i].tag) == t then
							modelIndexesBase0[#modelIndexesBase0+1] = i - 1
						-- elseif result.models[i].slotId ~= nil then
						-- 	local nTerminal, _, _ = slotHelpers.demangleId(result.models[i].slotId)
						-- 	if nTerminal == t then
						-- 		modelIndexesBase0[#modelIndexesBase0+1] = i - 1
						-- 	end
						end
					end
					for _, modelIndex in pairs(modelIndexesBase0) do
						-- table.insert(result.terminalGroups[#result.terminalGroups].terminals, {modelIndex, t - 1}) -- NO!
						table.insert(result.terminalGroups[#result.terminalGroups].terminals, {modelIndex, 0})
					end

					local stationIndex = arrayUtils.findIndex(result.stations, 'tag', isCargoTerminal and 0 or 1)
					table.insert(result.stations[stationIndex].terminals, t - 1)
				end

				-- avoid dump when configuring
				-- if #(result.stations[1].terminals) == 0 then
				-- 	print('avoiding dump when configuring')
				-- 	table.insert(result.stations[1].terminals, 0)
				-- 	print('result.stations =') debugPrint(result.stations)
				-- end

				-- it should output something like (this example has one terminal made of two adjacent bits)
				-- stock result.stations =
				-- 	{
				-- 		{
				-- 			tag = 0, -- in the stock station, this is 0 for cargo and 1 for passengers
				-- 			terminals = { 0 } -- 0 is the position of the linked terminal group, in base 0
				-- 		}
				-- 	}
				-- stock result.terminalGroups =
				-- {
				-- 	{
				-- 		tag = -1, -- possibly useless, try to keep them all different tho
				-- 		terminals = {
				-- 			{ 22, 0 }, -- 22 is the position of a model with a terminal, in base 0
				-- 			{ 25, 0 }, -- 0 is always 0 in the stock station, it is something like a terminal number
				-- 		}
				-- 	}
				-- }

				-- print('LOLLO lollo_freestyle_train_station leaving terminateConstructionHook')
				-- print('LOLLO result = ') debugPrint(result)
				-- print('LOLLO result.stations = ') debugPrint(result.stations)
				-- print('LOLLO result.models = ') debugPrint(result.models)
				-- print('LOLLO result.terminalGroups = ') debugPrint(result.terminalGroups)
			end
			-- _terminateConstructionHook()

			print('freestyleTrainStation result =') debugPrint(result)
			return result
		end,
 		-- preProcessFn = function(modules, change, three)
		-- 	-- this fires when the user adds or removes a module
		-- 	print('LOLLO preProcessFn')
		-- 	print('modules =') debugPrint(modules)
		-- 	print('change =') debugPrint(change)
		-- 	-- default behaviour
		-- 	if change.added then
		-- 		modules[change.slotId] = change.module
		-- 	else
		-- 		modules[change.slotId] = nil
		-- 	end
		-- 	-- airport behaviour
		-- 	-- if change.added then
		-- 	-- 	if change.slotId == landingSlotId + 1 then
		-- 	-- 		modules[landingSlotId + 0] = nil
		-- 	-- 	elseif change.slotId == landingSlotId + 0 then
		-- 	-- 		modules[landingSlotId + 1] = nil
		-- 	-- 	elseif change.slotId == landingSlotId + 2 then
		-- 	-- 		modules[landingSlotId + 3] = nil
		-- 	-- 	elseif change.slotId == landingSlotId + 3 then
		-- 	-- 		modules[landingSlotId + 2] = nil
		-- 	-- 	end
		-- 	-- 	modules[change.slotId] = change.module
		-- 	-- else
		-- 	-- 	modules[change.slotId] = nil
		-- 	-- end
		-- 	return modules
        -- end,
        upgradeFn = function(args, one)
            -- LOLLO TODO allow upgrading tracks.
            -- this sample is from the modular station, which puts edges in modules.
            -- I don't coz they are curved, so see what I can do.
			print('LOLLO upgradeFn starting, args =') debugPrint(args)
			print('one = ') debugPrint(one)
            local modules = {}

            local SwapModule = function(slotId, from, to)
                if args.modules[slotId] and args.modules[slotId].name == from then
                    table.insert(modules, {slotId, to})
                    return true
                end
                return false
            end
            local SwapRow = function(slotId, from, to)
                local slotId2 = slotId
                while SwapModule(slotId2, from, to) do 
                    slotId2 = slotId2 + 10
                end
                slotId2 = slotId
                while SwapModule(slotId2, from, to) do 
                    slotId2 = slotId2 - 10
                end
            end

            if args.modules[args.slotId] == nil then return {} end

            if args.catenaryToggle == 1 then 
                SwapRow(args.slotId, "station/rail/modular_station/platform_high_speed_track.module",
                    "station/rail/modular_station/platform_high_speed_track_catenary.module")
                SwapRow(args.slotId, "station/rail/modular_station/platform_track.module",
                    "station/rail/modular_station/platform_track_catenary.module")
                SwapRow(args.slotId, "station/rail/modular_station/platform_high_speed_track_catenary.module", 
                    "station/rail/modular_station/platform_high_speed_track.module")
                SwapRow(args.slotId, "station/rail/modular_station/platform_track_catenary.module", 
                    "station/rail/modular_station/platform_track.module")
            end
            if args.trackTypeToggle == 1 then 
                SwapRow(args.slotId, "station/rail/modular_station/platform_high_speed_track.module",
                    "station/rail/modular_station/platform_track.module")
                SwapRow(args.slotId, "station/rail/modular_station/platform_track.module",
                    "station/rail/modular_station/platform_high_speed_track.module")
                SwapRow(args.slotId, "station/rail/modular_station/platform_high_speed_track_catenary.module",
                    "station/rail/modular_station/platform_track_catenary.module")
                SwapRow(args.slotId, "station/rail/modular_station/platform_track_catenary.module",
                    "station/rail/modular_station/platform_high_speed_track_catenary.module")
            end

            return modules
        end,
	}
end